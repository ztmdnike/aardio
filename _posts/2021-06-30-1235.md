---
title: 大漠插件智能提示（3.1233）
---
免费版：
```
(!dm)
CreateFoobarCustom(hwnd,x,y,pic_name,trans_color,sim) = 根据指定的位图创建一个自定义形状的窗口\n参数定义:\n hwnd 整形数: 指定的窗口句柄,如果此值为0,那么就在桌面创建此窗口\n x 整形数: 左上角X坐标(相对于hwnd客户区坐标)\ny 整形数: 左上角Y坐标(相对于hwnd客户区坐标)\npic_name 字符串: 位图名字\ntrans_color 字符串: 透明色(RRGGBB)\nsim 双精度浮点数: 透明色的相似值 0.1-1.0\n返回值:\n 整形数 : 创建成功的窗口句柄\n示例:\nfoobar = dm.CreateFoobarCustom(hwnd,10,10,"菜单.bmp","FF00FF",1.0)
CreateFoobarEllipse(hwnd,x,y,w,h) = 创建一个椭圆窗口\n参数定义:\n hwnd整形数: 指定的窗口句柄,如果此值为0,那么就在桌面创建此窗口\n x整形数: 左上角X坐标(相对于hwnd客户区坐标)\ny整形数: 左上角Y坐标(相对于hwnd客户区坐标)\nw整形数: 矩形区域的宽度\nh整形数: 矩形区域的高度\n返回值:\n 整形数 : 创建成功的窗口句柄\n示例:\nfoobar = dm.CreateFoobarEllipse(hwnd,10,10,200,200)
CreateFoobarRect(hwnd,x,y,w,h) = 创建一个矩形窗口\n参数定义:\n hwnd整形数: 指定的窗口句柄,如果此值为0,那么就在桌面创建此窗口\n x整形数: 左上角X坐标(相对于hwnd客户区坐标)\ny整形数: 左上角Y坐标(相对于hwnd客户区坐标)\nw整形数: 矩形区域的宽度\nh整形数: 矩形区域的高度\n返回值:\n 整形数 : 创建成功的窗口句柄\n示例:\nfoobar = dm.CreateFoobarRect(hwnd,10,10,200,200)
CreateFoobarRoundRect(hwnd,x,y,w,h,rw,rh) = 创建一个圆角矩形窗口\n参数定义:\n hwnd整形数: 指定的窗口句柄,如果此值为0,那么就在桌面创建此窗口\n x整形数: 左上角X坐标(相对于hwnd客户区坐标)\ny整形数: 左上角Y坐标(相对于hwnd客户区坐标)\nw整形数: 矩形区域的宽度\nh整形数: 矩形区域的高度\nrw整形数: 圆角的宽度\nrh整形数: 圆角的高度\n返回值:\n 整形数 : 创建成功的窗口句柄\n示例:\nfoobar = dm.CreateFoobarRoundRect(hwnd,10,10,200,200,30,30)
FoobarClearText(hwnd) = 清除指定的Foobar滚动文本区\n参数定义:\n hwnd整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\n返回值:\n整形数 :\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarClearText(foobar)
FoobarClose(hwnd) = 关闭一个Foobar,注意,必须调用此函数来关闭窗口,用SetWindowState也可以关闭,但会造成内存泄漏.\n参数定义:\n hwnd整形数: 指定的Foobar窗口句柄\n返回值:\n 整形数:\n 0: 失败\n1: 成功\n示例:\ndm_ret = dm.FoobarClose(foobar)
FoobarDrawPic(hwnd,x,y,pic_name,trans_color) = 在指定的Foobar窗口绘制图像 此图片不能是加密的图片\n参数定义:\n hwnd整形数: 指定的Foobar窗口,注意,此句柄必须是通过CreateFoobarxxxx系列函数创建出来的\n x整形数: 左上角X坐标(相对于hwnd客户区坐标)\ny整形数: 左上角Y坐标(相对于hwnd客户区坐标)\npic_name字符串: 图像文件名\ntrans_color字符串: 图像透明色\n返回值:\n整形数 :\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarDrawPic(foobar,0,0,"menu.bmp","FF0000")
FoobarDrawText(hwnd,x,y,w,h,text,color,align) = 在指定的Foobar窗口绘制文字\n参数定义:\n hwnd整形数: 指定的Foobar窗口,注意,此句柄必须是通过CreateFoobarxxxx系列函数创建出来的\n x整形数: 左上角X坐标(相对于hwnd客户区坐标)\ny整形数: 左上角Y坐标(相对于hwnd客户区坐标)\nw整形数: 矩形区域的宽度\nh整形数: 矩形区域的高度\ntext字符串: 字符串\ncolor字符串: 文字颜色值\nalign 整形数: 取值定义如下\n1 : 左对齐\n2 : 中间对齐\n4 : 右对齐\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarDrawText(foobar,0,0,200,30,"测试","FF0000",1)
FoobarFillRect(hwnd,x1,y1,x2,y2,color) = 在指定的Foobar窗口内部填充矩形\n参数定义:\n hwnd 整形数: 指定的Foobar窗口,注意,此句柄必须是通过CreateFoobarxxxx系列函数创建出来的\n x1 整形数: 左上角X坐标(相对于hwnd客户区坐标)\ny1 整形数: 左上角Y坐标(相对于hwnd客户区坐标)\nx2 整形数: 右下角X坐标(相对于hwnd客户区坐标)\ny2 整形数: 右下角Y坐标(相对于hwnd客户区坐标)\ncolor字符串: 填充的颜色值\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarFillRect(foobar,0,0,200,200,"FF0000")
[//]: <> (FoobarLock(hwnd) = 锁定指定的Foobar窗口,不能通过鼠标来移动\n参数定义:\n hwnd整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarLock(foobar)）
FoobarPrintText(hwnd,text,color) = 向指定的Foobar窗口区域内输出滚动文字\n参数定义:\n hwnd整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\ntext字符串: 文本内容\ncolor字符串: 文本颜色\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarPrintText(foobar,"大漠测试","ff0000")\n// 用红色文字向滚动区域输出文字信息
FoobarSetFont(hwnd,font_name,size,flag) = 设置指定Foobar窗口的字体\n参数定义:\n hwnd整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\nfont_name字符串: 系统字体名,注意,必须保证系统中有此字体\nsize整形数: 字体大小\nflag整形数: 取值定义如下\n0 : 正常字体\n1 : 粗体\n2 : 斜体\n4 : 下划线\n文字可以是以上的组合 比如粗斜体就是1+2,斜体带下划线就是:2+4等.\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarSetFont(foobar,"宋体",25,2+4)
FoobarSetSave(hwnd,file,enable,header) = 设置保存指定的Foobar滚动文本区信息到文件.\n参数定义:\n hwnd 整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\nfile 字符串: 保存的文件名\nenable 整形数: 取值如下\n              0 : 关闭向文件输出 (默认是0)\n              1 : 开启向文件输出\nheader 字符串: 输出的附加头信息. (比如行数 日期 时间信息) 格式是如下格式串的顺序组合.如果为空串，表示无附加头.\n              "%L0nd%" 表示附加头信息带有行号，并且是按照十进制输出. n表示按多少个十进制数字补0对齐. 比如"%L04d%",输出的行号为0001  0002 0003等. "%L03d",输出的行号为001 002 003..等.\n              "%L0nx%"表示附加头信息带有行号，并且是按照16进制小写输出. n表示按多少个16进制数字补0对齐. 比如"%L04x%",输出的行号为0009  000a 000b等. "%L03x",输出的行号为009 00a 00b..等.\n              "%L0nX%"表示附加头信息带有行号，并且是按照16进制大写输出. n表示按多少个16进制数字补0对齐. 比如"%L04X%",输出的行号为0009  000A 000B等. "%L03X",输出的行号为009 00A 00B..等.\n              "[//]:#(%yyyy%)"表示年. 比如2012\n              "%MM%"表示月. 比如12\n              "%dd%"表示日. 比如28\n              "%hh%"表示小时. 比如13\n              "%mm%"表示分钟. 比如59\n              "%ss%"表示秒. 比如48.\n返回值:\n整形数 :\n 0 : 失败\n1 : 成功\n示例:\n// 开启输出，并且按原始信息输出. 无附加头.\n dm.FoobarSetSave foobar,"output.txt",1,""\n// 开启输出，并且按行号信息输出.\n dm.FoobarSetSave foobar,"output.txt",1,"【%L04d%】"\n // 这个输出的信息类似如下\n 【0001】…\n 【0002】…\n 【0003】…\n// 开启输出，并且按年月日的方式输出.\n dm.FoobarSetSave foobar,"output.txt",1,"[//]:#({%yyyy%-%MM%-%dd%}) "\n // 这个输出的信息类似如下\n {2008-01-01} …\n {2008-01-01} …\n {2008-01-01} …\n {2008-01-01} …  \n// 开启输出，并且按时分秒的方式输出.\n dm.FoobarSetSave foobar,"output.txt",1,"{%hh%-%mm%-%ss%} "\n // 这个输出的信息类似如下\n {13-04-45} …\n {13-04-48} …\n {13-04-50} …\n// 开启输出，并且按照行号 时分的方式输出\n dm.FoobarSetSave foobar,"output.txt",1,"[%L03d%] (%hh%-%mm%)"\n // 这个输出的信息类似如下\n [001] (23-16)…\n [002] (23-17)…\n [003] (23-20)…
FoobarTextLineGap(hwnd,line_gap) = 设置滚动文本区的文字行间距,默认是3\n参数定义:\n hwnd 整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\nline_gap 整形数: 文本行间距\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarTextLineGap(foobar,5)
FoobarTextPrintDir(hwnd,dir) = 设置滚动文本区的文字输出方向,默认是0\n参数定义:\n hwnd 整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\ndir 整形数: 0 表示向下输出\n    : 1 表示向上输出\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarTextPrintDir(foobar,1)
FoobarTextRect(hwnd,x,y,w,h) = 设置指定Foobar窗口的滚动文本框范围,默认的文本框范围是窗口区域\n参数定义:\n hwnd 整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\nx 整形数: x坐标\ny 整形数: y坐标\nw 整形数: 宽度\nh 整形数: 高度\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarTextRect(foobar,10,10,100,200)
FoobarUnlock(hwnd) = 解锁指定的Foobar窗口,可以通过鼠标来移动\n参数定义:\n hwnd 整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarUnlock(foobar)
FoobarUpdate(hwnd) = 刷新指定的Foobar窗口\n参数定义:\n hwnd 整形数: 指定的Foobar窗口,注意,此句柄必须是通过CreateFoobarxxxx系列函数创建出来的\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarUpdate(foobar)\n注意： 所有绘制完成以后,必须通过调用此函数来刷新窗口,否则窗口内容不会改变.
DoubleToData(value) = 把双精度浮点数转换成二进制形式.\n 参数定义:\n value 双精度浮点数: 需要转化的双精度浮点数\n返回值:\n字符串:\n 字符串形式表达的二进制数据. 可以用于WriteData FindData FindDataEx等接口.\n示例:\ndouble_data =  dm.DoubleToData(1.24)\n dm_ret = dm.FindData(hwnd,"00000000-7fffffff",double_data)
FindDouble(hwnd, addr_range, double_value_min, double_value_max) = 搜索指定的双精度浮点数,默认步长是1.如果要定制步长，请用FindDoubleEx\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr_range 字符串: 指定搜索的地址集合，字符串类型，这个地方可以是上次FindXXX的返回地址集合,可以进行二次搜索.(类似CE的再次扫描)\n             如果要进行地址范围搜索，那么这个值为的形如如下(类似于CE的新搜索)\n            "00400000-7FFFFFFF" "80000000-BFFFFFFF" "00000000-FFFFFFFF" 等.\ndouble_value_min 双精度浮点数: 搜索的双精度数值最小值\ndouble_value_max 双精度浮点数: 搜索的双精度数值最大值 \n 最终搜索的数值大与等于double_value_min,并且小于等于double_value_max\n返回值:\n字符串:\n 返回搜索到的地址集合，地址格式如下:\n"addr1|addr2|addr3…|addrn"\n比如"400050|423435|453430"\n示例:\n// 全局搜索\n result = dm.FindDouble(hwnd,"00000000-FFFFFFFF",0.5,1.0)\n if len(result) = 0 then\n      MessageBox "找不到"\n      EndScript\n end if\n result = split(result,"|")\n count = ubound(result)+1\n MessageBox "找到"&count&"个地址"\n 注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。
FindFloat(hwnd, addr_range, float_value_min, float_value_max) = 搜索指定的单精度浮点数,默认步长是1.如果要定制步长，请用FindFloatEx\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr_range 字符串: 指定搜索的地址集合，字符串类型，这个地方可以是上次FindXXX的返回地址集合,可以进行二次搜索.(类似CE的再次扫描)\n             如果要进行地址范围搜索，那么这个值为的形如如下(类似于CE的新搜索)\n            "00400000-7FFFFFFF" "80000000-BFFFFFFF" "00000000-FFFFFFFF" 等.\nfloat_value_min 单精度浮点数: 搜索的单精度数值最小值\nfloat_value_max 单精度浮点数: 搜索的单精度数值最大值 \n 最终搜索的数值大与等于float_value_min,并且小于等于float_value_max\n返回值:\n字符串:\n 返回搜索到的地址集合，地址格式如下:\n"addr1|addr2|addr3…|addrn"\n比如"400050|423435|453430"\n示例:\n// 全局搜索\n result = dm.FindFloat(hwnd,"00000000-FFFFFFFF",0.5,1.0)\n if len(result) = 0 then\n      MessageBox "找不到"\n      EndScript\n end if\n result = split(result,"|")\n count = ubound(result)+1\n MessageBox "找到"&count&"个地址"\n 注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。
FindInt(hwnd, addr_range, int_value_min, int_value_max,type) = 搜索指定的整数,默认步长是1.如果要定制步长，请用FindIntEx\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr_range 字符串: 指定搜索的地址集合，字符串类型，这个地方可以是上次FindXXX的返回地址集合,可以进行二次搜索.(类似CE的再次扫描)\n             如果要进行地址范围搜索，那么这个值为的形如如下(类似于CE的新搜索)\n            "00400000-7FFFFFFF" "80000000-BFFFFFFF" "00000000-FFFFFFFF" 等.\nint_value_min 整形数: 搜索的整数数值最小值\nint_value_max 整形数: 搜索的整数数值最大值 \n 最终搜索的数值大与等于int_value_min,并且小于等于int_value_max\ntype 整形数: 搜索的整数类型,取值如下\n      0 : 32位\n      1 : 16 位\n      2 : 8位\n返回值:\n字符串:\n 返回搜索到的地址集合，地址格式如下:\n"addr1|addr2|addr3…|addrn"\n比如"400050|423435|453430"\n示例:\n// 全局搜索\n result = dm.FindInt(hwnd,"00000000-FFFFFFFF",300,300,0)\n if len(result) = 0 then\n      MessageBox "找不到"\n      EndScript\n end if\n result = split(result,"|")\n count = ubound(result)+1\n MessageBox "找到"&count&"个地址"\n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。  
FindString(hwnd, addr_range, string_value,type) = 搜索指定的字符串,默认步长是1.如果要定制步长，请用FindStringEx\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr_range 字符串: 指定搜索的地址集合，字符串类型，这个地方可以是上次FindXXX的返回地址集合,可以进行二次搜索.(类似CE的再次扫描)\n             如果要进行地址范围搜索，那么这个值为的形如如下(类似于CE的新搜索)\n            "00400000-7FFFFFFF" "80000000-BFFFFFFF" "00000000-FFFFFFFF" 等.\nstring_value 字符串: 搜索的字符串\ntype 整形数: 搜索的字符串类型,取值如下\n      0 : Ascii字符串\n      1 : Unicode字符串\n返回值:\n字符串:\n 返回搜索到的地址集合，地址格式如下:\n"addr1|addr2|addr3…|addrn"\n比如"400050|423435|453430"\n示例:\n// 全局搜索\n result = dm.FindString(hwnd,"00000000-FFFFFFFF","哈哈哈哈",0)\n if len(result) = 0 then\n      MessageBox "找不到"\n      EndScript\n end if\n result = split(result,"|")\n count = ubound(result)+1\n MessageBox "找到"&count&"个地址"\n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。  
FloatToData(value) = 把单精度浮点数转换成二进制形式.\n 参数定义:\n value 单精度浮点数: 需要转化的单精度浮点数\n返回值:\n字符串:\n 字符串形式表达的二进制数据. 可以用于WriteData FindData FindDataEx等接口.\n示例:\nfloat_data =  dm.FloatToData(1.24)\n dm_ret = dm.FindData(hwnd,"00000000-7fffffff",float_data)
GetModuleBaseAddr(hwnd,module) = 根据指定的窗口句柄，来获取对应窗口句柄进程下的指定模块的基址\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\nmodule 字符串: 模块名\n返回值:\n整形数:\n 模块的基址\n示例:\nbase_addr = dm.GetModuleBaseAddr(hwnd,"gdi32.dll")\n MessageBox  base_addr  \n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。
IntToData(value,type) = 把整数转换成二进制形式.\n 参数定义:\n value 整形数: 需要转化的整型数\n type  整形数: 取值如下:\n             0: 4字节整形数 (一般都选这个)\n             1: 2字节整形数\n             2: 1字节整形数\n返回值:\n字符串:\n 字符串形式表达的二进制数据. 可以用于WriteData FindData FindDataEx等接口.\n示例:\nint_data =  dm.IntToData(&H12345678,0)\n dm_ret = dm.FindData(hwnd,"00000000-7fffffff",int_data)
ReadData(hwnd,addr,len) = 读取指定地址的二进制数据\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\nlen 整形数: 二进制数据的长度\n返回值:\n字符串:\n 读取到的数值,以16进制表示的字符串 每个字节以空格相隔 比如"12 34 56 78 ab cd ef"\n示例:\nvalue = dm.ReadData(hwnd,"4DA678",10)\n MessageBox  value  \n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。
ReadDouble(hwnd,addr) = 读取指定地址的双精度浮点数\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\n返回值:\n双精度浮点数:\n 读取到的数值,注意这里无法判断读取是否成功\n示例:\nvalue = dm.ReadDouble(hwnd,"4DA678")\n MessageBox  value  \n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。
ReadFloat(hwnd,addr) = 读取指定地址的单精度浮点数\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\n返回值:\n单精度浮点数:\n 读取到的数值,注意这里无法判断读取是否成功\n示例:\nvalue = dm.ReadFloat(hwnd,"4DA678")\n MessageBox  value  \n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。
ReadInt(hwnd,addr,type) = 读取指定地址的整数数值，类型可以是8位，16位 或者 32位\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\ntype 整形数: 整数类型,取值如下\n      0 : 32位\n      1 : 16 位\n      2 : 8位\n返回值:\n整形数:\n 读取到的数值,注意这里无法判断读取是否成功\n示例:\nvalue = dm.ReadInt(hwnd,"4DA678",0)\n MessageBox  value  \n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。
ReadString(hwnd,addr,type,len) = 读取指定地址的字符串，可以是GBK字符串或者是Unicode字符串.(必须事先知道内存区的字符串编码方式)\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\ntype 整形数: 字符串类型,取值如下\n      0 : GBK字符串\n      1 : Unicode字符串\nlen 整形数: 需要读取的字节数目.\n返回值:\n字符串:\n 读取到的字符串,注意这里无法判断读取是否成功\n示例:\nvalue = dm.ReadString(hwnd,"4DA678",0,10)\n MessageBox  value  \n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。
StringToData(value,type) = 把字符串转换成二进制形式.\n 参数定义:\n value字符串: 需要转化的字符串\n type  整形数: 取值如下:\n             0: 返回Ascii表达的字符串\n             1: 返回Unicode表达的字符串\n返回值:\n字符串:\n 字符串形式表达的二进制数据. 可以用于WriteData FindData FindDataEx等接口.\n示例:\nstring_data =  dm.StringToData("12345678",1)\n dm_ret = dm.FindData(hwnd,"00000000-7fffffff",string_data)
WriteData(hwnd,addr,data) = 对指定地址写入二进制数据\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\ndata 字符串: 二进制数据，以字符串形式描述，比如"12 34 56 78 90 ab cd"\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.WriteData(hwnd,"4DA678","12 34 56 78 90 ab cd")\n 注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。\n注: 简单游平台不支持此接口
WriteDouble(hwnd,addr,v) = 对指定地址写入双精度浮点数\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\nv 双精度浮点数: 双精度浮点数\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.WriteDouble(hwnd,"4DA678",2.34)\n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。\n注: 简单游平台不支持此接口
WriteFloat(hwnd,addr,v) = 对指定地址写入单精度浮点数\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\nv 单精度浮点数: 单精度浮点数\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.WriteFloat(hwnd,"4DA678",2.34)\n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。\n注: 简单游平台不支持此接口
WriteInt(hwnd,addr,type,v) = 对指定地址写入整数数值，类型可以是8位，16位 或者 32位\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\ntype 整形数: 整数类型,取值如下\n      0 : 32位\n      1 : 16 位\n      2 : 8位\nv 整形数: 整形数值\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.WriteInt(hwnd,"4DA678",0,100)\n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。  \n注: 简单游平台不支持此接口
WriteString(hwnd,addr,type,v) = 对指定地址写入字符串，可以是Ascii字符串或者是Unicode字符串\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\ntype 整形数: 字符串类型,取值如下\n      0 : Ascii字符串\n      1 : Unicode字符串\nv 字符串: 字符串\n返回值:\n整形数:\n 0: 失败\n1: 成功\n示例:\ndm_ret = dm.WriteString(hwnd,"4DA678",0,"我是来测试的")\n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。\n注: 简单游平台不支持此接口
DownCpu(rate) = 降低目标窗口所在进程的CPU占用\n 参数定义:\n rate 整形数: 取值范围0到100   取值为0 表示关闭CPU优化. 这个值越大表示降低CPU效果越好.\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n dm_ret = dm.BindWindowEx(hwnd,"dx.graphic.3d","normal","normal","",0)\n dm.DownCpu 50\n注意: 此接口必须在绑定窗口成功以后调用，而且必须保证目标窗口可以支持dx.graphic.3d或者dx.graphic.3d.8或者dx.graphic.2d或者dx.graphic.2d.2方式截图，否则降低CPU无效.\n因为降低CPU是通过降低窗口刷新速度来实现，所以注意，开启此功能以后会导致窗口刷新速度变慢.  
EnableIme(enable) = 设置是否关闭绑定窗口所在进程的输入法.\n 参数定义:\n enable 整形数: 1 开启\n 0 关闭\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n// 绑定为后台\n dm_ret = dm.BindWindow(hwnd,"dx","dx","dx",101)\n …\n // 关闭输入法\n dm.EnableIme 0 \n …\n // 再开启输入法\n dm.EnableIme 1\n注: 此函数必须在绑定后调用才有效果.
EnableSpeedDx(enable) = 设置是否开启高速dx键鼠模式。 默认是关闭.\n 参数定义:\n enable 整形数: 0 关闭\n 1 开启\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm.EnableSpeedDx 1\n注: 此函数开启的后果就是，所有dx键鼠操作将不会等待，适用于某些特殊的场合(比如避免窗口无响应导致宿主进程也卡死的问题).\n EnableMouseSync和EnableKeyboardSync开启以后，此函数就无效了.\n 此函数可能在部分窗口下会有副作用，谨慎使用!!
LockInput(lock) = 禁止外部输入到指定窗口\n 参数定义:\n lock 整形数: 0关闭锁定\n        1 开启锁定(键盘鼠标都锁定)\n        2 只锁定鼠标\n        3 只锁定键盘\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n dm_ret = dm.BindWindow(hwnd,"dx","dx2","dx",0)\n dm.LockInput 1\n // 这里做需要锁定输入做的事情\n dm.LockInput 0\n注意:此接口只针对dx键鼠. 普通键鼠无效. \n 有时候，绑定为dx2 鼠标模式时(或者没有锁定鼠标位置或状态时)，在脚本处理过程中，在某个时候需要临时锁定外部输入，以免外部干扰，那么这个函数就非常有用.\n 比如某个信息，需要鼠标移动到某个位置才可以获取，但这时，如果外部干扰，那么很可能就会获取失败，所以，这时候就很有必要锁定外部输入. \n 当然，锁定完以后，记得要解除锁定，否则外部永远都无法输入了，除非解除了窗口绑定.
LockMouseRect(x1,y1,x2,y2) = 设置前台鼠标在屏幕上的活动范围.\n 参数定义:\nx1 整形数:区域的左上X坐标. 屏幕坐标.\n y1 整形数:区域的左上Y坐标. 屏幕坐标.\n x2 整形数:区域的右下X坐标. 屏幕坐标.\n y2 整形数:区域的右下Y坐标. 屏幕坐标.\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n// 限制鼠标只能在10,10,800,600区域内活动.\n dm.LockMouseRect 10,10,800,600\n …\n Sub OnScriptExit()\n     // 恢复,4个参数都是0,表示恢复鼠标活动范围为整个屏幕区域.\n     dm.LockMouseRect 0,0,0,0\n End Sub\n注: 调用此函数后，一旦有窗口切换或者窗口移动的动作，那么限制立刻失效.\n 如果想一直限制鼠标范围在指定的窗口客户区域，那么你需要启动一个线程，并且时刻监视当前活动窗口，然后根据情况调用此函数限制鼠标范围.
SetDisplayDelay(time) = 设置dx截图最长等待时间。内部默认是3000毫秒. 一般用不到调整这个.\n 参数定义:\n time  整形数: 等待时间，单位是毫秒。 注意这里不能设置的过小，否则可能会导致截图失败,从而导致图色函数和文字识别失败.\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm.SetDisplayDelay 500\n 注: 此接口仅对 图色为dx.graphic.3d   dx.graphic.3d.8  dx.graphic.2d   dx.graphic.2d.2有效. 其他图色模式无效.\n 默认情况下，截图需要等待一个延时，超时就认为截图失败. 这个接口可以调整这个延时. 某些时候或许有用.比如当窗口图色卡死(这时获取图色一定都是超时)，并且要判断窗口卡死，那么这个设置就很有用了。
UnBindWindow() = 解除绑定窗口,并释放系统资源.一般在OnScriptExit调用\n 参数定义:\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n Sub OnScriptExit()\n     dm_ret = dm.UnBindWindow() \n End Sub
AppendPicAddr(pic_info,addr,size) = 对指定的数据地址和长度，组合成新的参数. FindPicMem FindPicMemE 以及FindPicMemEx专用\n参数定义:\npic_info 字符串: 老的地址描述串\naddr 整形数: 数据地址\nsize 整形数: 数据长度\n返回值:\n 字符串:\n 新的地址描述串\n示例:\npic_info = ""\n pic_info = dm.AppendPicAddr(pic_info,12034,643)\n pic_info = dm.AppendPicAddr(pic_info,328435,8935)\n pic_info = dm.AppendPicAddr(pic_info,809234,789) 
BGR2RGB(bgr_color) = 把BGR(按键格式)的颜色格式转换为RGB\n参数定义:\n bgr_color 字符串:bgr格式的颜色字符串\n返回值:\n字符串:\n RGB格式的字符串\n示例:\n rgb_color = dm.BGR2RGB(bgr_color)
Capture(x1, y1, x2, y2, file) = 抓取指定区域(x1, y1, x2, y2)的图像,保存为file(24位位图)\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n file 字符串:保存的文件名,保存的地方一般为SetPath中设置的目录\n     当然这里也可以指定全路径名.\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm_ret = dm.Capture(0,0,2000,2000,"screen.bmp")
CaptureGif(x1, y1, x2, y2, file,delay,time) = 抓取指定区域(x1, y1, x2, y2)的动画，保存为gif格式\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n file 字符串:保存的文件名,保存的地方一般为SetPath中设置的目录\n     当然这里也可以指定全路径名.\n delay 整形数: 动画间隔，单位毫秒。 如果为0，表示只截取静态图片\n time 整形数: 总共截取多久的动画，单位毫秒。\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n// 截取动画\n dm_ret = dm.CaptureGif(0,0,2000,2000,"screen.gif",100,3000)\n // 截取静态\n dm_ret = dm.CaptureGif(0,0,2000,2000,"screen.gif",0,0)
CaptureJpg(x1, y1, x2, y2, file, quality) = 抓取指定区域(x1, y1, x2, y2)的图像,保存为file(JPG压缩格式)\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n file 字符串:保存的文件名,保存的地方一般为SetPath中设置的目录\n     当然这里也可以指定全路径名.\n quality 整形数: jpg压缩比率(1-100) 越大图片质量越好\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm_ret = dm.CaptureJpg(0,0,2000,2000,"screen.jpg",50)
CapturePng(x1,y1,x2,y2,file) = 同Capture函数，只是保存的格式为PNG.\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n file 字符串:保存的文件名,保存的地方一般为SetPath中设置的目录\n     当然这里也可以指定全路径名.  \n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm_ret = dm.CapturePng(0,0,2000,2000,"screen.png")
CapturePre(file) = 抓取上次操作的图色区域，保存为file(24位位图)\n参数定义:\n file 字符串:保存的文件名,保存的地方一般为SetPath中设置的目录\n     当然这里也可以指定全路径名.\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm_ret = dm.CapturePre("screen.bmp")\n注意，要开启此函数，必须先调用EnableDisplayDebug\n 任何图色或者文字识别函数，都可以通过这个来截取. 具体可以查看常见问题中"本机文字识别正常,别的机器为何不正常"这一节.
CmpColor(x,y,color,sim) = 比较指定坐标点(x,y)的颜色\n参数定义:\nx 整形数: X坐标\ny 整形数: Y坐标\ncolor 字符串: 颜色字符串,可以支持偏色,多色,例如 "ffffff-202020|000000-000000" 这个表示白色偏色为202020,和黑色偏色为000000.颜色最多支持10种颜色组合. 注意，这里只支持RGB颜色.\nsim 双精度浮点数: 相似度(0.1-1.0)\n返回值:\n整形数:\n 0: 颜色匹配\n 1: 颜色不匹配\n示例:\ndm_ret = dm.CmpColor(200,300,"000000-000000|ff00ff-101010",0.9)\n If dm_ret = 0 Then\n     MessageBox "相等" \n End If 
EnableDisplayDebug(enable_debug) = 开启图色调试模式，此模式会稍许降低图色和文字识别的速度.默认不开启.\n参数定义:\n enable_debug 整形数: 0 为关闭\n               1 为开启\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.EnableDisplayDebug 1\n dm_ret = dm.CapturePre("screen.bmp")
EnableGetColorByCapture(enable) = 允许调用GetColor GetColorBGR GetColorHSV 以及 CmpColor时，以截图的方式来获取颜色。\n参数定义:\nenable 整形数: 0 关闭\n         1 打开\n返回值:\n整形数:\n 0 : 失败\n 1 : 成功\n示例:\n dm.EnableGetColorByCapture 1\n TracePrint dm.GetColor(300,300)\n注 : 某些窗口上，可能GetColor会获取不到颜色，可以尝试此接口.
FindColor(x1, y1, x2, y2, color, sim, dir,intX,intY) = 查找指定区域内的颜色,颜色格式"RRGGBB-DRDGDB",注意,和按键的颜色格式相反\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n color 字符串:颜色 格式为"RRGGBB-DRDGDB",比如"123456-000000|aabbcc-202020".注意，这里只支持RGB颜色.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 \n              1: 从左到右,从下到上 \n              2: 从右到左,从上到下 \n              3: 从右到左,从下到上 \n              4：从中心往外查找\n              5: 从上到下,从左到右 \n              6: 从上到下,从右到左\n              7: 从下到上,从左到右\n              8: 从下到上,从右到左\n intX 变参指针:返回X坐标\n intY 变参指针:返回Y坐标\n 返回值: \n整形数:\n 0:没找到\n 1:找到\n示例:\n dm_ret = dm.FindColor(0,0,2000,2000,"123456-000000|aabbcc-030303|ddeeff-202020",1.0,0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n     MessageBox "找到"\n End If
FindColorE(x1, y1, x2, y2, color, sim, dir) = 查找指定区域内的颜色,颜色格式"RRGGBB-DRDGDB",注意,和按键的颜色格式相反\n易语言用不了FindColor可以用此接口来代替\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n color 字符串:颜色 格式为"RRGGBB-DRDGDB",比如"123456-000000|aabbcc-202020".注意，这里只支持RGB颜色.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 \n              1: 从左到右,从下到上 \n              2: 从右到左,从上到下 \n              3: 从右到左,从下到上 \n              4：从中心往外查找\n              5: 从上到下,从左到右 \n              6: 从上到下,从右到左\n              7: 从下到上,从左到右\n              8: 从下到上,从右到左\n 返回值: \n字符串:\n 返回X和Y坐标 形式如"x|y", 比如"100|200"\n示例:\n pos = dm.FindColorE(0,0,2000,2000,"123456-000000|aabbcc-030303|ddeeff-202020",1.0,0)\n pos = split(pos,"|")\n If int(pos(0)) > 0 Then\n     MessageBox "找到"\n End If
FindColorEx(x1, y1, x2, y2, color, sim, dir) = 查找指定区域内的所有颜色,颜色格式"RRGGBB-DRDGDB",注意,和按键的颜色格式相反\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n color 字符串:颜色 格式为"RRGGBB-DRDGDB" 比如"aabbcc-000000|123456-202020".注意，这里只支持RGB颜色.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 \n              1: 从左到右,从下到上 \n              2: 从右到左,从上到下 \n              3: 从右到左,从下到上 \n              5: 从上到下,从左到右 \n              6: 从上到下,从右到左\n              7: 从下到上,从左到右\n              8: 从下到上,从右到左  \n 返回值: \n字符串:\n 返回所有颜色信息的坐标值,然后通过GetResultCount等接口来解析 (由于内存限制,返回的颜色数量最多为1800个左右)\n示例:\n s = dm.FindColorEx(0,0,2000,2000,"123456-000000|abcdef-202020",1.0,0)\n count = dm.GetResultCount(s)\n index = 0\n Do While index < count\n     dm_ret = dm.GetResultPos(s,index,intX,intY)\n     MessageBox intX&","&intY \n     index = index + 1 \n Loop 
FindMultiColor(x1, y1, x2, y2,first_color,offset_color,sim, dir,intX,intY) = 根据指定的多点查找颜色坐标\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n first_color 字符串:颜色 格式为"RRGGBB-DRDGDB",比如"123456-000000"\n 这里的含义和按键自带Color插件的意义相同，只不过我的可以支持偏色\n 所有的偏移色坐标都相对于此颜色.注意，这里只支持RGB颜色.\n offset_color 字符串: 偏移颜色 可以支持任意多个点 格式和按键自带的Color插件意义相同\n  格式为"x1|y1|RRGGBB-DRDGDB,……xn|yn|RRGGBB-DRDGDB"\n 比如"1|3|aabbcc,-5|-3|123456-000000"等任意组合都可以，支持偏色\n 还可以支持反色模式，比如"1|3|-aabbcc,-5|-3|-123456-000000","-"表示除了指定颜色之外的颜色.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 1: 从左到右,从下到上 2: 从右到左,从上到下 3: 从右到左, 从下到上\n intX 变参指针:返回X坐标(坐标为first_color所在坐标)\n intY 变参指针:返回Y坐标(坐标为first_color所在坐标)\n 返回值: \n整形数:\n 0:没找到\n 1:找到\n示例:\n dm_ret = dm.FindMultiColor(0,0,2000,2000,"cc805b-020202","9|2|-00ff00,15|2|2dff1c-010101,6|11|a0d962,11|14|-ffffff",1.0,1,intX,intY)\n dm.MoveTo intX,intY
FindMultiColorE(x1, y1, x2, y2,first_color,offset_color,sim, dir) = 根据指定的多点查找颜色坐标\n易语言用不了FindMultiColor可以用此接口来代替\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n first_color 字符串:颜色 格式为"RRGGBB-DRDGDB",比如"123456-000000"\n 这里的含义和按键自带Color插件的意义相同，只不过我的可以支持偏色\n 所有的偏移色坐标都相对于此颜色.注意，这里只支持RGB颜色.\n offset_color 字符串: 偏移颜色 可以支持任意多个点 格式和按键自带的Color插件意义相同\n  格式为"x1|y1|RRGGBB-DRDGDB,……xn|yn|RRGGBB-DRDGDB"\n 比如"1|3|aabbcc,-5|-3|123456-000000"等任意组合都可以，支持偏色\n 还可以支持反色模式，比如"1|3|-aabbcc,-5|-3|-123456-000000","-"表示除了指定颜色之外的颜色.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 1: 从左到右,从下到上 2: 从右到左,从上到下 3: 从右到左, 从下到上  \n 返回值: \n字符串:\n 返回X和Y坐标 形式如"x|y", 比如"100|200"\n示例:\n pos = dm.FindMultiColorE(0,0,2000,2000,"cc805b-020202","9|2|-00ff00,15|2|-2dff1c-010101,6|11|a0d962,11|14|-ffffff",1.0,1)\n pos = split(pos,"|")\n dm.MoveTo int(pos(0)),int(pos(1))
FindMultiColorEx(x1, y1, x2, y2,first_color,offset_color,sim, dir) = 根据指定的多点查找所有颜色坐标\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n first_color 字符串:颜色 格式为"RRGGBB-DRDGDB",比如"123456-000000"\n 这里的含义和按键自带Color插件的意义相同，只不过我的可以支持偏色\n 所有的偏移色坐标都相对于此颜色.注意，这里只支持RGB颜色.\n offset_color 字符串: 偏移颜色 可以支持任意多个点 格式和按键自带的Color插件意义相同\n  格式为"x1|y1|RRGGBB-DRDGDB,……xn|yn|RRGGBB-DRDGDB"\n 比如"1|3|aabbcc,-5|-3|123456-000000"等任意组合都可以，支持偏色\n 还可以支持反色模式，比如"1|3|-aabbcc,-5|-3|-123456-000000","-"表示除了指定颜色之外的颜色\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 1: 从左到右,从下到上 2: 从右到左,从上到下 3: 从右到左, 从下到上  \n 返回值: \n字符串:\n 返回所有颜色信息的坐标值,然后通过GetResultCount等接口来解析(由于内存限制,返回的坐标数量最多为1800个左右)\n坐标是first_color所在的坐标\n示例:\n dm_ret = dm.FindMultiColorEx(0,0,2000,2000,"cc805b-020202","9|2|-00ff00,15|2|2dff1c-010101,6|11|a0d962,11|14|-ffffff",1.0,1)\n count = dm.GetResultCount(dm_ret)\n index = 0\n Do While index < count \n    aa = dm.GetResultPos(dm_ret,index,intX,intY)\n    dm.MoveTo intX,intY\n    index = index + 1\n    Delay  1000\n Loop
FindPic(x1, y1, x2, y2, pic_name, delta_color,sim, dir,intX, intY) = 查找指定区域内的图片,位图必须是24位色格式,支持透明色,当图像上下左右4个顶点的颜色一样时,则这个颜色将作为透明色处理.\n这个函数可以查找多个图片,只返回第一个找到的X Y坐标.\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n pic_name 字符串:图片名,可以是多个图片,比如"test.bmp|test2.bmp|test3.bmp"\n delta_color 字符串:颜色色偏 比如"203040" 表示RGB的色偏分别是20 30 40 (这里是16进制表示)\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 1: 从左到右,从下到上 2: 从右到左,从上到下 3: 从右到左, 从下到上\n intX 变参指针:返回图片左上角的X坐标\n intY 变参指针:返回图片左上角的Y坐标\n返回值:\n整形数:\n 返回找到的图片的序号,从0开始索引.如果没找到返回-1\n示例:\n dm_ret = dm.FindPic(0,0,2000,2000,"1.bmp|2.bmp|3.bmp","000000",0.9,0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n     MessageBox "找到"\n End If
FindPicE(x1, y1, x2, y2, pic_name, delta_color,sim, dir) = 查找指定区域内的图片,位图必须是24位色格式,支持透明色,当图像上下左右4个顶点的颜色一样时,则这个颜色将作为透明色处理.\n这个函数可以查找多个图片,只返回第一个找到的X Y坐标.\n易语言用不了FindPic可以用此接口来代替\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n pic_name 字符串:图片名,可以是多个图片,比如"test.bmp|test2.bmp|test3.bmp"\n delta_color 字符串:颜色色偏 比如"203040" 表示RGB的色偏分别是20 30 40 (这里是16进制表示)\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 1: 从左到右,从下到上 2: 从右到左,从上到下 3: 从右到左, 从下到上\n返回值:\n 字符串:\n 返回找到的图片序号(从0开始索引)以及X和Y坐标 形式如"index|x|y", 比如"3|100|200"\n示例:\n pos = dm.FindPicE(0,0,2000,2000,"1.bmp|2.bmp|3.bmp","000000",0.9,0)\n pos = split(pos,"|")\n If int(pos(1)) > 0 Then\n     MessageBox "找到"\n End If
FindPicEx(x1, y1, x2, y2, pic_name, delta_color,sim, dir) = 查找指定区域内的图片,位图必须是24位色格式,支持透明色,当图像上下左右4个顶点的颜色一样时,则这个颜色将作为透明色处理.\n这个函数可以查找多个图片,并且返回所有找到的图像的坐标.\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n pic_name 字符串:图片名,可以是多个图片,比如"test.bmp|test2.bmp|test3.bmp"\n delta_color 字符串:颜色色偏 比如"203040" 表示RGB的色偏分别是20 30 40 (这里是16进制表示)\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 1: 从左到右,从下到上 2: 从右到左,从上到下 3: 从右到左, 从下到上\n返回值:\n字符串:\n 返回的是所有找到的坐标格式如下:"id,x,y|id,x,y..|id,x,y" (图片左上角的坐标)\n比如"0,100,20|2,30,40" 表示找到了两个,第一个,对应的图片是图像序号为0的图片,坐标是(100,20),第二个是序号为2的图片,坐标(30,40)\n (由于内存限制,返回的图片数量最多为1500个左右)\n示例:\n dm_ret = dm.FindPicEx(0,0,2000,2000,"test.bmp|test2.bmp|test3.bmp|test4.bmp|test5.bmp","020202",1.0,0)\n If len(dm_ret) > 0 Then\n    ss = split(dm_ret,"|")\n    index = 0\n    count = UBound(ss) + 1\n    Do While index < count\n       TracePrint ss(index)\n       sss = split(ss(index),",")\n       id = int(sss(0))\n       x = int(sss(1))\n       y = int(sss(2))\n       dm.MoveTo x,y\n       Delay 1000\n       index = index+1\n    Loop\n End If
FreePic(pic_name) = 释放指定的图片,此函数不必要调用,除非你想节省内存.\n参数定义:\n pic_name 字符串: 文件名 比如"1.bmp|2.bmp|3.bmp" 等,可以使用通配符,比如\n          "*.bmp" 这个对应了所有的bmp文件\n          "a?c*.bmp" 这个代表了所有第一个字母是a 第三个字母是c 第二个字母任意的所有bmp文件\n          "abc???.bmp|1.bmp|aa??.bmp" 可以这样任意组合.\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n PutAttachment "c:\test","*.bmp"\n dm_ret = dm.SetPath("c:\test")\nall_pic = "1.bmp|2.bmp|3.bmp"\n dm_ret = dm.LoadPic(all_pic)\ndm_ret = dm.FreePic(all_pic)
GetAveHSV(x1,y1,x2,y2) = 获取范围(x1,y1,x2,y2)颜色的均值,返回格式"H.S.V"\n参数定义:\n x1 整形数: 左上角X\ny1 整形数: 左上角Y\nx2 整形数: 右下角X\ny2 整形数: 右下角Y\n返回值:\n字符串:\n 颜色字符串\n示例:\n color = dm.GetAveHSV(30,30,100,100)\n MessageBox color
GetAveRGB(x1,y1,x2,y2) = 获取范围(x1,y1,x2,y2)颜色的均值,返回格式"RRGGBB"\n参数定义:\n x1 整形数: 左上角X\ny1 整形数: 左上角Y\nx2 整形数: 右下角X\ny2 整形数: 右下角Y\n返回值:\n字符串:\n 颜色字符串\n示例:\n color = dm.GetAveRGB(30,30,100,100)\n MessageBox color
GetColor(x,y) = 获取(x,y)的颜色,颜色返回格式"RRGGBB",注意,和按键的颜色格式相反\n参数定义:\n x 整形数:X坐标\n y 整形数:Y坐标\n返回值:\n字符串:\n 颜色字符串(注意这里都是小写字符，和工具相匹配)\n示例:\n color = dm.GetColor(30,30)\n If color = "ffffff" Then\n      MessageBox "是白色"\n End If
GetColorBGR(x,y) = 获取(x,y)的颜色,颜色返回格式"BBGGRR"\n参数定义:\n x 整形数:X坐标\n y 整形数:Y坐标\n返回值:\n字符串:\n 颜色字符串(注意这里都是小写字符，和工具相匹配)\n示例:\n color = dm.GetColorBGR(30,30)\n If color = "0000ff" Then\n       MessageBox "是红色"\n End If
GetColorHSV(x,y) = 获取(x,y)的HSV颜色,颜色返回格式"H.S.V"\n参数定义:\n x 整形数:X坐标\n y 整形数:Y坐标\n返回值:\n字符串:\n 颜色字符串\n示例:\n color = dm.GetColorHSV(30,30)\n If color = "100.20.20" Then\n       MessageBox "ok"\n End If
GetColorNum(x1, y1, x2, y2, color, sim) = 获取指定区域的颜色数量,颜色格式"RRGGBB-DRDGDB",注意,和按键的颜色格式相反\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n color 字符串:颜色 格式为"RRGGBB-DRDGDB",比如"123456-000000|aabbcc-202020".注意，这里只支持RGB颜色.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n 返回值: \n整形数:\n 颜色数量\n示例:\n TracePrint dm.GetColorNum(0,0,2000,2000,"123456-000000|aabbcc-030303|ddeeff-202020",1.0)  
GetPicSize(pic_name) = 获取指定图片的尺寸，如果指定的图片已经被加入缓存，则从缓存中获取信息.\n 此接口也会把此图片加入缓存. \n参数定义:\n pic_name 字符串: 文件名 比如"1.bmp"\n返回值:\n字符串:\n 形式如 "w,h" 比如"30,20"\n示例:\n PutAttachment "c:\test","*.bmp"\n dm_ret = dm.SetPath("c:\test")\npic_size = dm.GetPicSize("1.bmp")\n pic_size = split(pic_size,",")\n w = int(pic_size(0))\n h = int(pic_size(1))\n Trace "宽度:"&w\n Trace "高度:"&h
GetScreenData(x1,y1,x2,y2) = 获取指定区域的图像,用二进制数据的方式返回,（不适合按键使用）方便二次开发.\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n返回值:\n整形数:\n 返回的是指定区域的二进制颜色数据地址,每个颜色是4个字节,表示方式为(00RRGGBB)\n示例:\n无示例,开发者都懂的。\n注意,调用完此接口后，返回的数据指针在当前dm对象销毁时，或者再次调用GetScreenData时，会自动释放.\n从2.1120版本之后，调用完此函数后，没必要再调用FreenScreenData了,插件会自动释放.
ImageToBmp(pic_name,bmp_name) = 转换图片格式为24位BMP格式.\n参数定义:\npic_name 字符串: 要转换的图片名\n bmp_name 字符串: 要保存的BMP图片名 \n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm.ImageToBmp "1.png","1.bmp"\n dm.ImageToBmp "2.jpg","2.bmp"\n dm.ImageToBmp "3.gif","3.bmp"
IsDisplayDead(x1,y1,x2,y2,t) = 判断指定的区域，在指定的时间内(秒),图像数据是否一直不变.(卡屏).\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n t  整形数:需要等待的时间,单位是秒 \n返回值:\n整形数:\n 0 : 没有卡屏，图像数据在变化.\n 1 : 卡屏. 图像数据在指定的时间内一直没有变化.\n示例:\n TracePrint dm.IsDisplayDead(0,0,100,100,5)\n注:此函数的原理是不停的截取指定区域的图像，然后比较，如果改变就立刻返回0,否则等待直到指定的时间到达.
LoadPic(pic_name) = 预先加载指定的图片,这样在操作任何和图片相关的函数时,将省去了加载图片的时间。调用此函数后,没必要一定要调用FreePic,插件自己会自动释放.\n另外,此函数不是必须调用的,所有和图形相关的函数只要调用过一次，图片会自动加入缓存.\n如果想对一个已经加入缓存的图片进行修改，那么必须先用FreePic释放此图片在缓存中占用\n的内存，然后重新调用图片相关接口，就可以重新加载此图片. \n参数定义:\n pic_name 字符串: 文件名 比如"1.bmp|2.bmp|3.bmp" 等,可以使用通配符,比如\n          "*.bmp" 这个对应了所有的bmp文件\n          "a?c*.bmp" 这个代表了所有第一个字母是a 第三个字母是c 第二个字母任意的所有bmp文件\n          "abc???.bmp|1.bmp|aa??.bmp" 可以这样任意组合.\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n PutAttachment "c:\test","*.bmp"\n dm_ret = dm.SetPath("c:\test")\nall_pic = "abc???.bmp|1.bmp|aa??.bmp"\n dm_ret = dm.LoadPic(all_pic)
MatchPicName(pic_name) = 根据通配符获取文件集合. 方便用于FindPic和FindPicEx\n参数定义:\n pic_name 字符串: 文件名 比如"1.bmp|2.bmp|3.bmp" 等,可以使用通配符,比如\n          "*.bmp" 这个对应了所有的bmp文件\n          "a?c*.bmp" 这个代表了所有第一个字母是a 第三个字母是c 第二个字母任意的所有bmp文件\n          "abc???.bmp|1.bmp|aa??.bmp" 可以这样任意组合.\n返回值:\n字符串:\n 返回的是通配符对应的文件集合，每个图片以|分割\n示例:\n PutAttachment "c:\test","*.bmp"\n dm_ret = dm.SetPath("c:\test")\nall_pic = "abc*.bmp"\n pic_name = dm.MatchPicName(all_pic)\n// 比如c:\test目录下有abc001.bmp abc002.bmp abc003.bmp\n// 那么pic_name 的值为abc001.bmp|abc002.bmp|abc003.bmp
RGB2BGR(rgb_color) = 把RGB的颜色格式转换为BGR(按键格式)\n参数定义:\n rgb_color 字符串:rgb格式的颜色字符串\n返回值:\n字符串:\n BGR格式的字符串\n示例:\n bgr_color = dm.RGB2BGR(rgb_color)
SetPicPwd(pwd) = 设置图片密码，如果图片本身没有加密，那么此设置不影响不加密的图片，一样正常使用.\n参数定义:\n pwd 字符串: 图片密码\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm_ret = dm.SetPicPwd("123")\n注意,此函数必须在使用图片之前调用.
GetBasePath() = 获取注册在系统中的dm.dll的路径.\n参数定义:\n 返回值:\n字符串:\n 返回dm.dll所在路径\n示例:\n base_path = dm.GetBasePath()\n MessageBox base_path
GetID() = 返回当前大漠对象的ID值，这个值对于每个对象是唯一存在的。可以用来判定两个大漠对象是否一致.\n参数定义:\n返回值:\n整形数:\n 当前对象的ID值.\n示例:\n TracePrint dm.GetID()
GetPath() = 获取全局路径.(可用于调试)\n参数定义:\n返回值:\n字符串:\n 以字符串的形式返回当前设置的全局路径\n示例:\n path = dm.GetPath()\n MessageBox path
Reg(reg_code,ver_info) = 非简单游平台使用，调用此函数来注册，从而使用插件的高级功能.推荐使用此函数.\n参数定义:\n reg_code 字符串: 注册码. (从大漠插件后台获取)\nver_info 字符串: 版本附加信息. 可以在后台详细信息查看. 可以任意填写. 可留空. 长度不能超过10. 并且只能包含数字和字母以及小数点. 这个版本信息不是插件版本.\n返回值:\n整形数:\n -1 : 无法连接网络,(可能防火墙拦截,如果可以正常访问大漠插件网站，那就可以肯定是被防火墙拦截)\n -2 : 进程没有以管理员方式运行. (出现在win7 vista 2008.建议关闭uac)\n 0 : 失败 (未知错误)\n 1 : 成功\n 2 : 余额不足\n 3 : 绑定了本机器，但是账户余额不足50元.\n 4 : 注册码错误\n 5 : 你的机器或者IP在黑名单列表中或者不在白名单列表中.\n -8 : 版本附加信息长度超过了10\n -9 : 版本附加信息里包含了非法字母.\n 空 : 这是不可能返回空的，如果出现空，那肯定是当前使用的版本不对,老的插件里没这个函数导致返回为空.最好参考文档中的标准写法,判断插件版本号.\n示例:\n dm_ret = dm.Reg("abcdefg","")\n if dm_ret <> 1 then\n     MessageBox "注册失败,只能使用免费功能"\n end if\n 注: 简单游平台调用此函数，不会有任何效果. 也不会扣费.\n注册码在大漠插件后台可以查看.\n此函数每个进程调用一次即可，不需要每个DM对象都调用.\n必须保证此函数在创建完对象以后立即调用，尤其必须在绑定窗口之前调用，否则可能会出现异常.\n如果有多个进程操作同个窗口，必须保证每个进程要么都调用Reg,要么都不要调用Reg，以免出现异常.
RegEx(reg_code,ver_info,ip) = 非简单游平台使用，调用此函数来注册，从而使用插件的高级功能. 可以根据指定的IP列表来注册. 新手不建议使用!\n参数定义:\n reg_code 字符串: 注册码. (从大漠插件后台获取)\nver_info 字符串: 版本附加信息. 可以在后台详细信息查看.可留空. 长度不能超过10. 并且只能包含数字和字母以及小数点. 这个版本信息不是插件版本.\nip 字符串: 插件注册的ip地址.可以用|来组合,依次对ip中的地址进行注册，直到成功. ip地址列表在VIP群中获取.\n返回值:\n整形数:\n -1 : 无法连接网络,(可能防火墙拦截,如果可以正常访问大漠插件网站，那就可以肯定是被防火墙拦截)\n -2 : 进程没有以管理员方式运行. (出现在win7 vista 2008.建议关闭uac)\n 0 : 失败 (未知错误)\n 1 : 成功\n 2 : 余额不足\n 3 : 绑定了本机器，但是账户余额不足50元.\n 4 : 注册码错误\n 5 : 你的机器或者IP在黑名单列表中或者不在白名单列表中.\n -8 : 版本附加信息长度超过了10\n -9 : 版本附加信息里包含了非法字母.\n -10 : 非法的参数ip\n 空 : 这是不可能返回空的，如果出现空，那肯定是当前使用的版本不对,老的插件里没这个函数导致返回为空.最好参考文档中的标准写法,判断插件版本号.\n示例:\n// 严重注意,这个例子的IP只是示例，实际并无效。真实IP要去VIP群里获取.\n dm_ret = dm.RegEx("abcdefg","0001","123.45.4.6|78.79.26.3")\n if dm_ret <> 1 then\n     MessageBox "注册失败,只能使用免费功能"\n end if\n 注: 简单游平台调用此函数，不会有任何效果. 也不会扣费.\n注册码在大漠插件后台可以查看.\n此函数每个进程调用一次即可，不需要每个DM对象都调用.\n必须保证此函数在创建完对象以后立即调用，尤其必须在绑定窗口之前调用，否则可能会出现异常.\n如果有多个进程操作同个窗口，必须保证每个进程要么都调用RegEx,要么都不要调用RegEx，以免出现异常.
RegExNoMac(reg_code,ver_info,ip) = 非简单游平台使用，调用此函数来注册，从而使用插件的高级功能. 可以根据指定的IP列表来注册.新手不建议使用! 此函数同RegEx函数的不同在于,此函数用于注册的机器码是不带mac地址的.\n参数定义:\n reg_code 字符串: 注册码. (从大漠插件后台获取)\nver_info 字符串: 版本附加信息. 可以在后台详细信息查看.可留空. 长度不能超过10. 并且只能包含数字和字母以及小数点. 这个版本信息不是插件版本.\nip 字符串: 插件注册的ip地址.可以用|来组合,依次对ip中的地址进行注册，直到成功. ip地址列表在VIP群中获取.\n返回值:\n整形数:\n -1 : 无法连接网络,(可能防火墙拦截,如果可以正常访问大漠插件网站，那就可以肯定是被防火墙拦截)\n -2 : 进程没有以管理员方式运行. (出现在win7 vista 2008.建议关闭uac)\n 0 : 失败 (未知错误)\n 1 : 成功\n 2 : 余额不足\n 3 : 绑定了本机器，但是账户余额不足50元.\n 4 : 注册码错误\n 5 : 你的机器或者IP在黑名单列表中或者不在白名单列表中.\n -8 : 版本附加信息长度超过了10\n -9 : 版本附加信息里包含了非法字母.\n -10 : 非法的参数ip\n 空 : 这是不可能返回空的，如果出现空，那肯定是当前使用的版本不对,老的插件里没这个函数导致返回为空.最好参考文档中的标准写法,判断插件版本号.\n示例:\n// 严重注意,这个例子的IP只是示例，实际并无效。真实IP要去VIP群里获取.\n dm_ret = dm.RegExNoMac("abcdefg","0001","123.45.4.6|78.79.26.3")\n if dm_ret <> 1 then\n     MessageBox "注册失败,只能使用免费功能"\n end if\n 注: 简单游平台调用此函数，不会有任何效果. 也不会扣费.\n注册码在大漠插件后台可以查看.\n此函数每个进程调用一次即可，不需要每个DM对象都调用.\n必须保证此函数在创建完对象以后立即调用，尤其必须在绑定窗口之前调用，否则可能会出现异常.\n如果有多个进程操作同个窗口，必须保证每个进程要么都调用RegExNoMac,要么都不要调用RegExNoMac，以免出现异常.
RegNoMac(reg_code,ver_info) = 非简单游平台使用，调用此函数来注册，从而使用插件的高级功能.推荐使用此函数. 新手不建议使用! 此函数同Reg函数的不同在于,此函数用于注册的机器码是不带mac地址的.\n参数定义:\n reg_code 字符串: 注册码. (从大漠插件后台获取)\nver_info 字符串: 版本附加信息. 可以在后台详细信息查看. 可以任意填写. 可留空. 长度不能超过10. 并且只能包含数字和字母以及小数点. 这个版本信息不是插件版本.\n返回值:\n整形数:\n -1 : 无法连接网络,(可能防火墙拦截,如果可以正常访问大漠插件网站，那就可以肯定是被防火墙拦截)\n -2 : 进程没有以管理员方式运行. (出现在win7 vista 2008.建议关闭uac)\n 0 : 失败 (未知错误)\n 1 : 成功\n 2 : 余额不足\n 3 : 绑定了本机器，但是账户余额不足50元.\n 4 : 注册码错误\n 5 : 你的机器或者IP在黑名单列表中或者不在白名单列表中.\n -8 : 版本附加信息长度超过了10\n -9 : 版本附加信息里包含了非法字母.\n 空 : 这是不可能返回空的，如果出现空，那肯定是当前使用的版本不对,老的插件里没这个函数导致返回为空.最好参考文档中的标准写法,判断插件版本号.\n示例:\n dm_ret = dm.RegNoMac("abcdefg","")\n if dm_ret <> 1 then\n     MessageBox "注册失败,只能使用免费功能"\n end if\n 注: 简单游平台调用此函数，不会有任何效果. 也不会扣费.\n注册码在大漠插件后台可以查看.\n此函数每个进程调用一次即可，不需要每个DM对象都调用.\n必须保证此函数在创建完对象以后立即调用，尤其必须在绑定窗口之前调用，否则可能会出现异常.\n如果有多个进程操作同个窗口，必须保证每个进程要么都调用RegNoMac,要么都不要调用RegNoMac，以免出现异常.
SetDisplayInput(mode) =  设定图色的获取方式，默认是显示器或者后台窗口(具体参考BindWindow)\n参数定义:\n mode 字符串: 图色输入模式 取值有以下几种\n 1.     "screen" 这个是默认的模式，表示使用显示器或者后台窗口\n 2.     "pic:file" 指定输入模式为指定的图片,如果使用了这个模式，则所有和图色相关的函数\n 均视为对此图片进行处理，比如文字识别 查找图片 颜色 等等一切图色函数.\n 需要注意的是，设定以后，此图片就已经加入了缓冲，如果更改了源图片内容，那么需要\n 释放此缓冲，重新设置.\n返回值:\n整形数:\n 0: 失败\n1: 成功\n示例:\n // 设定为默认的模式\n dm_ret = dm.SetDisplayInput("screen")\n// 设定为图片模式 图片采用相对路径模式 相对于SetPath的路径\n dm_ret = dm.SetDisplayInput("pic:test.bmp")\n// 设为图片模式 图片采用绝对路径模式\n dm_ret = dm.SetDisplayInput("pic:d:\test\test.bmp")\n// 设为图片模式 但是每次设置前 先清除缓冲\n dm_ret = dm.FreePic("test.bmp")\n dm_ret = dm.SetDisplayInput("pic:test.bmp")  
SetPath(path) = 设置全局路径,设置了此路径后,所有接口调用中,相关的文件都相对于此路径. 比如图片,字库等.\n参数定义:\n path 字符串: 路径,可以是相对路径,也可以是绝对路径\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n // 以下代码把全局路径设置到了c盘根目录\n dm_ret = dm.SetPath("c:\")\n// 如下是把全局路径设置到了相对于当前exe所在的路径\n dm.SetPath ".\MyData"\n // 以上，如果exe在c:\test\a.exe 那么，就相当于把路径设置到了c:\test\MyData
SetShowErrorMsg (show) = 设置是否弹出错误信息,默认是打开.\n参数定义:\nshow 整形数: 0表示不打开,1表示打开\n 返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.SetShowErrorMsg(0)  
Ver() = 返回当前插件版本号\n参数定义:\n返回值:\n字符串:\n 当前插件的版本描述字符串\n示例:\n // 返回版本号\n ver = dm.Ver()\n MessageBox ver
CopyFile(src_file,dst_file,over) = 拷贝文件. \n参数定义:\nsrc_file 字符串: 原始文件名\ndst_file 字符串: 目标文件名.\nover整形数: 取值如下,\n             0 : 如果dst_file文件存在则不覆盖返回.\n             1 : 如果dst_file文件存在则覆盖.\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n // 绝对路径\n dm.CopyFile "c:\123.txt","d:\456.txt",1\n // 相对路径\n dm.SetPath "c:\test_game"\n dm.CopyFile "123.txt","456.txt",1
CreateFolder(folder) = 创建指定目录. \n参数定义:\nfolder 字符串: 目录名\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n dm.CreateFolder "c:\123\456\789"
DeleteFile(file) = 删除文件. \n参数定义:\nfile 字符串: 文件名\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n // 绝对路径\n dm.DeleteFile "c:\123.txt"\n // 相对路径\n dm.SetPath "c:\test_game"\n dm.DeleteFile "123.txt"
DeleteFolder(folder) = 删除指定目录. \n参数定义:\nfolder 字符串: 目录名\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n dm.DeleteFolder "c:\123"
DeleteIni(section,key,file) = 删除指定的ini小节.  \n参数定义:\nsection 字符串: 小节名\nkey 字符串: 变量名. 如果这个变量为空串，则删除整个section小节.\nfile 字符串: ini文件名.\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n // 绝对路径\n dm.DeleteIni "Global","var1" ,"c:\test_game\cfg.ini"\n // 相对路径\n dm.SetPath "c:\test_game"\n dm.DeleteIni "Global","" ,"cfg.ini"\n注 : 此函数是多线程安全的. 多线程同时读写同个文件不会造成文件错乱.
DownloadFile(url,save_file,timeout) = 从internet上下载一个文件. \n参数定义:\nurl 字符串: 下载的url地址.\nsave_file 字符串: 要保存的文件名.\ntimeout整形数: 连接超时时间，单位是毫秒.\n返回值:\n 整形数:\n 1 : 成功\n -1 : 网络连接失败\n -2 : 写入文件失败\n示例:\n dm.DownloadFile "www.sohu.com","sohu.html",3000\ndm.DownloadFile "http://www.sohu.com","d:\sohu.html",3000
GetFileLength(file) = 获取指定的文件长度. \n参数定义:\nfile 字符串: 文件名\n返回值:\n 整形数:\n 文件长度(字节数)\n示例:\n // 绝对路径\n TracePrint dm.GetFileLength("c:\123.txt")\n // 相对路径\n dm.SetPath "c:\test_game"\n TracePrint dm.GetFileLength("123.txt")
IsFileExist(file) = 判断指定文件是否存在. \n参数定义:\nfile 字符串: 文件名\n返回值:\n 整形数:\n 0 : 不存在\n 1 : 存在\n示例:\n // 绝对路径\n TracePrint dm.IsFileExist("c:\123.txt")\n // 相对路径\n dm.SetPath "c:\test_game"\n TracePrint dm.IsFileExist("123.txt")
MoveFile(src_file,dst_file) = 移动文件. \n参数定义:\nsrc_file 字符串: 原始文件名\ndst_file 字符串: 目标文件名.\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n // 绝对路径\n dm.MoveFile "c:\123.txt","d:\456.txt"\n // 相对路径\n dm.SetPath "c:\test_game"\n dm.MoveFile "123.txt","456.txt"
ReadFile(file) = 从指定的文件读取内容. \n参数定义:\nfile 字符串: 文件\n返回值:\n 字符串:\n 读入的文件内容\n示例:\n // 绝对路径\n TracePrint dm.ReadFile("c:\123.txt")\n // 相对路径\n dm.SetPath "c:\test_game"\n TracePrint dm.ReadFile("123.txt")
ReadIni(section,key,file) = 从Ini中读取指定信息. \n参数定义:\nsection 字符串: 小节名\nkey 字符串: 变量名.\nfile 字符串: ini文件名.\n返回值:\n 字符串:\n 字符串形式表达的读取到的内容\n示例:\n // 绝对路径\n Text = dm.ReadIni("Global","var1","c:\test_game\cfg.ini")\n // 相对路径\n dm.SetPath "c:\test_game"\n Text = dm.ReadIni("Global","var1","cfg.ini")\n注 : 此函数是多线程安全的. 多线程同时读写同个文件不会造成文件错乱.
SelectDirectory() = 弹出选择文件夹对话框，并返回选择的文件夹.\n参数定义:\n返回值:\n 字符串:\n 选择的文件夹全路径\n示例:\nTracePrint dm.SelectDirectory()
SelectFile() = 弹出选择文件对话框，并返回选择的文件.\n参数定义:\n返回值:\n 字符串:\n 选择的文件全路径\n示例:\nTracePrint dm.SelectFile()
WriteFile(file,content) = 向指定文件追加字符串. \n参数定义:\nfile 字符串: 文件\ncontent 字符串: 写入的字符串.\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n // 绝对路径\n dm.WriteFile "c:\123.txt","哈哈哈"\n // 相对路径\n dm.SetPath "c:\test_game"\n dm.WriteFile "123.txt","哈哈哈"
WriteIni(section,key,value,file) = 向指定的Ini写入信息.  \n参数定义:\nsection 字符串: 小节名\nkey 字符串: 变量名.\nvalue 字符串: 变量内容\nfile 字符串: ini文件名.\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n // 绝对路径\n dm.WriteIni "Global","var1","123","c:\test_game\cfg.ini"\n // 相对路径\n dm.SetPath "c:\test_game"\n dm.WriteIni "Global","var1","123","cfg.ini"\n注 : 此函数是多线程安全的. 多线程同时读写同个文件不会造成文件错乱.
AddDict(index,dict_info) = 给指定的字库中添加一条字库信息.\n参数定义:\nindex 整形数:字库的序号,取值为0-9,目前最多支持10个字库\n dict_info 字符串:字库描述串，具体参考大漠综合工具中的字符定义\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.AddDict(0,"081101BF8020089FD10A21443F85038$记$0.0$11")  \n注意: 此函数尽量在小字库中使用，大字库中使用AddDict速度比较慢\n另，此函数是向指定的字库所在的内存中添加,而不是往文件中添加. 添加以后立刻就可以用于文字识别。无须再SetDict\n如果要保存添加进去的字库信息，需要调用SaveDict
ClearDict(index) = 清空指定的字库.\n参数定义:\nindex 整形数:字库的序号,取值为0-9,目前最多支持10个字库\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.ClearDict 0\n注意: 此函数尽量在小字库中使用，大字库中使用AddDict速度比较慢\n另外，此函数支持清空内存中的字库，而不是字库文件本身.
FetchWord(x1, y1, x2, y2, color, word) = 根据指定的范围,以及指定的颜色描述，提取点阵信息，类似于大漠工具里的单独提取.\n参数定义:\n x1 整形数:左上角X坐标\ny1 整形数:左上角Y坐标\nx2 整形数:右下角X坐标\ny2 整形数:右下角Y坐标\ncolor 字符串: 颜色格式串.注意，RGB和HSV格式都支持.\nword 字符串: 待定义的文字,不能为空，且不能为关键符号"$"\n返回值:\n字符串:\n 识别到的点阵信息，可用于AddDict\n 如果失败，返回空\n示例:\n info = dm.FetchWord(200,200,250,220,"abcdef-101010|ffffff-101010","张三")\n If len(info) > 0 Then\n     dm.AddDict 3,info\n End if\ninfo = dm.FetchWord(200,200,250,220,"b@abcdef-101010|ffffff-101010","李四")\n If len(info) > 0 Then\n     dm.AddDict 2,info\n End if\ninfo = dm.FetchWord(200,200,250,220,"b@0.100.100-0.0.0","张三")\n If len(info) > 0 Then\n     dm.AddDict 4,info\n End if\ninfo = dm.FetchWord(200,200,250,220,"0.100.100-0.0.0|100.0.0-0.0.0","王")\n If len(info) > 0 Then\n     dm.AddDict 4,info\n End if
FindStr(x1,y1,x2,y2,string,color_format,sim,intX,intY) = 在屏幕范围(x1,y1,x2,y2)内,查找string(可以是任意个字符串的组合),并返回符合color_format的坐标位置,相似度sim同Ocr接口描述.\n(多色,差色查找类似于Ocr接口,不再重述)\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串,可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例 .注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n intX 变参指针:返回X坐标 没找到返回-1\n intY 变参指针:返回Y坐标 没找到返回-1\n返回值:\n整形数:\n 返回字符串的索引 没找到返回-1, 比如"长安|洛阳",若找到长安，则返回0\n示例:\n dm_ret = dm.FindStr(0,0,2000,2000,"长安","9f2e3f-000000",1.0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\ndm_ret = dm.FindStr(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",1.0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\n// 查找时,对多行文本进行换行,换行分隔符是"|". 语法是在","后增加换行字符串.任意字符串都可以.\n dm_ret = dm.FindStr(0,0,2000,2000,"长安|洛阳","9f2e3f-000000,|",1.0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\n注: 此函数的原理是先Ocr识别，然后再查找。所以速度比FindStrFast要慢，尤其是在字库\n 很大，或者模糊度不为1.0时。\n一般字库字符数量小于100左右，模糊度为1.0时，用FindStr要快一些,否则用FindStrFast.
FindStrE(x1,y1,x2,y2,string,color_format,sim) = 在屏幕范围(x1,y1,x2,y2)内,查找string(可以是任意个字符串的组合),并返回符合color_format的坐标位置,相似度sim同Ocr接口描述.\n(多色,差色查找类似于Ocr接口,不再重述)\n易语言用不了FindStr可以用此接口来代替\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串, 可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0  \n返回值:\n字符串:\n 返回字符串序号以及X和Y坐标,形式如"id|x|y", 比如"0|100|200",没找到时，id和X以及Y均为-1，"-1|-1|-1"\n示例:\n pos = dm.FindStrE(0,0,2000,2000,"长安","9f2e3f-000000",1.0)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\npos = dm.FindStrE(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",1.0)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\n// 查找时,对多行文本进行换行,换行分隔符是"|". 语法是在","后增加换行字符串.任意字符串都可以.\n pos = dm.FindStrE(0,0,2000,2000,"长安|洛阳","9f2e3f-000000,|",1.0)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\n注: 此函数的原理是先Ocr识别，然后再查找。所以速度比FindStrFastE要慢，尤其是在字库\n 很大，或者模糊度不为1.0时。\n一般字库字符数量小于100左右，模糊度为1.0时，用FindStrE要快一些,否则用FindStrFastE.
FindStrEx(x1,y1,x2,y2,string,color_format,sim) = 在屏幕范围(x1,y1,x2,y2)内,查找string(可以是任意字符串的组合),并返回符合color_format的所有坐标位置,相似度sim同Ocr接口描述.\n(多色,差色查找类似于Ocr接口,不再重述)\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串, 可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n返回值:\n字符串:\n 返回所有找到的坐标集合,格式如下:\n "id,x0,y0|id,x1,y1|......|id,xn,yn"\n 比如"0,100,20|2,30,40" 表示找到了两个,第一个,对应的是序号为0的字符串,坐标是(100,20),第二个是序号为2的字符串,坐标(30,40)\n 示例:\n dm_ret = dm.FindStrEx(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",1.0)\n If len(dm_ret) > 0 Then\n    ss = split(dm_ret,"|")\n    index = 0\n    count = UBound(ss) + 1\n    Do While index < count\n       TracePrint ss(index)\n       sss = split(ss(index),",")\n       id = int(sss(0))\n       x = int(sss(1))\n       y = int(sss(2))\n       dm.MoveTo x,y\n       Delay 1000\n       index = index+1\n    Loop\n End If  \n注: 此函数的原理是先Ocr识别，然后再查找。所以速度比FindStrExFast要慢，尤其是在字库\n 很大，或者模糊度不为1.0时。\n一般字库字符数量小于100左右，模糊度为1.0时，用FindStrEx要快一些,否则用FindStrFastEx.
FindStrFast(x1,y1,x2,y2,string,color_format,sim,intX,intY) = 同FindStr。\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串,可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n intX 变参指针:返回X坐标 没找到返回-1\n intY 变参指针:返回Y坐标 没找到返回-1\n返回值:\n整形数:\n 返回字符串的索引 没找到返回-1, 比如"长安|洛阳",若找到长安，则返回0\n示例:\n dm_ret = dm.FindStrFast(0,0,2000,2000,"长安","9f2e3f-000000",1.0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\ndm_ret = dm.FindStrFast(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",0.9,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\n// 查找时,对多行文本进行换行,换行分隔符是"|". 语法是在","后增加换行字符串.任意字符串都可以.\n dm_ret = dm.FindStrFast(0,0,2000,2000,"长安|洛阳","9f2e3f-000000,|",0.9,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\n注: 此函数比FindStr要快很多，尤其是在字库很大时，或者模糊识别时，效果非常明显。\n 推荐使用此函数。\n 另外由于此函数是只识别待查找的字符，所以可能会有如下情况出现问题。\n比如 字库中有"张和三" 一共3个字符数据，然后待识别区域里是"张和三",如果用FindStr查找\n "张三"肯定是找不到的，但是用FindStrFast却可以找到，因为"和"这个字符没有列入查找计划中\n 所以，在使用此函数时，也要特别注意这一点。
FindStrFastE(x1,y1,x2,y2,string,color_format,sim) = 同FindStrE\n易语言用不了FindStrFast可以用此接口来代替\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串, 可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0  \n返回值:\n字符串:\n 返回字符串序号以及X和Y坐标,形式如"id|x|y", 比如"0|100|200",没找到时，id和X以及Y均为-1，"-1|-1|-1"\n示例:\n pos = dm.FindStrFastE(0,0,2000,2000,"长安","9f2e3f-000000",1.0)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\npos = dm.FindStrFastE(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",0.9)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\n// 查找时,对多行文本进行换行,换行分隔符是"|". 语法是在","后增加换行字符串.任意字符串都可以.\n pos = dm.FindStrFastE(0,0,2000,2000,"长安|洛阳","9f2e3f-000000,|",0.9)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\n注: 此函数比FindStrE要快很多，尤其是在字库很大时，或者模糊识别时，效果非常明显。\n 推荐使用此函数。\n另外由于此函数是只识别待查找的字符，所以可能会有如下情况出现问题。\n比如 字库中有"张和三" 一共3个字符数据，然后待识别区域里是"张和三",如果用FindStrE查找\n "张三"肯定是找不到的，但是用FindStrFastE却可以找到，因为"和"这个字符没有列入查找计划中\n 所以，在使用此函数时，也要特别注意这一点。
FindStrFastEx(x1,y1,x2,y2,string,color_format,sim) = 同FindStrEx\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串, 可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n返回值:\n字符串:\n 返回所有找到的坐标集合,格式如下:\n "id,x0,y0|id,x1,y1|......|id,xn,yn"\n 比如"0,100,20|2,30,40" 表示找到了两个,第一个,对应的是序号为0的字符串,坐标是(100,20),第二个是序号为2的字符串,坐标(30,40)\n 示例:\n dm_ret = dm.FindStrFastEx(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",0.9)\n If len(dm_ret) > 0 Then\n    ss = split(dm_ret,"|")\n    index = 0\n    count = UBound(ss) + 1\n    Do While index < count\n       TracePrint ss(index)\n       sss = split(ss(index),",")\n       id = int(sss(0))\n       x = int(sss(1))\n       y = int(sss(2))\n       dm.MoveTo x,y\n       Delay 1000\n       index = index+1\n    Loop\n End If  \n注: 此函数比FindStrEx要快很多，尤其是在字库很大时，或者模糊识别时，效果非常明显。\n 推荐使用此函数。\n另外由于此函数是只识别待查找的字符，所以可能会有如下情况出现问题。\n比如 字库中有"张和三" 一共3个字符数据，然后待识别区域里是"张和三",如果用FindStrEx查找\n "张三"肯定是找不到的，但是用FindStrFastEx却可以找到，因为"和"这个字符没有列入查找计划中\n 所以，在使用此函数时，也要特别注意这一点。
FindStrWithFont(x1,y1,x2,y2,string,color_format,sim,font_name,font_size,flag,intX,intY) = 同FindStr，但是不使用SetDict设置的字库，而利用系统自带的字库，速度比FindStr稍慢.\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串,可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例 .注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n font_name 字符串:系统字体名,比如"宋体"\n font_size 整形数:系统字体尺寸，这个尺寸一定要以大漠综合工具获取的为准.如果获取尺寸看视频教程.\n flag 整形数:字体类别 取值可以是以下值的组合,比如1+2+4+8,2+4. 0表示正常字体.\n     1 : 粗体\n     2 : 斜体\n     4 : 下划线\n     8 : 删除线\n intX 变参指针:返回X坐标 没找到返回-1\n intY 变参指针:返回Y坐标 没找到返回-1\n返回值:\n整形数:\n 返回字符串的索引 没找到返回-1, 比如"长安|洛阳",若找到长安，则返回0\n示例:\n dm_ret = dm.FindStrWithFont(0,0,2000,2000,"长安","9f2e3f-000000",1.0,"宋体",9,0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\ndm_ret = dm.FindStrWithFont(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",1.0,"宋体",9,1+2,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\n// 查找时,对多行文本进行换行,换行分隔符是"|". 语法是在","后增加换行字符串.任意字符串都可以.\n dm_ret = dm.FindStrWithFont(0,0,2000,2000,"长安|洛阳","9f2e3f-000000,|",1.0,"宋体",9,1+2,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\n注: 对于如何获取字体尺寸以及名字等信息，可以参考视频教程，如何使用系统字库.
FindStrWithFontE(x1,y1,x2,y2,string,color_format,sim,font_name,font_size,flag) = 同FindStrE，但是不使用SetDict设置的字库，而利用系统自带的字库，速度比FindStrE稍慢\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串, 可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n font_name 字符串:系统字体名,比如"宋体"\n font_size 整形数:系统字体尺寸，这个尺寸一定要以大漠综合工具获取的为准.如果获取尺寸看视频教程.\n flag 整形数:字体类别 取值可以是以下值的组合,比如1+2+4+8,2+4. 0表示正常字体.\n     1 : 粗体\n     2 : 斜体\n     4 : 下划线\n     8 : 删除线  \n返回值:\n字符串:\n 返回字符串序号以及X和Y坐标,形式如"id|x|y", 比如"0|100|200",没找到时，id和X以及Y均为-1，"-1|-1|-1"\n示例:\n pos = dm.FindStrWithFontE(0,0,2000,2000,"长安","9f2e3f-000000",1.0,"宋体",9,0)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\npos = dm.FindStrWithFontE(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",1.0,"宋体",9,1+2)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\n// 查找时,对多行文本进行换行,换行分隔符是"|". 语法是在","后增加换行字符串.任意字符串都可以.\n pos = dm.FindStrWithFontE(0,0,2000,2000,"长安|洛阳","9f2e3f-000000,|",1.0,"宋体",9,1+2)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\n注: 对于如何获取字体尺寸以及名字等信息，可以参考视频教程，如何使用系统字库.
FindStrWithFontEx(x1,y1,x2,y2,string,color_format,sim,font_name,font_size,flag) = 同FindStrEx，但是不使用SetDict设置的字库，而利用系统自带的字库，速度比FindStrEx稍慢\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串, 可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n font_name 字符串:系统字体名,比如"宋体"\n font_size 整形数:系统字体尺寸，这个尺寸一定要以大漠综合工具获取的为准.如果获取尺寸看视频教程.\n flag 整形数:字体类别 取值可以是以下值的组合,比如1+2+4+8,2+4. 0表示正常字体.\n     1 : 粗体\n     2 : 斜体\n     4 : 下划线\n     8 : 删除线\n返回值:\n字符串:\n 返回所有找到的坐标集合,格式如下:\n "id,x0,y0|id,x1,y1|......|id,xn,yn"\n 比如"0,100,20|2,30,40" 表示找到了两个,第一个,对应的是序号为0的字符串,坐标是(100,20),第二个是序号为2的字符串,坐标(30,40)\n 示例:\n dm_ret = dm.FindStrWithFontEx(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",1.0,"宋体",9,1+2)\n If len(dm_ret) > 0 Then\n    ss = split(dm_ret,"|")\n    index = 0\n    count = UBound(ss) + 1\n    Do While index < count\n       TracePrint ss(index)\n       sss = split(ss(index),",")\n       id = int(sss(0))\n       x = int(sss(1))\n       y = int(sss(2))\n       dm.MoveTo x,y\n       Delay 1000\n       index = index+1\n    Loop\n End If  \n注: 对于如何获取字体尺寸以及名字等信息，可以参考视频教程，如何使用系统字库.
GetDictCount(index) = 获取指定的字库中的字符数量.\n参数定义:\nindex 整形数: 字库序号(0-9)\n返回值:\n整形数:\n 字库数量\n示例:\n count = dm.GetDictCount(0)\n TracePrint "0号字库使用的字库数量是:"&count
GetDictInfo(str,font_name,font_size,flag) = 根据指定的文字，以及指定的系统字库信息，获取字库描述信息.\n参数定义:\nstr 字符串:需要获取的字符串\n font_name 字符串:系统字体名,比如"宋体"\n font_size 整形数:系统字体尺寸，这个尺寸一定要以大漠综合工具获取的为准.如何获取尺寸看视频教程.\n flag 整形数:字体类别 取值可以是以下值的组合,比如1+2+4+8,2+4. 0表示正常字体.\n     1 : 粗体\n     2 : 斜体\n     4 : 下划线\n     8 : 删除线\n返回值:\n字符串:\n 返回字库信息,每个字符的字库信息用"|"来分割\n示例:\n// 下面的代码是获取"回收站"这3个字符的字库信息，然后加入到字库1中.\n font_desc = dm.GetDictInfo("回收站","宋体",9,0)\n font_desc = split(font_desc,"|")\n count = ubound(font_desc)\n for i = 0 to count\n     TracePrint font_desc(i)\n     dm.AddDict 1,font_desc(i)\n next
GetNowDict() = 获取当前使用的字库序号(0-9)\n参数定义:\n返回值:\n整形数:\n 字库序号(0-9)\n示例:\n index = dm.GetNowDict()\n TracePrint "当前使用的字库序号是:"&index
GetResultCount(ret) = 对插件部分接口的返回值进行解析,并返回ret中的坐标个数\n参数定义:\n ret 字符串: 部分接口的返回串\n返回值:\n整形数:\n 返回ret中的坐标个数\n示例:\n s = dm.FindColorEx(0,0,2000,2000,"123456-000000|abcdef-202020",1.0,0)\n count = dm.GetResultCount(s)\n MessageBox count
GetResultPos(ret,index,intX,intY) = 对插件部分接口的返回值进行解析,并根据指定的第index个坐标,返回具体的值\n参数定义:\n ret 字符串:部分接口的返回串\n index 整形数: 第几个坐标\n intX 变参指针: 返回X坐标\n intY 变参指针: 返回Y坐标\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n s = dm.FindColorEx(0,0,2000,2000,"123456-000000|abcdef-202020",1.0,0)\n count = dm.GetResultCount(s)\n index = 0\n Do While index < count\n     dm_ret = dm.GetResultPos(s,index,intX,intY)\n     MessageBox intX&","&intY \n     index = index + 1 \n Loop
GetWordResultCount(str) = 在使用GetWords进行词组识别以后,可以用此接口进行识别词组数量的计算.\n参数定义:\n str 字符串: GetWords接口调用以后的返回值\n返回值:\n整形数:\n 返回词组数量\n示例:\n s = dm.GetWords(0,0,2000,2000,"000000-000000",1.0)\n count = dm.GetWordResultCount(s)\n MessageBox count 
GetWordResultPos(str,index,intX,intY) = 在使用GetWords进行词组识别以后,可以用此接口进行识别各个词组的坐标\n参数定义:\n str 字符串: GetWords的返回值\nindex 整形数: 表示第几个词组\nintX 变参指针: 返回的X坐标\nintY 变参指针: 返回的Y坐标\n返回值:\n整形数:\n 0: 失败\n1: 成功\n示例:\n s = dm.GetWords(0,0,2000,2000,"000000-000000",1.0)\n count = dm.GetWordResultCount(s)\n index = 0\n Do While index < count\n     dm_ret = dm.GetWordResultPos(s,index,intX,intY)\n     MessageBox intX&","&intY \n     index = index + 1 \n Loop 
GetWordResultStr(str,index) = 在使用GetWords进行词组识别以后,可以用此接口进行识别各个词组的内容\n参数定义:\n str 字符串: GetWords的返回值\nindex 整形数: 表示第几个词组\n返回值:\n字符串:\n 返回的第index个词组内容\n示例:\n s = dm.GetWords(0,0,2000,2000,"000000-000000",1.0)\n count = dm.GetWordResultCount(s)\n index = 0\n Do While index < count\n     word = dm.GetWordResultStr(s,index)\n     MessageBox word \n     index = index + 1 \n Loop 
GetWords(x1, y1, x2, y2, color, sim) = 根据指定的范围,以及设定好的词组识别参数(一般不用更改,除非你真的理解了)\n识别这个范围内所有满足条件的词组. 比较适合用在未知文字的情况下,进行不定识别.\n参数定义:\n x1 整形数:左上角X坐标\n y1 整形数:左上角Y坐标\n x2 整形数:右下角X坐标\n y2 整形数:右下角Y坐标\n color 字符串: 颜色格式串.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度 0.1-1.0 \n返回值:\n字符串:\n 识别到的格式串,要用到专用函数来解析\n示例:\n s = dm.GetWords(0,0,2000,2000,"000000-000000",1.0)\n count = dm.GetWordResultCount(s)\n index = 0\n Do While index < count\n     dm_ret = dm.GetWordResultPos(s,index,intX,intY)\n     word = dm.GetWordResultStr(s,index)\n     MessageBox intX&","&intY&","&word\n     index = index + 1 \n Loop 
GetWordsNoDict(x1, y1, x2, y2, color) = 根据指定的范围,以及设定好的词组识别参数(一般不用更改,除非你真的理解了)\n识别这个范围内所有满足条件的词组. 这个识别函数不会用到字库。只是识别大概形状的位置 \n参数定义:\n x1 整形数:左上角X坐标\ny1 整形数:左上角Y坐标\nx2 整形数:右下角X坐标\ny2 整形数:右下角Y坐标\ncolor 字符串: 颜色格式串.注意，RGB和HSV格式都支持.\n返回值:\n字符串:\n 识别到的格式串,要用到专用函数来解析\n示例:\n s = dm.GetWordsNoDict(0,0,2000,2000,"000000-000000")\n count = dm.GetResultCount(s)\n index = 0\n Do While index < count\n     dm_ret = dm.GetResultPos(s,index,intX,intY)\n     MessageBox intX&","&intY\n     index = index + 1 \n Loop 
Ocr(x1,y1,x2,y2,color_format,sim) = 识别屏幕范围(x1,y1,x2,y2)内符合color_format的字符串,并且相似度为sim,sim取值范围(0.1-1.0),\n这个值越大越精确,越大速度越快,越小速度越慢,请斟酌使用!\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n color_format 字符串:颜色格式串. 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n返回值:\n字符串:\n 返回识别到的字符串\n示例:\n //RGB单色识别\n s = dm.Ocr(0,0,2000,2000,"9f2e3f-000000",1.0)\n MessageBox s\n//RGB单色差色识别\n s = dm.Ocr(0,0,2000,2000,"9f2e3f-030303",1.0)\n MessageBox s\n//RGB多色识别(最多支持10种,每种颜色用"|"分割)\n s = dm.Ocr(0,0,2000,2000,"9f2e3f-030303|2d3f2f-000000|3f9e4d-100000",1.0)\n MessageBox s\n//HSV多色识别(最多支持10种,每种颜色用"|"分割)\n s = dm.Ocr(0,0,2000,2000,"20.30.40-0.0.0|30.40.50-0.0.0",1.0)\n MessageBox s\n//识别后,每行字符串用指定字符分割\n 比如用"|"字符分割\n s = dm.Ocr(0,0,2000,2000,"9f2e3f-000000,|",1.0)\n MessageBox s\n//比如用回车换行分割\n s = dm.Ocr(0,0,2000,2000,"9f2e3f-000000,"+vbcrlf,1.0)\n MessageBox s\n//背景色识别\n //比如要识别背景色为白色,文字颜色未知的字形\n s = dm.Ocr(0,0,2000,2000,"b@ffffff-000000",1.0)\n MessageBox s\n //注: 在color_fomat最前面加上"b@"表示后面的颜色描述是针对背景色,而非字的颜色.
OcrEx(x1,y1,x2,y2,color_format,sim) = 识别屏幕范围(x1,y1,x2,y2)内符合color_format的字符串,并且相似度为sim,sim取值范围(0.1-1.0),\n这个值越大越精确,越大速度越快,越小速度越慢,请斟酌使用!\n这个函数可以返回识别到的字符串，以及每个字符的坐标.\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n color_format 字符串:颜色格式串.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n返回值:\n字符串:\n 返回识别到的字符串 格式如  "识别到的信息|x0,y0|…|xn,yn"\n示例:\n和Ocr函数相同，只是结果处理有所不同 如下\nss = dm.OcrEx(0,0,2000,2000,"ffffff|000000",1.0)\n ss = split(ss,"|")\n MessageBox "识别到的字符串:"&ss(0)\n ss_len = len(ss(0))\n for i = 1 to ss_len \n     MessageBox "第("&i&")的坐标是"&ss(i)\n next
OcrInFile(x1, y1, x2, y2, pic_name, color_format, sim) = 识别位图中区域(x1,y1,x2,y2)的文字\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n pic_name 字符串:图片文件名\n color_format 字符串:颜色格式串.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n返回值:\n 字符串:\n 返回识别到的字符串\n示例:\n s = dm.OcrInFile(0,0,2000,2000,"test.bmp","000000-000000",1.0)\n MessageBox s
SaveDict(index,file) = 保存指定的字库到指定的文件中.\n参数定义:\n index 整形数:字库索引序号 取值为0-9对应10个字库\n file 字符串:文件名\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.SetPath "c:\test_game"\n dm.AddDict 0,"FFF00A7D49292524A7D402805FFC$回$0.0.54$11"\n dm.AddDict 0,"3F0020087FF08270B9A108268708808$收$0.0.43$11"\n dm.AddDict 0,"2055C98617420807C097F222447C800$站$0.0.44$11"\n dm.SaveDict 0,"test.txt"  
SetColGapNoDict(col_gap) = 高级用户使用,在不使用字库进行词组识别前,可设定文字的列距,默认列距是1\n参数定义:\n col_gap 整形数:文字列距\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetColGapNoDict(3)
SetDict(index,file) = 设置字库文件\n参数定义:\nindex 整形数:字库的序号,取值为0-9,目前最多支持10个字库\n file 字符串:字库文件名\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetDict(0,"test.txt")\n 注: 此函数速度很慢，全局初始化时调用一次即可，切换字库用UseDict
SetDictPwd(pwd) = 设置字库的密码,在SetDict前调用,目前的设计是,所有字库通用一个密码.\n参数定义:\n pwd 字符串:字库密码\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetDictPwd("1234")\n注意:如果使用了多字库,所有字库的密码必须一样. 此函数必须在SetDict之前调用,否则会解密失败.
SetExactOcr(exact_ocr) = 高级用户使用,在使用文字识别功能前，设定是否开启精准识别.\n参数定义:\n exact_ocr 整形数: 0 表示关闭精准识别\n            1 开启精准识别\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n// 开启精准识别\n dm_ret = dm.SetExactOcr(1)\n注意: 精准识别开启后，行间距和列间距会对识别结果造成较大影响，可以在工具中进行测试.
SetMinColGap(min_col_gap) = 高级用户使用,在识别前,如果待识别区域有多行文字,可以设定列间距,默认的列间距是0,\n如果根据情况设定,可以提高识别精度。一般不用设定。\n参数定义:\n min_col_gap 整形数:最小列间距\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetMinColGap(1)\n注意：此设置如果不为0,那么将不能识别连体字 慎用.
SetMinRowGap(min_row_gap) = 高级用户使用,在识别前,如果待识别区域有多行文字,可以设定行间距,默认的行间距是1,\n如果根据情况设定,可以提高识别精度。一般不用设定。\n参数定义:\n min_row_gap 整形数:最小行间距\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetMinRowGap(2)
SetRowGapNoDict(row_gap) = 高级用户使用,在不使用字库进行词组识别前,可设定文字的行距,默认行距是1\n参数定义:\n row_gap 整形数:文字行距\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm_ret = dm.SetRowGapNoDict(3)
SetWordGap(word_gap) = 高级用户使用,在识别词组前,可设定词组间的间隔,默认的词组间隔是5\n参数定义:\n word_gap 整形数:单词间距\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetWordGap(5)
SetWordGapNoDict(word_gap) = 高级用户使用,在不使用字库进行词组识别前,可设定词组间的间隔,默认的词组间隔是5\n参数定义:\n word_gap 整形数:单词间距\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetWordGapNoDict(1)
SetWordLineHeight(line_height) = 高级用户使用,在识别词组前,可设定文字的平均行高,默认的词组行高是10\n参数定义:\n line_height 整形数:行高\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetWordLineHeight(15)
SetWordLineHeightNoDict(line_height) = 高级用户使用,在不使用字库进行词组识别前,可设定文字的平均行高,默认的词组行高是10\n参数定义:\n line_height 整形数:行高\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetWordLineHeightNoDict(15)
UseDict(index) = 表示使用哪个字库文件进行识别(index范围:0-9)\n设置之后，永久生效，除非再次设定  \n参数定义:\n index 整形数:字库编号(0-9)\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.UseDict(1)\n ss = dm.Ocr(0,0,2000,2000,"FFFFFF-000000",1.0)\n dm_ret = dm.UseDict(0)
ActiveInputMethod(hwnd,input_method) = 激活指定窗口所在进程的输入法. \n参数定义:\nhwnd 整形数: 窗口句柄\n input_method 字符串: 输入法名字。 具体输入法名字对应表查看注册表中以下位置:\nHKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layouts\n下面的每一项下的Layout Text的值就是输入法名字\n比如 "中文 - QQ拼音输入法"  \n以此类推.\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm_ret = dm.ActiveInputMethod(hwnd,"中文 - QQ拼音输入法")\n if dm_ret = 1 then\n     msgbox "QQ输入法开启成功"\n end if  
CheckInputMethod(hwnd,input_method) = 检测指定窗口所在线程输入法是否开启\n参数定义:\nhwnd 整形数: 窗口句柄\n input_method 字符串: 输入法名字。 具体输入法名字对应表查看注册表中以下位置:\nHKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layouts\n下面的每一项下的Layout Text的值就是输入法名字\n比如 "中文 - QQ拼音输入法"  \n以此类推.\n返回值:\n整形数:\n 0 : 未开启\n1 : 开启\n示例:\n dm_ret = dm.CheckInputMethod(hwnd,"中文 - QQ拼音输入法")\n if dm_ret = 1 then\n     msgbox "QQ输入法开启拉"\n end if
FindInputMethod(input_method) = 检测系统中是否安装了指定输入法\n参数定义:\n input_method 字符串: 输入法名字。 具体输入法名字对应表查看注册表中以下位置:\nHKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layouts\n下面的每一项下的Layout Text的值就是输入法名字\n比如 "中文 - QQ拼音输入法"  \n以此类推.\n返回值:\n整形数:\n 0 : 未安装\n1 : 安装了\n示例:\n dm_ret = dm.FindInputMethod("中文 - QQ拼音输入法")\n if dm_ret = 1 then\n     msgbox "QQ输入法安装啦"\n end if
AsmAdd(asm_ins) = 添加指定的MASM汇编指令\n 参数定义:\n asm_ins 字符串:MASM汇编指令,大小写均可以  比如 "mov eax,1"\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.AsmAdd "push 0100"\n dm.AsmAdd "push 060304d"\n dm.AsmAdd "call 0678fed"  \n注: 简单游平台不支持此接口
AsmClear() = 清除汇编指令缓冲区 用AsmAdd添加到缓冲的指令全部清除\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.AsmClear  \n注: 简单游平台不支持此接口
AsmCode(base_addr) = 把汇编缓冲区的指令转换为机器码 并用16进制字符串的形式输出\n 参数定义:\nbase_addr 字符串: 用AsmAdd添加到缓冲区的第一条指令所在的地址\n返回值:\n字符串:\n 机器码，比如 "aa bb cc"这样的形式\n示例:\ncode = dm.AsmCode(&H405940)\n MessageBox code  \n注: 简单游平台不支持此接口
Assemble(asm_code,base_addr,is_upper) = 把指定的机器码转换为汇编语言输出\n 参数定义:\n asm_code 字符串: 机器码，形式如 "aa bb cc"这样的16进制表示的字符串(空格无所谓)\nbase_addr 整形数: 指令所在的地址\nis_upper 整形数: 表示转换的汇编语言是否以大写输出\n返回值:\n字符串:\n MASM汇编语言字符串\n示例:\ndm_ret = dm.Assemble("81 05 E0 5A 47 00 01 00 00 00",&H435fde,0)\n MessageBox dm_ret  \n注: 简单游平台不支持此接口
ClientToScreen(hwnd,x,y) = 把窗口坐标转换为屏幕坐标 \n参数定义:\n hwnd 整形数: 指定的窗口句柄\nx 变参指针: 窗口X坐标\ny 变参指针: 窗口Y坐标\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\nx = 0:y = 0 \n dm_ret = dm.ClientToScreen(hwnd,x,y) 
FindWindow(class,title) = 查找符合类名或者标题名的顶层可见窗口\n参数定义:\n class 字符串: 窗口类名，如果为空，则匹配所有. 这里的匹配是模糊匹配.\ntitle 字符串: 窗口标题,如果为空，则匹配所有.这里的匹配是模糊匹配.\n返回值:\n整形数:\n 整形数表示的窗口句柄，没找到返回0\n示例:\nhwnd = dm.FindWindow("","记事本") 
FindWindowEx(parent,class,title) = 查找符合类名或者标题名的顶层可见窗口,如果指定了parent,则在parent的第一层子窗口中查找.\n参数定义:\n parent 整形数: 父窗口句柄，如果为空，则匹配所有顶层窗口\n class 字符串: 窗口类名，如果为空，则匹配所有. 这里的匹配是模糊匹配.\ntitle 字符串: 窗口标题,如果为空，则匹配所有. 这里的匹配是模糊匹配.\n返回值:\n整形数:\n 整形数表示的窗口句柄，没找到返回0\n示例:\nhwnd = dm.FindWindowEx(0,"","记事本") 
GetClientRect(hwnd,x1,y1,x2,y2) = 获取窗口客户区域在屏幕上的位置\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n x1 变参指针: 返回窗口客户区左上角X坐标\ny1 变参指针: 返回窗口客户区左上角Y坐标\nx2 变参指针: 返回窗口客户区右下角X坐标\ny2 变参指针: 返回窗口客户区右下角Y坐标\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm_ret = dm.GetClientRect(hwnd,x1,y1,x2,y2)
GetClientSize(hwnd,width,height) = 获取窗口客户区域的宽度和高度\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n width 变参指针: 宽度\nheight 变参指针: 高度\n返回值:\n 整形数:\n 0: 失败\n 1: 成功\n示例:\ndm_ret = dm.GetClientSize(hwnd,w,h) \n TracePrint "宽度:"& w &",高度:"& h
GetForegroundFocus() = 获取顶层活动窗口中具有输入焦点的窗口句柄 \n参数定义:\n返回值:\n整形数:\n 返回整型表示的窗口句柄\n示例:\nhwnd = dm.GetForegroundFocus()
GetForegroundWindow() = 获取顶层活动窗口,可以获取到按键自带插件无法获取到的句柄\n参数定义:\n返回值:\n整形数:\n 返回整型表示的窗口句柄\n示例:\nhwnd = dm.GetForegroundWindow()
GetMousePointWindow() = 获取鼠标指向的窗口句柄,可以获取到按键自带的插件无法获取到的句柄\n参数定义:\n返回值:\n整形数:\n 返回整型表示的窗口句柄\n示例:\nhwnd = dm.GetMousePointWindow()
GetPointWindow(x,y) = 获取给定坐标的窗口句柄,可以获取到按键自带的插件无法获取到的句柄\n参数定义:\nX 整形数: 屏幕X坐标\nY 整形数: 屏幕Y坐标\n返回值:\n整形数:\n 返回整型表示的窗口句柄\n示例:\nhwnd = dm.GetPointWindow(100,100)
GetSpecialWindow(flag) = 获取特殊窗口\n参数定义:\nFlag 整形数: 取值定义如下\n0 : 获取桌面窗口\n1 : 获取任务栏窗口\n返回值:\n整形数:\n 以整型数表示的窗口句柄\n示例:\ndesk_win = dm.GetSpecialWindow(0) 
GetWindow(hwnd,flag) = 获取给定窗口相关的窗口句柄\n参数定义:\nhwnd 整形数: 窗口句柄\nflag 整形数: 取值定义如下\n0 : 获取父窗口\n1 : 获取第一个儿子窗口\n2 : 获取First 窗口\n3 : 获取Last窗口\n4 : 获取下一个窗口\n5 : 获取上一个窗口\n6 : 获取拥有者窗口\n7 : 获取顶层窗口\n返回值:\n整形数:\n 返回整型表示的窗口句柄\n示例:\nown_hwnd = dm.GetWindow(hwnd,6)
GetWindowClass(hwnd) = 获取窗口的类名\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n返回值:\n字符串:\n 窗口的类名\n示例:\nclass_name = dm.GetWindowClass(hwnd) 
GetWindowProcessId(hwnd) = 获取指定窗口所在的进程ID.\n参数定义:\nhwnd 整形数: 窗口句柄\n返回值:\n整形数:\n 返回整型表示的是进程ID\n示例:\nprocess_id = dm.GetWindowProcessId(hwnd)
GetWindowProcessPath(hwnd) = 获取指定窗口所在的进程的exe文件全路径.\n参数定义:\nhwnd 整形数: 窗口句柄\n返回值:\n字符串:\n 返回字符串表示的是exe全路径名\n示例:\nprocess_path = dm.GetWindowProcessPath(hwnd)
GetWindowRect(hwnd,x1,y1,x2,y2) = 获取窗口在屏幕上的位置\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n x1 变参指针: 返回窗口左上角X坐标\ny1 变参指针: 返回窗口左上角Y坐标\nx2 变参指针: 返回窗口右下角X坐标\ny2 变参指针: 返回窗口右下角Y坐标\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm_ret = dm.GetWindowRect(hwnd,x1,y1,x2,y2)
GetWindowState(hwnd,flag) = 获取指定窗口的一些属性\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n flag 整形数: 取值定义如下\n0 : 判断窗口是否存在\n1 : 判断窗口是否处于激活\n2 : 判断窗口是否可见\n3 : 判断窗口是否最小化\n4 : 判断窗口是否最大化\n5 : 判断窗口是否置顶\n6 : 判断窗口是否无响应\n返回值:\n整形数:\n 0: 不满足条件\n 1: 满足条件\n示例:\ndm_ret = dm.GetWindowState(hwnd,3) \n If dm_ret = 1 Then\n     MessageBox "窗口已经最小化了"\n End If
GetWindowTitle(hwnd) = 获取窗口的标题\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n返回值:\n字符串:\n 窗口的标题\n示例:\ntitle = dm.GetWindowTitle(hwnd) 
MoveWindow(hwnd,x,y) = 移动指定窗口到指定位置\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n x 整形数: X坐标\ny 整形数: Y坐标\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm.MoveWindow hwnd,-10,-10
ScreenToClient(hwnd,x,y) = 把屏幕坐标转换为窗口坐标\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n x 变参指针: 屏幕X坐标\ny 变参指针: 屏幕Y坐标\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\nx = 100:y = 100 \n dm_ret = dm.ScreenToClient(hwnd,x,y) 
SendPaste(hwnd) = 向指定窗口发送粘贴命令. 把剪贴板的内容发送到目标窗口.\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm.SetClipboard "abcd"\n dm.SendPaste hwnd\n注:剪贴板是公共资源，多个线程同时设置剪贴板时,会产生冲突，必须用互斥信号保护.
SendString(hwnd,str) = 向指定窗口发送文本数据\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n str 字符串: 发送的文本数据\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm.SendString hwnd,"我是来测试的"
SendString2(hwnd,str) = 向指定窗口发送文本数据\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n str 字符串: 发送的文本数据\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm.SendString2 hwnd,"我是来测试的"\n注: 此接口为老的SendString，如果新的SendString不能输入，可以尝试此接口.
SetClientSize(hwnd,width,height) = 设置窗口客户区域的宽度和高度\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n width 整形数: 宽度\nheight 整形数: 高度\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm_ret = dm.SetClientSize(hwnd,800,600) 
SetWindowSize(hwnd,width,height) = 设置窗口的大小\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n width 整形数: 宽度\nheight 整形数: 高度\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm_ret = dm.SetWindowSize(hwnd,300,400)
SetWindowState(hwnd,flag) = 设置窗口的状态\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n flag 整形数: 取值定义如下\n0 : 关闭指定窗口\n1 : 激活指定窗口\n2 : 最小化指定窗口,但不激活\n3 : 最小化指定窗口,并释放内存,但同时也会激活窗口.\n4 : 最大化指定窗口,同时激活窗口.\n5 : 恢复指定窗口 ,但不激活\n6 : 隐藏指定窗口\n7 : 显示指定窗口\n8 : 置顶指定窗口\n9 : 取消置顶指定窗口\n10 : 禁止指定窗口\n11 : 取消禁止指定窗口\n12 : 恢复并激活指定窗口\n13 : 强制结束窗口所在进程.\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm_ret = dm.SetWindowState(hwnd,0) 
SetWindowText(hwnd,title) = 设置窗口的标题\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n titie 字符串: 标题\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm_ret = dm.SetWindowText(hwnd,"test") 
SetWindowTransparent(hwnd,trans) = 设置窗口的透明度\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n trans 整形数: 透明度 取值(0-255) 越小透明度越大 0为完全透明(不可见) 255为完全显示(不透明)\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm_ret = dm.SetWindowTransparent(hwnd,200) \n注 :  此接口不支持WIN98
FaqCancel() = 可以把上次FaqPost的发送取消,接着下一次FaqPost\n参数定义:\n返回值:\n整形数:\n 0 : 失败\n 1 : 成功\n示例:\n// 截取这个范围内,3秒动画,图像质量为中等50,动画帧率间隔为100ms\n handle = dm.FaqCapture(50,50,300,400,50,100,3000)\n // 调用FaqPost异步发送\n dm.FaqCancel\n dm_ret = dm.FaqPost("192.168.1.100:12345",handle,1,3 * 60 * 1000)\n If dm_ret = 0 Then\n     MessageBox "发送失败，可能上个FaqPost还未处理完毕"\n     EndScript\n End If\n // 不影响脚本运行\n    result = dm.FaqFetch()\n    If len(result) > 0 Then\n         MessageBox "服务器返回结果 = "&result\n    End If\n    // 做其他的事情 这里就假设为延时\n    Delay 1000\n Loop
FaqCapture(x1, y1, x2, y2, quality, delay, time) = 截取指定范围内的动画或者图像,并返回此句柄.\n参数定义:\n x1 整形数: 左上角X坐标\ny1 整形数: 左上角Y坐标\nx2 整形数: 右下角X坐标\ny2 整形数: 右下角Y坐标\nquality 整形数: 图像或动画品质,或者叫压缩率,此值越大图像质量越好 取值范围（1-100）\ndelay 整形数: 截取动画时用,表示相隔两帧间的时间间隔,单位毫秒 （如果只是截取静态图像,这个参数必须是0）\ntime 整形数: 表示总共截取多久的动画,单位毫秒 （如果只是截取静态图像,这个参数必须是0）\n返回值:\n整形数:\n 图像或者动画句柄\n示例:\n// 截取这个范围内,3秒动画,图像质量为中等50,动画帧率间隔为100ms\n handle = dm.FaqCapture(intX - 50,intY - 232,intX+272,intY-12,50,100,3000)\n注 : 从插件版本2.1119之后，接口FaqCapture返回handle，不需要再手动调用FaqRelease释放了。插件已经自动释放了.
FaqFetch() = 获取由FaqPost发送后，由服务器返回的答案.\n参数定义:\n返回值:\n字符串:\n 如果此函数调用失败,那么返回值如下\n"Error:错误描述" \n如果函数调用成功,那么返回值如下\n"OK:答案"\n根据FaqPost中 request_type取值的不同,返回值不同\n当request_type 为0时,答案的格式为"x,y" (不包含引号)\n当request_type 为1时,答案的格式为"1" "2" "3" "4" "5" "6" (不包含引号)\n当request_type 为2时,答案就是要求的答案 比如 "李白" (不包含引号)\n当request_type 为3时,答案的格式为"x1,y1|x2,y2" 比如 "20,30|78,68" (不包含引号)\n如果返回为空字符串，表示FaqPost还未处理完毕,或者没有调用过FaqPost.\n示例:\n// 截取这个范围内,3秒动画,图像质量为中等50,动画帧率间隔为100ms\n handle = dm.FaqCapture(50,50,300,400,50,100,3000)\n // 调用FaqPost异步发送\n dm_ret = dm.FaqPost("192.168.1.100:12345",handle,1,3 * 60 * 1000)\n If dm_ret = 0 Then\n     MessageBox "发送失败，可能上个FaqPost还未处理完毕"\n     EndScript\n End If\n // 不影响脚本运行\n    result = dm.FaqFetch()\n    If len(result) > 0 Then\n         MessageBox "服务器返回结果 = "&result\n    End If\n    // 做其他的事情 这里就假设为延时\n    Delay 1000\n Loop\n注: 如果此函数调用成功后，插件内部状态会再次重置为未处理状态，可以接着处理FaqPost接口.
FaqGetSize(handle) = 获取句柄所对应的数据包的大小,单位是字节\n参数定义:\n handle 整形数: 由FaqCapture返回的句柄\n返回值:\n整形数:\n 数据包大小,一般用于判断数据大小,选择合适的压缩比率.\n示例:\n// 截取这个范围内,3秒动画,图像质量为中等50,动画帧率间隔为100ms\n handle = dm.FaqCapture(intX - 50,intY - 232,intX+272,intY-12,50,100,3000)\n packet_size = dm.FaqGetSize(handle)\n MessageBox packet_size  
ExcludePos(all_pos,type,x1,y1,x2,y2) = 根据部分Ex接口的返回值，排除指定范围区域内的坐标.\n参数定义:\n all_pos 字符串: 坐标描述串。  一般是FindStrEx,FindStrFastEx,FindStrWithFontEx, FindColorEx, FindMultiColorEx,和FindPicEx的返回值.\n type 整形数:  取值为0或者1\n     如果all_pos的内容是由FindPicEx,FindStrEx,FindStrFastEx,FindStrWithFontEx返回，那么取值为0\n     如果all_pos的内容是由FindColorEx, FindMultiColorEx返回，那么取值为1\nx1 整形数: 左上角横坐标\n y1 整形数: 左上角纵坐标\n x2 整形数: 右下角横坐标\n y2 整形数: 右下角纵坐标\n返回值:\n字符串:\n 经过筛选以后的返回值，格式和type指定的一致.\n示例:\nret = dm.FindColorEx(0,0,2000,2000,"aaaaaa-000000",1.0,0)\n ret = dm.ExcludePos(ret,1,100,100,300,400)\n TracePrint ret\nret = dm.FindPicEx(0,0,2000,2000,"a.bmp","000000",1.0,0)\n ret = dm.ExcludePos(ret,0,100,100,300,400)\n TracePrint ret
FindNearestPos(all_pos,type,x,y) = 根据部分Ex接口的返回值，然后在所有坐标里找出距离指定坐标最近的那个坐标.\n参数定义:\n all_pos 字符串: 坐标描述串。  一般是FindStrEx,FindStrFastEx,FindStrWithFontEx, FindColorEx, FindMultiColorEx,和FindPicEx的返回值.\n type 整形数:  取值为0或者1\n     如果all_pos的内容是由FindPicEx,FindStrEx,FindStrFastEx,FindStrWithFontEx返回，那么取值为0\n     如果all_pos的内容是由FindColorEx, FindMultiColorEx返回，那么取值为1\nx 整形数: 横坐标\n y 整形数: 纵坐标\n返回值:\n 字符串:\n 返回的格式和type有关，如果type为0，那么返回的格式是"id,x,y"\n如果type为1,那么返回的格式是"x,y".\n示例:\nret = dm.FindColorEx(0,0,2000,2000,"aaaaaa-000000",1.0,0)\n ret = dm.FindNearestPos(ret,1,100,100)\n TracePrint ret\nret = dm.FindPicEx(0,0,2000,2000,"a.bmp","000000",1.0,0)\n ret = dm.FindNearestPos(ret,0,100,100)\n TracePrint ret
SortPosDistance(all_pos,type,x,y) = 根据部分Ex接口的返回值，然后对所有坐标根据对指定坐标的距离进行从小到大的排序.\n参数定义:\n all_pos 字符串: 坐标描述串。  一般是FindStrEx,FindStrFastEx,FindStrWithFontEx, FindColorEx, FindMultiColorEx,和FindPicEx的返回值.\n type 整形数:  取值为0或者1\n     如果all_pos的内容是由FindPicEx,FindStrEx,FindStrFastEx,FindStrWithFontEx返回，那么取值为0\n     如果all_pos的内容是由FindColorEx, FindMultiColorEx返回，那么取值为1\nx 整形数: 横坐标\n y 整形数: 纵坐标\n返回值:\n 字符串:\n 返回的格式和type指定的格式一致.\n示例:\nret = dm.FindColorEx(0,0,2000,2000,"aaaaaa-000000",1.0,0)\n ret = dm.SortPosDistance(ret,1,100,100)\n TracePrint ret\nret = dm.FindPicEx(0,0,2000,2000,"a.bmp","000000",1.0,0)\n ret = dm.SortPosDistance(ret,0,100,100)\n TracePrint ret
Beep(f,duration) = 蜂鸣器.\n参数定义:\nf 整形数: 频率\nduration 整形数: 时长(ms).\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm.Beep 1000,1000
CheckUAC() = 检测当前系统是否有开启UAC(用户账户控制).\n参数定义:\n返回值:\n整形数:\n 0 : 没开启UAC\n1 : 开启了UAC\n示例:\n if dm.CheckUAC() = 1 then\n     TracePrint "当前系统开启了用户账户控制"\n end if\n注: 只有WIN7 VISTA WIN2008以及以上系统才有UAC设置
DisablePowerSave() = 关闭电源管理，不会进入睡眠.\n参数定义:\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm.DisablePowerSave\n注 :此函数调用以后，并不会更改系统电源设置. \n 此函数经常用在后台操作过程中. 避免被系统干扰.
DisableScreenSave() = 关闭屏幕保护.\n参数定义:\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm.DisableScreenSave\n注 : 调用此函数后，可能在系统中还是看到屏保是开启状态。但实际上屏保已经失效了.\n系统重启后，会失效。必须再重新调用一次.\n此函数经常用在后台操作过程中. 避免被系统干扰.
ExitOs(type) = 退出系统(注销 重启 关机) \n参数定义:\ntype 整形数: 取值为以下类型\n     0 : 注销系统\n     1 : 关机\n     2 : 重新启动\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm_ret = dm.ExitOs(1)  
GetClipboard() = 获取剪贴板的内容\n参数定义:\n返回值:\n字符串:\n 以字符串表示的剪贴板内容\n示例:\nTracePrint dm.GetClipboard()  
GetDir(type) = 得到系统的路径 \n参数定义:\ntype 整形数: 取值为以下类型\n     0 : 获取当前路径\n     1 : 获取系统路径(system32路径)\n     2 : 获取windows路径(windows所在路径)\n     3 : 获取临时目录路径(temp)\n     4 : 获取当前进程(exe)所在的路径\n返回值:\n字符串:\n 返回路径\n示例:\n path = dm.GetDir(2)  
GetDiskSerial() = 获取本机的硬盘序列号.支持ide scsi硬盘. 要求调用进程必须有管理员权限. 否则返回空串.\n参数定义:\n返回值:\n字符串:\n 字符串表达的硬盘序列号\n示例:\n sirial = dm.GetDiskSerial()
GetMachineCode() = 获取本机的机器码.(带网卡). 此机器码用于插件网站后台. 要求调用进程必须有管理员权限. 否则返回空串.\n参数定义:\n返回值:\n字符串:\n 字符串表达的机器机器码\n示例:\n machine_code = dm.GetMachineCode()\n注: 此机器码包含的硬件设备有硬盘,显卡,网卡等. 其它不便透露. 重装系统不会改变此值.\n另要注意,插拔任何USB设备,(U盘，U盾,USB移动硬盘,USB键鼠等),以及安装任何网卡驱动程序,(开启或者关闭无线网卡等)都会导致机器码改变.  
GetMachineCodeNoMac() = 获取本机的机器码.(不带网卡) 要求调用进程必须有管理员权限. 否则返回空串.\n参数定义:\n返回值:\n字符串:\n 字符串表达的机器机器码\n示例:\n machine_code = dm.GetMachineCodeNoMac()\n注: 此机器码包含的硬件设备有硬盘,显卡,等. 其它不便透露. 重装系统不会改变此值.\n另要注意,插拔任何USB设备,(U盘，U盾,USB移动硬盘,USB键鼠等),都会导致机器码改变.  
GetNetTime() = 从网络获取当前北京时间.\n参数定义:\n返回值:\n字符串:\n 时间格式. 和now返回一致. 比如"2001-11-01 23:14:08"\n示例:\n t = dm.GetNetTime()\n TracePrint "当前北京时间是:"&t  
GetOsType() = 得到操作系统的类型\n参数定义:\n返回值:\n整形数:\n 0 : win95/98/me/nt4.0\n1 : xp/2000\n2 : 2003\n3 : win7/vista/2008\n示例:\n os_type = dm.GetOsType()  
GetScreenDepth() = 获取屏幕的色深. \n参数定义:\n返回值:\n整形数:\n 返回系统颜色深度.(16或者32等)\n示例:\n Depth = dm.GetScreenDepth()  
GetScreenHeight() = 获取屏幕的高度. \n参数定义:\n返回值:\n整形数:\n 返回屏幕的高度\n示例:\n ScreenH = dm.GetScreenHeight()  
GetScreenWidth() = 获取屏幕的宽度. \n参数定义:\n返回值:\n整形数:\n 返回屏幕的宽度\n示例:\n ScreenW = dm.GetScreenWidth()  
GetTime() = 获取当前系统从开机到现在所经历过的时间，单位是毫秒\n参数定义:\n返回值:\n整形数:\n 时间(单位毫秒)\n示例:\n t1 = dm.GetTime()\n dm_ret = dm.FindPic(0,0,2000,2000,"test.bmp","000000",1.0,0,x,y)\n t2 = dm.GetTime()\n MessageBox (t2-t1)  
Is64Bit() = 判断当前系统是否是64位操作系统\n参数定义:\n返回值:\n整形数:\n 0 : 不是64位系统\n 1 : 是64位系统\n示例:\nif dm.Is64Bit() = 1 then\n     MessageBox "64位系统"\n else\n     MessageBox "不是64位系统"\n end if  
Play(media_file) = 播放指定的MP3或者wav文件.\n参数定义:\nmedia_file 字符串: 指定的音乐文件，可以采用文件名或者绝对路径的形式.\n返回值:\n整形数:\n 0 : 失败\n 非0表示当前播放的ID。可以用Stop来控制播放结束.\n示例:\n // test.mp3放于d:\test目录下\n dm.SetPath "d:\test"\n id = dm.Play("test.mp3")  \n// 绝对路径\n id = dm.Play("d:\test\test.mp3")\n Delay 1000\n dm.Stop id
SetClipboard(value) = 设置剪贴板的内容\n参数定义:\nvalue 字符串: 以字符串表示的剪贴板内容\n返回值:\n整形数:\n 0 : 失败\n 1 : 成功\n示例:\n dm.SetClipboard "abcd"  
SetScreen(width,height,depth) = 设置系统的分辨率 系统色深 \n参数定义:\nwidth 整形数: 屏幕宽度\nheight 整形数: 屏幕高度\ndepth 整形数: 系统色深\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm_ret = dm.SetScreen(1024,768,16)  
SetUAC(enable) = 设置当前系统的UAC(用户账户控制).\n参数定义:\nenable 整形数: 取值如下\n       0 : 关闭UAC\n        1 : 开启UAC\n返回值:\n 整形数:\n 0 : 操作失败\n1 : 操作成功\n示例:\n if dm.SetUAC(0) = 1 then\n     TracePrint "成功关闭了当前系统UAC设置"\n end if\n注: 只有WIN7 VISTA WIN2008以及以上系统才有UAC设置. 关闭UAC以后，必须重启系统才会生效.\n如果关闭了UAC，那么默认启动所有应用程序都是管理员权限，就不会再发生绑定失败这样的尴尬情况了.
Stop(id) = 停止指定的音乐.\n参数定义:\nid 整形数: Play返回的播放id.\n返回值:\n整形数:\n 0 : 失败\n 1 : 成功.\n示例:\n // test.mp3放于d:\test目录下\n dm.SetPath "d:\test"\n id = dm.Play("test.mp3")  \n// 绝对路径\n id = dm.Play("d:\test\test.mp3")\n Delay 1000\n dm.Stop id
GetCursorPos(x,y) = 获取鼠标位置.\n参数定义:\n x 变参指针: 返回X坐标\ny 变参指针: 返回Y坐标\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm.GetCursorPos x,y\n MessageBox x&","&y\n注: 此接口在3.1223版本之后，返回的值的定义修改。  同大多数接口一样,返回的x,y坐标是根据绑定的鼠标参数来决定.  如果绑定了窗口，那么获取的坐标是相对于绑定窗口，否则是屏幕坐标.  \n 另外，此函数获取的坐标是真实的鼠标坐标，对于某些自绘鼠标位置不一定准确。请自行测试.
GetKeyState(vk_code) = 获取指定的按键状态.(前台信息,不是后台)\n参数定义:\n vk_code 整形数:虚拟按键码\n返回值:\n整形数:\n 0:弹起\n 1:按下\n示例:\n TracePrint dm.GetKeyState(13)
KeyDown(vk_code) = 按住指定的虚拟键码\n 参数定义:\n vk_code 整形数:虚拟按键码\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.KeyDown 13  
KeyDownChar(key_str) = 按住指定的虚拟键码\n 参数定义:\n key_str 字符串: 字符串描述的键码. 大小写无所谓. 点这里查看具体对应关系.\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.KeyDownChar "enter"\n dm.KeyDownChar "1"\n dm.KeyDownChar "F1"\n dm.KeyDownChar "a"\n dm.KeyDownChar "B"  
KeyPress(vk_code) = 按下指定的虚拟键码\n参数定义:\n vk_code 整形数:虚拟按键码\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.KeyPress 13
KeyPressChar(key_str) = 按下指定的虚拟键码\n参数定义:\n key_str 字符串: 字符串描述的键码. 大小写无所谓. 点这里查看具体对应关系.\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.KeyPressChar "enter"\n dm.KeyPressChar "1"\n dm.KeyPressChar "F1"\n dm.KeyPressChar "a"\n dm.KeyPressChar "B"
KeyUp(vk_code) = 弹起来虚拟键vk_code\n参数定义:\n vk_code 整形数:虚拟按键码\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.KeyUp 13
KeyUpChar(key_str) = 弹起来虚拟键key_str\n参数定义:\n key_str 字符串: 字符串描述的键码. 大小写无所谓. 点这里查看具体对应关系.\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.KeyUpChar "enter"\n dm.KeyUpChar "1"\n dm.KeyUpChar "F1"\n dm.KeyUpChar "a"\n dm.KeyUpChar "B"
LeftClick() = 按下鼠标左键\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.LeftClick
LeftDoubleClick() = 双击鼠标左键\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.LeftDoubleClick
LeftDown() = 按住鼠标左键\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.LeftDown
LeftUp() = 弹起鼠标左键\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.LeftUp
MiddleClick() = 按下鼠标中键\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.MiddleClick
MoveR(rx,ry) = 鼠标相对于上次的位置移动rx,ry\n参数定义:\n rx 整形数:相对于上次的X偏移\n ry 整形数:相对于上次的Y偏移\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.MoveR rx,ry  
MoveTo(x,y) = 把鼠标移动到目的点(x,y)\n参数定义:\n x 整形数:X坐标\n y 整形数:Y坐标\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.MoveTo x,y
MoveToEx(x,y,w,h) = 把鼠标移动到目的范围内的任意一点\n参数定义:\n x 整形数:X坐标\n y 整形数:Y坐标\n w 整形数:宽度(从x计算起)\n h 整形数:高度(从y计算起)\n返回值:\n字符串:\n 返回要移动到的目标点. 格式为x,y.  比如MoveToEx 100,100,10,10,返回值可能是101,102\n示例:\n// 移动鼠标到(100,100)到(110,110)这个矩形范围内的任意一点.\n dm.MoveToEx 100,100,10,10\n注: 此函数的意思是移动鼠标到指定的范围(x,y,x+w,y+h)内的任意随机一点.
RightClick() = 按下鼠标右键\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.RightClick
RightDown() = 按住鼠标右键\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.RightDown
RightUp() = 弹起鼠标右键\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.RightUp
SetKeypadDelay(type,delay) = 设置按键时,键盘按下和弹起的时间间隔。高级用户使用。某些窗口可能需要调整这个参数才可以正常按键。\n 参数定义:\n type 字符串: 键盘类型,取值有以下\n     "normal" : 对应normal键盘  默认内部延时为30ms\n     "windows": 对应windows 键盘 默认内部延时为10ms\n     "dx" :     对应dx 键盘 默认内部延时为50ms\ndelay 整形数: 延时,单位是毫秒\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.SetKeypadDelay "dx",10  \n注 : 此函数影响的接口有KeyPress
SetMouseDelay(type,delay) = 设置鼠标单击或者双击时,鼠标按下和弹起的时间间隔。高级用户使用。某些窗口可能需要调整这个参数才可以正常点击。\n 参数定义:\n type 字符串: 鼠标类型,取值有以下\n     "normal" : 对应normal鼠标 默认内部延时为 30ms\n     "windows": 对应windows 鼠标 默认内部延时为 10ms\n     "dx" :     对应dx鼠标 默认内部延时为40ms\ndelay 整形数: 延时,单位是毫秒\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.SetMouseDelay "dx",10  \n注 : 此函数影响的接口有LeftClick RightClick MiddleClick LeftDoubleClick
WaitKey(vk_code,time_out) = 等待指定的按键按下 (前台,不是后台)\n参数定义:\n vk_code 整形数:虚拟按键码\n time_out 整形数:等待多久,单位毫秒. 如果是0，表示一直等待\n返回值:\n整形数:\n 0:超时\n 1:指定的按键按下\n示例:\n dm.WaitKey 66,0
WheelDown() = 滚轮向下滚\n参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.WheelDown
WheelUp() = 滚轮向上滚\n参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.WheelUp
```

完整版：
```
(!dm)
CreateFoobarCustom(hwnd,x,y,pic_name,trans_color,sim) = 根据指定的位图创建一个自定义形状的窗口\n参数定义:\n hwnd 整形数: 指定的窗口句柄,如果此值为0,那么就在桌面创建此窗口\n x 整形数: 左上角X坐标(相对于hwnd客户区坐标)\ny 整形数: 左上角Y坐标(相对于hwnd客户区坐标)\npic_name 字符串: 位图名字\ntrans_color 字符串: 透明色(RRGGBB)\nsim 双精度浮点数: 透明色的相似值 0.1-1.0\n返回值:\n 整形数 : 创建成功的窗口句柄\n示例:\nfoobar = dm.CreateFoobarCustom(hwnd,10,10,"菜单.bmp","FF00FF",1.0)
CreateFoobarEllipse(hwnd,x,y,w,h) = 创建一个椭圆窗口\n参数定义:\n hwnd整形数: 指定的窗口句柄,如果此值为0,那么就在桌面创建此窗口\n x整形数: 左上角X坐标(相对于hwnd客户区坐标)\ny整形数: 左上角Y坐标(相对于hwnd客户区坐标)\nw整形数: 矩形区域的宽度\nh整形数: 矩形区域的高度\n返回值:\n 整形数 : 创建成功的窗口句柄\n示例:\nfoobar = dm.CreateFoobarEllipse(hwnd,10,10,200,200)
CreateFoobarRect(hwnd,x,y,w,h) = 创建一个矩形窗口\n参数定义:\n hwnd整形数: 指定的窗口句柄,如果此值为0,那么就在桌面创建此窗口\n x整形数: 左上角X坐标(相对于hwnd客户区坐标)\ny整形数: 左上角Y坐标(相对于hwnd客户区坐标)\nw整形数: 矩形区域的宽度\nh整形数: 矩形区域的高度\n返回值:\n 整形数 : 创建成功的窗口句柄\n示例:\nfoobar = dm.CreateFoobarRect(hwnd,10,10,200,200)
CreateFoobarRoundRect(hwnd,x,y,w,h,rw,rh) = 创建一个圆角矩形窗口\n参数定义:\n hwnd整形数: 指定的窗口句柄,如果此值为0,那么就在桌面创建此窗口\n x整形数: 左上角X坐标(相对于hwnd客户区坐标)\ny整形数: 左上角Y坐标(相对于hwnd客户区坐标)\nw整形数: 矩形区域的宽度\nh整形数: 矩形区域的高度\nrw整形数: 圆角的宽度\nrh整形数: 圆角的高度\n返回值:\n 整形数 : 创建成功的窗口句柄\n示例:\nfoobar = dm.CreateFoobarRoundRect(hwnd,10,10,200,200,30,30)
FoobarClearText(hwnd) = 清除指定的Foobar滚动文本区\n参数定义:\n hwnd整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\n返回值:\n整形数 :\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarClearText(foobar)
FoobarClose(hwnd) = 关闭一个Foobar,注意,必须调用此函数来关闭窗口,用SetWindowState也可以关闭,但会造成内存泄漏.\n参数定义:\n hwnd整形数: 指定的Foobar窗口句柄\n返回值:\n 整形数:\n 0: 失败\n1: 成功\n示例:\ndm_ret = dm.FoobarClose(foobar)
FoobarDrawLine(hwnd,x1,y1,x2,y2,color,style,width) = 在指定的Foobar窗口内部画线条.  <收费功能，具体详情点击查看>\n参数定义:\n hwnd 整形数: 指定的Foobar窗口,注意,此句柄必须是通过CreateFoobarxxxx系列函数创建出来的\n x1 整形数: 左上角X坐标(相对于hwnd客户区坐标)\ny1 整形数: 左上角Y坐标(相对于hwnd客户区坐标)\nx2 整形数: 右下角X坐标(相对于hwnd客户区坐标)\ny2 整形数: 右下角Y坐标(相对于hwnd客户区坐标)\ncolor字符串: 填充的颜色值\nstyle 整形数: 画笔类型. 0为实线. 1为虚线\nwidth 整形数: 线条宽度. \n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarDrawLine(foobar,0,0,200,200,"FF0000",1,1)\n注:当style为1时，线条宽度必须也是1.否则线条是实线.
FoobarDrawPic(hwnd,x,y,pic_name,trans_color) = 在指定的Foobar窗口绘制图像 此图片不能是加密的图片\n参数定义:\n hwnd整形数: 指定的Foobar窗口,注意,此句柄必须是通过CreateFoobarxxxx系列函数创建出来的\n x整形数: 左上角X坐标(相对于hwnd客户区坐标)\ny整形数: 左上角Y坐标(相对于hwnd客户区坐标)\npic_name字符串: 图像文件名\ntrans_color字符串: 图像透明色\n返回值:\n整形数 :\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarDrawPic(foobar,0,0,"menu.bmp","FF0000")
FoobarDrawText(hwnd,x,y,w,h,text,color,align) = 在指定的Foobar窗口绘制文字\n参数定义:\n hwnd整形数: 指定的Foobar窗口,注意,此句柄必须是通过CreateFoobarxxxx系列函数创建出来的\n x整形数: 左上角X坐标(相对于hwnd客户区坐标)\ny整形数: 左上角Y坐标(相对于hwnd客户区坐标)\nw整形数: 矩形区域的宽度\nh整形数: 矩形区域的高度\ntext字符串: 字符串\ncolor字符串: 文字颜色值\nalign 整形数: 取值定义如下\n1 : 左对齐\n2 : 中间对齐\n4 : 右对齐\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarDrawText(foobar,0,0,200,30,"测试","FF0000",1)
FoobarFillRect(hwnd,x1,y1,x2,y2,color) = 在指定的Foobar窗口内部填充矩形\n参数定义:\n hwnd 整形数: 指定的Foobar窗口,注意,此句柄必须是通过CreateFoobarxxxx系列函数创建出来的\n x1 整形数: 左上角X坐标(相对于hwnd客户区坐标)\ny1 整形数: 左上角Y坐标(相对于hwnd客户区坐标)\nx2 整形数: 右下角X坐标(相对于hwnd客户区坐标)\ny2 整形数: 右下角Y坐标(相对于hwnd客户区坐标)\ncolor字符串: 填充的颜色值\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarFillRect(foobar,0,0,200,200,"FF0000")
FoobarLock(hwnd) = 锁定指定的Foobar窗口,不能通过鼠标来移动\n参数定义:\n hwnd整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarLock(foobar)
FoobarPrintText(hwnd,text,color) = 向指定的Foobar窗口区域内输出滚动文字\n参数定义:\n hwnd整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\ntext字符串: 文本内容\ncolor字符串: 文本颜色\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarPrintText(foobar,"大漠测试","ff0000")\n// 用红色文字向滚动区域输出文字信息
FoobarSetFont(hwnd,font_name,size,flag) = 设置指定Foobar窗口的字体\n参数定义:\n hwnd整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\nfont_name字符串: 系统字体名,注意,必须保证系统中有此字体\nsize整形数: 字体大小\nflag整形数: 取值定义如下\n0 : 正常字体\n1 : 粗体\n2 : 斜体\n4 : 下划线\n文字可以是以上的组合 比如粗斜体就是1+2,斜体带下划线就是:2+4等.\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarSetFont(foobar,"宋体",25,2+4)
FoobarSetSave(hwnd,file,enable,header) = 设置保存指定的Foobar滚动文本区信息到文件.\n参数定义:\n hwnd 整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\nfile 字符串: 保存的文件名\nenable 整形数: 取值如下\n              0 : 关闭向文件输出 (默认是0)\n              1 : 开启向文件输出\nheader 字符串: 输出的附加头信息. (比如行数 日期 时间信息) 格式是如下格式串的顺序组合.如果为空串，表示无附加头.\n              "%L0nd%" 表示附加头信息带有行号，并且是按照十进制输出. n表示按多少个十进制数字补0对齐. 比如"%L04d%",输出的行号为0001  0002 0003等. "%L03d",输出的行号为001 002 003..等.\n              "%L0nx%"表示附加头信息带有行号，并且是按照16进制小写输出. n表示按多少个16进制数字补0对齐. 比如"%L04x%",输出的行号为0009  000a 000b等. "%L03x",输出的行号为009 00a 00b..等.\n              "%L0nX%"表示附加头信息带有行号，并且是按照16进制大写输出. n表示按多少个16进制数字补0对齐. 比如"%L04X%",输出的行号为0009  000A 000B等. "%L03X",输出的行号为009 00A 00B..等.\n              "%yyyy%"表示年. 比如2012\n              "%MM%"表示月. 比如12\n              "%dd%"表示日. 比如28\n              "%hh%"表示小时. 比如13\n              "%mm%"表示分钟. 比如59\n              "%ss%"表示秒. 比如48.\n返回值:\n整形数 :\n 0 : 失败\n1 : 成功\n示例:\n// 开启输出，并且按原始信息输出. 无附加头.\n dm.FoobarSetSave foobar,"output.txt",1,""\n// 开启输出，并且按行号信息输出.\n dm.FoobarSetSave foobar,"output.txt",1,"【%L04d%】"\n // 这个输出的信息类似如下\n 【0001】…\n 【0002】…\n 【0003】…\n// 开启输出，并且按年月日的方式输出.\n dm.FoobarSetSave foobar,"output.txt",1,"{%yyyy%-%MM%-%dd%} "\n // 这个输出的信息类似如下\n {2008-01-01} …\n {2008-01-01} …\n {2008-01-01} …\n {2008-01-01} …  \n// 开启输出，并且按时分秒的方式输出.\n dm.FoobarSetSave foobar,"output.txt",1,"{%hh%-%mm%-%ss%} "\n // 这个输出的信息类似如下\n {13-04-45} …\n {13-04-48} …\n {13-04-50} …\n// 开启输出，并且按照行号 时分的方式输出\n dm.FoobarSetSave foobar,"output.txt",1,"[%L03d%] (%hh%-%mm%)"\n // 这个输出的信息类似如下\n [001] (23-16)…\n [002] (23-17)…\n [003] (23-20)…
FoobarTextLineGap(hwnd,line_gap) = 设置滚动文本区的文字行间距,默认是3\n参数定义:\n hwnd 整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\nline_gap 整形数: 文本行间距\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarTextLineGap(foobar,5)
FoobarTextPrintDir(hwnd,dir) = 设置滚动文本区的文字输出方向,默认是0\n参数定义:\n hwnd 整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\ndir 整形数: 0 表示向下输出\n    : 1 表示向上输出\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarTextPrintDir(foobar,1)
FoobarTextRect(hwnd,x,y,w,h) = 设置指定Foobar窗口的滚动文本框范围,默认的文本框范围是窗口区域\n参数定义:\n hwnd 整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\nx 整形数: x坐标\ny 整形数: y坐标\nw 整形数: 宽度\nh 整形数: 高度\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarTextRect(foobar,10,10,100,200)
FoobarUnlock(hwnd) = 解锁指定的Foobar窗口,可以通过鼠标来移动\n参数定义:\n hwnd 整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarUnlock(foobar)
FoobarUpdate(hwnd) = 刷新指定的Foobar窗口\n参数定义:\n hwnd 整形数: 指定的Foobar窗口,注意,此句柄必须是通过CreateFoobarxxxx系列函数创建出来的\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarUpdate(foobar)\n注意： 所有绘制完成以后,必须通过调用此函数来刷新窗口,否则窗口内容不会改变.
DoubleToData(value) = 把双精度浮点数转换成二进制形式.\n 参数定义:\n value 双精度浮点数: 需要转化的双精度浮点数\n返回值:\n字符串:\n 字符串形式表达的二进制数据. 可以用于WriteData FindData FindDataEx等接口.\n示例:\ndouble_data =  dm.DoubleToData(1.24)\n dm_ret = dm.FindData(hwnd,"00000000-7fffffff",double_data)
FindData(hwnd, addr_range, data) = 搜索指定的二进制数据,默认步长是1.如果要定制步长，请用FindDataEx\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr_range 字符串: 指定搜索的地址集合，字符串类型，这个地方可以是上次FindXXX的返回地址集合,可以进行二次搜索.(类似CE的再次扫描)\n             如果要进行地址范围搜索，那么这个值为的形如如下(类似于CE的新搜索)\n            "00400000-7FFFFFFF" "80000000-BFFFFFFF" "00000000-FFFFFFFF" 等.\ndata 字符串: 要搜索的二进制数据 以字符串的形式描述 比如"00 01 23 45 67 86 ab ce f1"等. \n              这里也可以支持模糊查找,用??来代替单个字节. 比如"00 01 ?? ?? 67 86 ?? ce f1"等. 模糊查找是收费功能. <收费功能，具体详情点击查看>.\n返回值:\n字符串:\n 返回搜索到的地址集合，地址格式如下:\n"addr1|addr2|addr3…|addrn"\n比如"400050|423435|453430"\n示例:\n// 全局搜索\n result = dm.FindData(hwnd,"00000000-FFFFFFFF","00 01 23 45 67 86 ab ce f1")\n if len(result) = 0 then\n      MessageBox "找不到"\n      EndScript\n end if\n result = split(result,"|")\n count = ubound(result)+1\n MessageBox "找到"&count&"个地址"\n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。  
FindDataEx(hwnd, addr_range, data,step,multi_thread,mode) = 搜索指定的二进制数据. <收费功能，具体详情点击查看>.\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr_range 字符串: 指定搜索的地址集合，字符串类型，这个地方可以是上次FindXXX的返回地址集合,可以进行二次搜索.(类似CE的再次扫描)\n             如果要进行地址范围搜索，那么这个值为的形如如下(类似于CE的新搜索)\n            "00400000-7FFFFFFF" "80000000-BFFFFFFF" "00000000-FFFFFFFF" 等.\ndata 字符串: 要搜索的二进制数据 以字符串的形式描述 比如"00 01 23 45 67 86 ab ce f1"等\n              这里也可以支持模糊查找,用??来代替单个字节. 比如"00 01 ?? ?? 67 86 ?? ce f1"等.\nstep 整形数: 搜索步长.\nmulti_thread整形数:表示是否开启多线程查找.  0不开启，1开启.\n                    开启多线程查找速度较快，但会耗费较多CPU资源. 不开启速度较慢，但节省CPU.\nmode 整形数: 1 表示开启快速扫描(略过只读内存)  0表示所有内存类型全部扫描.\n返回值:\n字符串:\n 返回搜索到的地址集合，地址格式如下:\n"addr1|addr2|addr3…|addrn"\n比如"400050|423435|453430"\n示例:\n// 全局搜索\n result = dm.FindDataEx(hwnd,"00000000-FFFFFFFF","00 01 23 45 67 86 ab ce f1",4,1,0)\n if len(result) = 0 then\n      MessageBox "找不到"\n      EndScript\n end if\n result = split(result,"|")\n count = ubound(result)+1\n MessageBox "找到"&count&"个地址"\n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。  
FindDouble(hwnd, addr_range, double_value_min, double_value_max) = 搜索指定的双精度浮点数,默认步长是1.如果要定制步长，请用FindDoubleEx\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr_range 字符串: 指定搜索的地址集合，字符串类型，这个地方可以是上次FindXXX的返回地址集合,可以进行二次搜索.(类似CE的再次扫描)\n             如果要进行地址范围搜索，那么这个值为的形如如下(类似于CE的新搜索)\n            "00400000-7FFFFFFF" "80000000-BFFFFFFF" "00000000-FFFFFFFF" 等.\ndouble_value_min 双精度浮点数: 搜索的双精度数值最小值\ndouble_value_max 双精度浮点数: 搜索的双精度数值最大值 \n 最终搜索的数值大与等于double_value_min,并且小于等于double_value_max\n返回值:\n字符串:\n 返回搜索到的地址集合，地址格式如下:\n"addr1|addr2|addr3…|addrn"\n比如"400050|423435|453430"\n示例:\n// 全局搜索\n result = dm.FindDouble(hwnd,"00000000-FFFFFFFF",0.5,1.0)\n if len(result) = 0 then\n      MessageBox "找不到"\n      EndScript\n end if\n result = split(result,"|")\n count = ubound(result)+1\n MessageBox "找到"&count&"个地址"\n 注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。
FindDoubleEx(hwnd, addr_range, double_value_min, double_value_max,step,multi_thread,mode) = 搜索指定的双精度浮点数. <收费功能，具体详情点击查看>\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr_range 字符串: 指定搜索的地址集合，字符串类型，这个地方可以是上次FindXXX的返回地址集合,可以进行二次搜索.(类似CE的再次扫描)\n             如果要进行地址范围搜索，那么这个值为的形如如下(类似于CE的新搜索)\n            "00400000-7FFFFFFF" "80000000-BFFFFFFF" "00000000-FFFFFFFF" 等.\ndouble_value_min 双精度浮点数: 搜索的双精度数值最小值\ndouble_value_max 双精度浮点数: 搜索的双精度数值最大值 \n 最终搜索的数值大与等于double_value_min,并且小于等于double_value_max\nstep 整形数: 搜索步长.\nmulti_thread整形数:表示是否开启多线程查找.  0不开启，1开启.\n                    开启多线程查找速度较快，但会耗费较多CPU资源. 不开启速度较慢，但节省CPU.\nmode 整形数: 1 表示开启快速扫描(略过只读内存)  0表示所有内存类型全部扫描.\n返回值:\n字符串:\n 返回搜索到的地址集合，地址格式如下:\n"addr1|addr2|addr3…|addrn"\n比如"400050|423435|453430"\n示例:\n// 全局搜索\n result = dm.FindDoubleEx(hwnd,"00000000-FFFFFFFF",0.5,1.0,8,1)\n if len(result) = 0 then\n      MessageBox "找不到"\n      EndScript\n end if\n result = split(result,"|")\n count = ubound(result)+1\n MessageBox "找到"&count&"个地址"\n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。  
FindFloat(hwnd, addr_range, float_value_min, float_value_max) = 搜索指定的单精度浮点数,默认步长是1.如果要定制步长，请用FindFloatEx\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr_range 字符串: 指定搜索的地址集合，字符串类型，这个地方可以是上次FindXXX的返回地址集合,可以进行二次搜索.(类似CE的再次扫描)\n             如果要进行地址范围搜索，那么这个值为的形如如下(类似于CE的新搜索)\n            "00400000-7FFFFFFF" "80000000-BFFFFFFF" "00000000-FFFFFFFF" 等.\nfloat_value_min 单精度浮点数: 搜索的单精度数值最小值\nfloat_value_max 单精度浮点数: 搜索的单精度数值最大值 \n 最终搜索的数值大与等于float_value_min,并且小于等于float_value_max\n返回值:\n字符串:\n 返回搜索到的地址集合，地址格式如下:\n"addr1|addr2|addr3…|addrn"\n比如"400050|423435|453430"\n示例:\n// 全局搜索\n result = dm.FindFloat(hwnd,"00000000-FFFFFFFF",0.5,1.0)\n if len(result) = 0 then\n      MessageBox "找不到"\n      EndScript\n end if\n result = split(result,"|")\n count = ubound(result)+1\n MessageBox "找到"&count&"个地址"\n 注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。
FindFloatEx(hwnd, addr_range, float_value_min, float_value_max,step,multi_thread,mode) = 搜索指定的单精度浮点数. <收费功能，具体详情点击查看>\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr_range 字符串: 指定搜索的地址集合，字符串类型，这个地方可以是上次FindXXX的返回地址集合,可以进行二次搜索.(类似CE的再次扫描)\n             如果要进行地址范围搜索，那么这个值为的形如如下(类似于CE的新搜索)\n            "00400000-7FFFFFFF" "80000000-BFFFFFFF" "00000000-FFFFFFFF" 等.\nfloat_value_min 单精度浮点数: 搜索的单精度数值最小值\nfloat_value_max 单精度浮点数: 搜索的单精度数值最大值 \n 最终搜索的数值大与等于float_value_min,并且小于等于float_value_max\nstep 整形数: 搜索步长.\nmulti_thread整形数:表示是否开启多线程查找.  0不开启，1开启.\n                    开启多线程查找速度较快，但会耗费较多CPU资源. 不开启速度较慢，但节省CPU.\nmode 整形数: 1 表示开启快速扫描(略过只读内存)  0表示所有内存类型全部扫描.\n返回值:\n字符串:\n 返回搜索到的地址集合，地址格式如下:\n"addr1|addr2|addr3…|addrn"\n比如"400050|423435|453430"\n示例:\n// 全局搜索\n result = dm.FindFloatEx(hwnd,"00000000-FFFFFFFF",0.5,1.0,4,1)\n if len(result) = 0 then\n      MessageBox "找不到"\n      EndScript\n end if\n result = split(result,"|")\n count = ubound(result)+1\n MessageBox "找到"&count&"个地址"\n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。  
FindInt(hwnd, addr_range, int_value_min, int_value_max,type) = 搜索指定的整数,默认步长是1.如果要定制步长，请用FindIntEx\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr_range 字符串: 指定搜索的地址集合，字符串类型，这个地方可以是上次FindXXX的返回地址集合,可以进行二次搜索.(类似CE的再次扫描)\n             如果要进行地址范围搜索，那么这个值为的形如如下(类似于CE的新搜索)\n            "00400000-7FFFFFFF" "80000000-BFFFFFFF" "00000000-FFFFFFFF" 等.\nint_value_min 整形数: 搜索的整数数值最小值\nint_value_max 整形数: 搜索的整数数值最大值 \n 最终搜索的数值大与等于int_value_min,并且小于等于int_value_max\ntype 整形数: 搜索的整数类型,取值如下\n      0 : 32位\n      1 : 16 位\n      2 : 8位\n返回值:\n字符串:\n 返回搜索到的地址集合，地址格式如下:\n"addr1|addr2|addr3…|addrn"\n比如"400050|423435|453430"\n示例:\n// 全局搜索\n result = dm.FindInt(hwnd,"00000000-FFFFFFFF",300,300,0)\n if len(result) = 0 then\n      MessageBox "找不到"\n      EndScript\n end if\n result = split(result,"|")\n count = ubound(result)+1\n MessageBox "找到"&count&"个地址"\n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。  
FindIntEx(hwnd, addr_range, int_value_min, int_value_max,type,step,multi_thread,mode) = 搜索指定的整数. <收费功能，具体详情点击查看>\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr_range 字符串: 指定搜索的地址集合，字符串类型，这个地方可以是上次FindXXX的返回地址集合,可以进行二次搜索.(类似CE的再次扫描)\n             如果要进行地址范围搜索，那么这个值为的形如如下(类似于CE的新搜索)\n            "00400000-7FFFFFFF" "80000000-BFFFFFFF" "00000000-FFFFFFFF" 等.\nint_value_min 整形数: 搜索的整数数值最小值\nint_value_max 整形数: 搜索的整数数值最大值 \n 最终搜索的数值大与等于int_value_min,并且小于等于int_value_max\ntype 整形数: 搜索的整数类型,取值如下\n      0 : 32位\n      1 : 16 位\n      2 : 8位\nstep 整形数: 搜索步长.\nmulti_thread整形数:表示是否开启多线程查找.  0不开启，1开启.\n                    开启多线程查找速度较快，但会耗费较多CPU资源. 不开启速度较慢，但节省CPU.\nmode 整形数: 1 表示开启快速扫描(略过只读内存)  0表示所有内存类型全部扫描.\n返回值:\n字符串:\n 返回搜索到的地址集合，地址格式如下:\n"addr1|addr2|addr3…|addrn"\n比如"400050|423435|453430"\n示例:\n// 全局搜索\n result = dm.FindIntEx(hwnd,"00000000-FFFFFFFF",300,300,0,2,1,0)\n if len(result) = 0 then\n      MessageBox "找不到"\n      EndScript\n end if\n result = split(result,"|")\n count = ubound(result)+1\n MessageBox "找到"&count&"个地址"\n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。  
FindString(hwnd, addr_range, string_value,type) = 搜索指定的字符串,默认步长是1.如果要定制步长，请用FindStringEx\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr_range 字符串: 指定搜索的地址集合，字符串类型，这个地方可以是上次FindXXX的返回地址集合,可以进行二次搜索.(类似CE的再次扫描)\n             如果要进行地址范围搜索，那么这个值为的形如如下(类似于CE的新搜索)\n            "00400000-7FFFFFFF" "80000000-BFFFFFFF" "00000000-FFFFFFFF" 等.\nstring_value 字符串: 搜索的字符串\ntype 整形数: 搜索的字符串类型,取值如下\n      0 : Ascii字符串\n      1 : Unicode字符串\n返回值:\n字符串:\n 返回搜索到的地址集合，地址格式如下:\n"addr1|addr2|addr3…|addrn"\n比如"400050|423435|453430"\n示例:\n// 全局搜索\n result = dm.FindString(hwnd,"00000000-FFFFFFFF","哈哈哈哈",0)\n if len(result) = 0 then\n      MessageBox "找不到"\n      EndScript\n end if\n result = split(result,"|")\n count = ubound(result)+1\n MessageBox "找到"&count&"个地址"\n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。  
FindStringEx(hwnd, addr_range, string_value,type,step,multi_thread,mode) = 搜索指定的字符串. <收费功能，具体详情点击查看>\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr_range 字符串: 指定搜索的地址集合，字符串类型，这个地方可以是上次FindXXX的返回地址集合,可以进行二次搜索.(类似CE的再次扫描)\n             如果要进行地址范围搜索，那么这个值为的形如如下(类似于CE的新搜索)\n            "00400000-7FFFFFFF" "80000000-BFFFFFFF" "00000000-FFFFFFFF" 等.\nstring_value 字符串: 搜索的字符串\ntype 整形数: 搜索的字符串类型,取值如下\n      0 : Ascii字符串\n      1 : Unicode字符串\nstep 整形数: 搜索步长.\nmulti_thread整形数:表示是否开启多线程查找.  0不开启，1开启.\n                    开启多线程查找速度较快，但会耗费较多CPU资源. 不开启速度较慢，但节省CPU.\nmode 整形数: 1 表示开启快速扫描(略过只读内存)  0表示所有内存类型全部扫描.\n返回值:\n字符串:\n 返回搜索到的地址集合，地址格式如下:\n"addr1|addr2|addr3…|addrn"\n比如"400050|423435|453430"\n示例:\n// 全局搜索\n result = dm.FindStringEx(hwnd,"00000000-FFFFFFFF","哈哈哈哈",0,2,1,1)\n if len(result) = 0 then\n      MessageBox "找不到"\n      EndScript\n end if\n result = split(result,"|")\n count = ubound(result)+1\n MessageBox "找到"&count&"个地址"\n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。  
FloatToData(value) = 把单精度浮点数转换成二进制形式.\n 参数定义:\n value 单精度浮点数: 需要转化的单精度浮点数\n返回值:\n字符串:\n 字符串形式表达的二进制数据. 可以用于WriteData FindData FindDataEx等接口.\n示例:\nfloat_data =  dm.FloatToData(1.24)\n dm_ret = dm.FindData(hwnd,"00000000-7fffffff",float_data)
GetModuleBaseAddr(hwnd,module) = 根据指定的窗口句柄，来获取对应窗口句柄进程下的指定模块的基址\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\nmodule 字符串: 模块名\n返回值:\n整形数:\n 模块的基址\n示例:\nbase_addr = dm.GetModuleBaseAddr(hwnd,"gdi32.dll")\n MessageBox  base_addr  \n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。
IntToData(value,type) = 把整数转换成二进制形式.\n 参数定义:\n value 整形数: 需要转化的整型数\n type  整形数: 取值如下:\n             0: 4字节整形数 (一般都选这个)\n             1: 2字节整形数\n             2: 1字节整形数\n返回值:\n字符串:\n 字符串形式表达的二进制数据. 可以用于WriteData FindData FindDataEx等接口.\n示例:\nint_data =  dm.IntToData(&H12345678,0)\n dm_ret = dm.FindData(hwnd,"00000000-7fffffff",int_data)
ReadData(hwnd,addr,len) = 读取指定地址的二进制数据\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\nlen 整形数: 二进制数据的长度\n返回值:\n字符串:\n 读取到的数值,以16进制表示的字符串 每个字节以空格相隔 比如"12 34 56 78 ab cd ef"\n示例:\nvalue = dm.ReadData(hwnd,"4DA678",10)\n MessageBox  value  \n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。
ReadDouble(hwnd,addr) = 读取指定地址的双精度浮点数\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\n返回值:\n双精度浮点数:\n 读取到的数值,注意这里无法判断读取是否成功\n示例:\nvalue = dm.ReadDouble(hwnd,"4DA678")\n MessageBox  value  \n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。
ReadFloat(hwnd,addr) = 读取指定地址的单精度浮点数\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\n返回值:\n单精度浮点数:\n 读取到的数值,注意这里无法判断读取是否成功\n示例:\nvalue = dm.ReadFloat(hwnd,"4DA678")\n MessageBox  value  \n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。
ReadInt(hwnd,addr,type) = 读取指定地址的整数数值，类型可以是8位，16位 或者 32位\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\ntype 整形数: 整数类型,取值如下\n      0 : 32位\n      1 : 16 位\n      2 : 8位\n返回值:\n整形数:\n 读取到的数值,注意这里无法判断读取是否成功\n示例:\nvalue = dm.ReadInt(hwnd,"4DA678",0)\n MessageBox  value  \n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。
ReadString(hwnd,addr,type,len) = 读取指定地址的字符串，可以是GBK字符串或者是Unicode字符串.(必须事先知道内存区的字符串编码方式)\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\ntype 整形数: 字符串类型,取值如下\n      0 : GBK字符串\n      1 : Unicode字符串\nlen 整形数: 需要读取的字节数目.\n返回值:\n字符串:\n 读取到的字符串,注意这里无法判断读取是否成功\n示例:\nvalue = dm.ReadString(hwnd,"4DA678",0,10)\n MessageBox  value  \n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。
SetMemoryFindResultToFile(file) = 设置是否把所有内存查找接口的结果保存入指定文件. <收费功能，具体详情点击查看>\n 参数定义:\n file 字符串: 设置要保存的搜索结果文件名. 如果为空字符串表示取消此功能.\n返回值:\n整形数:\n 0 : 失败\n 1 : 成功\n示例:\n// 开启\n dm.SetPath "d:\test"\n dm.SetMemoryFindResultToFile "result.dat"  \n//取消\n dm.SetMemoryFindResultToFile ""\n注: 部分高级语言无法接纳FindXXX 接口返回的超长字符串，那么需要用这个函数转存入文件,然后再读取分析处理.\n 同时，设置了此文件后，那么当下次调用FindXXX接口传入的地址参数时，并且地址参数不是范围参数,那么地址参数会从设置的文件中读取. 如果是范围参数,那么插件不会从设置的文件读取,会认为是首次查找.因为部分高级语言对参数的接收也有长度限制，无法接收超长字符串. 
SetMemoryHwndAsProcessId(en) = 设置是否把所有内存接口函数中的窗口句柄当作进程ID,以支持直接以进程ID来使用内存接口. <收费功能，具体详情点击查看>\n 参数定义:\n en 整形数: 取值如下\n              0 : 关闭  1 : 开启\n返回值:\n整形数:\n 0 : 失败\n 1 : 成功\n示例:\ndm.SetMemoryHwndAsProcessId 1\n注: 默认是当作窗口句柄.  \n注意，开启这个功能以后,dx.public.memory就会无效.
StringToData(value,type) = 把字符串转换成二进制形式.\n 参数定义:\n value字符串: 需要转化的字符串\n type  整形数: 取值如下:\n             0: 返回Ascii表达的字符串\n             1: 返回Unicode表达的字符串\n返回值:\n字符串:\n 字符串形式表达的二进制数据. 可以用于WriteData FindData FindDataEx等接口.\n示例:\nstring_data =  dm.StringToData("12345678",1)\n dm_ret = dm.FindData(hwnd,"00000000-7fffffff",string_data)
WriteData(hwnd,addr,data) = 对指定地址写入二进制数据\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\ndata 字符串: 二进制数据，以字符串形式描述，比如"12 34 56 78 90 ab cd"\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.WriteData(hwnd,"4DA678","12 34 56 78 90 ab cd")\n 注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。\n注: 简单游平台不支持此接口
WriteDouble(hwnd,addr,v) = 对指定地址写入双精度浮点数\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\nv 双精度浮点数: 双精度浮点数\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.WriteDouble(hwnd,"4DA678",2.34)\n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。\n注: 简单游平台不支持此接口
WriteFloat(hwnd,addr,v) = 对指定地址写入单精度浮点数\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\nv 单精度浮点数: 单精度浮点数\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.WriteFloat(hwnd,"4DA678",2.34)\n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。\n注: 简单游平台不支持此接口
WriteInt(hwnd,addr,type,v) = 对指定地址写入整数数值，类型可以是8位，16位 或者 32位\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\ntype 整形数: 整数类型,取值如下\n      0 : 32位\n      1 : 16 位\n      2 : 8位\nv 整形数: 整形数值\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.WriteInt(hwnd,"4DA678",0,100)\n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。  \n注: 简单游平台不支持此接口
WriteString(hwnd,addr,type,v) = 对指定地址写入字符串，可以是Ascii字符串或者是Unicode字符串\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\ntype 整形数: 字符串类型,取值如下\n      0 : Ascii字符串\n      1 : Unicode字符串\nv 字符串: 字符串\n返回值:\n整形数:\n 0: 失败\n1: 成功\n示例:\ndm_ret = dm.WriteString(hwnd,"4DA678",0,"我是来测试的")\n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。\n注: 简单游平台不支持此接口
BindWindow(hwnd,display,mouse,keypad,mode) = 绑定指定的窗口,并指定这个窗口的屏幕颜色获取方式,鼠标仿真模式,键盘仿真模式,以及模式设定,高级用户可以参考BindWindowEx更加灵活强大.\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n display 字符串: 屏幕颜色获取方式 取值有以下几种\n "normal" : 正常模式,平常我们用的前台截屏模式\n "gdi" : gdi模式,用于窗口采用GDI方式刷新时. 此模式占用CPU较大.\n"gdi2" : gdi2模式,此模式兼容性较强,但是速度比gdi模式要慢许多,如果gdi模式发现后台不刷新时,可以考虑用gdi2模式.\n "dx2" : dx2模式,用于窗口采用dx模式刷新,如果dx方式会出现窗口所在进程崩溃的状况,可以考虑采用这种.采用这种方式要保证窗口有一部分在屏幕外.win7或者vista不需要移动也可后台.此模式占用CPU较大.\n"dx3" : dx3模式,同dx2模式,但是如果发现有些窗口后台不刷新时,可以考虑用dx3模式,此模式比dx2模式慢许多. 此模式占用CPU较大.\n"dx" : dx模式,等同于BindWindowEx中，display设置的"dx.graphic.2d|dx.graphic.3d",具体参考BindWindowEx\n 注意此模式需要管理员权限\n mouse 字符串: 鼠标仿真模式 取值有以下几种\n "normal" : 正常模式,平常我们用的前台鼠标模式\n "windows": Windows模式,采取模拟windows消息方式 同按键自带后台插件.\n"windows2": Windows2 模式,采取模拟windows消息方式(锁定鼠标位置) 此模式等同于BindWindowEx中的mouse为以下组合\n "dx.mouse.position.lock.api|dx.mouse.position.lock.message|dx.mouse.state.message"\n 注意此模式需要管理员权限\n"windows3": Windows3模式，采取模拟windows消息方式,可以支持有多个子窗口的窗口后台.\n "dx": dx模式,采用模拟dx后台鼠标模式,这种方式会锁定鼠标输入.有些窗口在此模式下绑定时，需要先激活窗口再绑定(或者绑定以后激活)，否则可能会出现绑定后鼠标无效的情况.此模式等同于BindWindowEx中的mouse为以下组合\n "dx.public.active.api|dx.public.active.message|dx.mouse.position.lock.api|dx.mouse.position.lock.message|dx.mouse.state.api|dx.mouse.state.message|dx.mouse.api|dx.mouse.focus.input.api|dx.mouse.focus.input.message|dx.mouse.clip.lock.api|dx.mouse.input.lock.api|dx.mouse.cursor"\n 注意此模式需要管理员权限\n"dx2"：dx2模式,这种方式类似于dx模式,但是不会锁定外部鼠标输入.\n 有些窗口在此模式下绑定时，需要先激活窗口再绑定(或者绑定以后手动激活)，否则可能会出现绑定后鼠标无效的情况. 此模式等同于BindWindowEx中的mouse为以下组合\n "dx.public.active.api|dx.public.active.message|dx.mouse.position.lock.api|dx.mouse.state.api|dx.mouse.api|dx.mouse.focus.input.api|dx.mouse.focus.input.message|dx.mouse.clip.lock.api|dx.mouse.input.lock.api| dx.mouse.cursor"\n 注意此模式需要管理员权限\n keypad 字符串: 键盘仿真模式 取值有以下几种\n "normal" : 正常模式,平常我们用的前台键盘模式\n "windows": Windows模式,采取模拟windows消息方式 同按键的后台插件.\n "dx": dx模式,采用模拟dx后台键盘模式。有些窗口在此模式下绑定时，需要先激活窗口再绑定(或者绑定以后激活)，否则可能会出现绑定后键盘无效的情况. 此模式等同于BindWindowEx中的keypad为以下组合\n "dx.public.active.api|dx.public.active.message| dx.keypad.state.api|dx.keypad.api|dx.keypad.input.lock.api"\n 注意此模式需要管理员权限\nmode 整形数: 模式。 取值有以下两种\n     0 : 推荐模式此模式比较通用，而且后台效果是最好的.\n     1 : 和模式0效果一样，如果模式0会失败时，可以尝试此模式. <收费功能，具体详情点击查看>\n     2 : 同模式0,此模式为老的模式0,尽量不要用此模式，除非有兼容性问题.\n     3 : 同模式1,此模式为老的模式1,尽量不要用此模式，除非有兼容性问题. <收费功能，具体详情点击查看>\n     4 : 同模式0,如果模式0有崩溃问题，可以尝试此模式.\n     5 : 同模式1, 如果模式0有崩溃问题，可以尝试此模式. <收费功能，具体详情点击查看>\n     6 : 同模式0，如果模式0有崩溃问题，可以尝试此模式. <收费功能，具体详情点击查看>\n     7 : 同模式1，如果模式1有崩溃问题，可以尝试此模式. <收费功能，具体详情点击查看>\n     101 : 超级绑定模式. 可隐藏目标进程中的dm.dll.避免被恶意检测.效果要比dx.public.hide.dll好. 推荐使用. <收费功能，具体详情点击查看>\n     103 : 同模式101，如果模式101有崩溃问题，可以尝试此模式. <收费功能，具体详情点击查看>\n需要注意的是: 模式1 3 5 7 101 103在大部分窗口下绑定都没问题。但也有少数特殊的窗口，比如有很多子窗口的窗口，对于这种窗口，在绑定时，一定要把\n 鼠标指向一个可以输入文字的窗口，比如一个文本框，最好能激活这个文本框，这样可以保证绑定的成功.\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n 如果返回0，可以调用GetLastError来查看具体失败错误码,帮助分析问题.\n示例:\n // display: 前台 鼠标:前台 键盘:前台 模式0\n dm_ret = dm.BindWindow(hwnd,"normal","normal","normal",0)\n// display: gdi 鼠标:前台 键盘:前台 模式1\n dm_ret = dm.BindWindow(hwnd,"gdi","normal","normal",1)\n// display: dx 鼠标:前台 键盘:前台 模式0\n dm_ret = dm.BindWindow(hwnd,"dx","normal","normal",0)\n// display: dx 鼠标:windows后台 键盘:windows后台 模式1\n dm_ret = dm.BindWindow(hwnd,"dx","windows","windows",1)\n// display: dx 鼠标:dx 后台 键盘: dx后台 模式1\n dm_ret = dm.BindWindow(hwnd,"dx","dx","dx",1) \n// display: dx 鼠标:windows3后台 键盘:windows后台 模式1\n dm_ret = dm.BindWindow(hwnd,"dx","windows3","windows",1)\n 注意:\n 绑定之后,所有的坐标都相对于窗口的客户区坐标(不包含窗口边框)\n 另外,绑定窗口后,必须加以下代码,以保证所有资源正常释放\n这个函数的意思是在脚本结束时,会调用这个函数。需要注意的是，目前的按键版本对于这个函数的执行不是线程级别的，也就是说，这个函数只会在主线程执行，子线程绑定的大漠对象，不保证完全释放。 \n Sub OnScriptExit()\n     dm_ret = dm.UnBindWindow() \n End Sub\n另外 绑定dx会比较耗时间,请不要频繁调用此函数.\n另外如果绑定的是dx,要注意不可连续操作dx,中间至少加个10MS的延时,否则可能会导致操作失败.比如绑定图色DX,那么不要连续取色等,键鼠也是一样.\n注意,图色dx,鼠标windows2 dx dx2以及键盘dx都需要管理员权限才能运行,所以对于WIN7和VISTA用户,在启动目标窗口时,必须用管理员方式启动,否则无法绑定成功！\n还有一点特别要注意的是,有些窗口绑定之后必须加一定的延时,否则后台也无效.一般1秒到2秒的延时就足够.\n发现绑定失败的几种可能(一般是需要管理员权限的模式才有可能会失败)\n 1.     系统登录的帐号必须有Administrators权限\n 2.     如果是vista和win7系统，启动窗口进程必须用管理员模式启动，脚本也必须用管理员模式启动.\n 3.     一些防火墙会防止插件注入窗口所在进程，比如360防火墙等，必须把dm.dll设置为信任.\n 4.     还有一个比较弱智的可能性，那就是插件没有注册到系统中，这时CreateObject压根就是失败的. 检测对象是否创建成功很简单，如下代码\n set dm = createobject("dm.dmsoft")\n ver = dm.Ver()\n If len(ver) = 0 Then\n     MessageBox "创建对象失败,检查系统是否禁用了vbs脚本权限"\n     EndScript\n End If\n 5.     在沙盘中开的窗口进程，绑定一些需要管理员权限的模式，会失败。\n 解决方法是要配置沙盘参数，具体如何配置参考沙盘绑定方法.  \n 6.     窗口所在进程有保护，这个我也无能为力.
BindWindowEx(hwnd,display,mouse,keypad,public,mode) = 绑定指定的窗口,并指定这个窗口的屏幕颜色获取方式,鼠标仿真模式,键盘仿真模式 高级用户使用.\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n display 字符串: 屏幕颜色获取方式 取值有以下几种\n "normal" : 正常模式,平常我们用的前台截屏模式\n "gdi" : gdi模式,用于窗口采用GDI方式刷新时. 此模式占用CPU较大.\n"gdi2" : gdi2模式,此模式兼容性较强,但是速度比gdi模式要慢许多,如果gdi模式发现后台不刷新时,可以考虑用gdi2模式.\n "dx2" : dx2模式,用于窗口采用dx模式刷新,如果dx方式会出现窗口进程崩溃的状况,可以考虑采用这种.采用这种方式要保证窗口有一部分在屏幕外.win7或者vista不需要移动也可后台. 此模式占用CPU较大.\n"dx3" : dx3模式,同dx2模式,但是如果发现有些窗口后台不刷新时,可以考虑用dx3模式,此模式比dx2模式慢许多. 此模式占用CPU较大.\n dx模式,用于窗口采用dx模式刷新,取值可以是以下任意组合，组合采用"|"符号进行连接  注意此模式需要管理员权限. 支持BindWindow中的缩写模式. 比如dx代表" dx.graphic.2d| dx.graphic.3d"\n 1. "dx.graphic.2d"  2d窗口的dx图色模式  \n 2. "dx.graphic.2d.2"  2d窗口的dx图色模式  是dx.graphic.2d的增强模式.兼容性更好. <收费功能，具体详情点击查看>\n 3. "dx.graphic.3d"  3d窗口的dx图色模式,注意采用这个模式，必须关闭窗口3D视频设置的全屏抗锯齿选项.\n 4. "dx.graphic.3d.8"  3d窗口的dx8图色模式,注意采用这个模式，必须关闭窗口3D视频设置的全屏抗锯齿选项. 这个模式支持某些老的引擎. <收费功能，具体详情点击查看>\n mouse 字符串: 鼠标仿真模式 取值有以下几种\n "normal" : 正常模式,平常我们用的前台鼠标模式\n "windows": Windows模式,采取模拟windows消息方式 同按键的后台插件.\n"windows3": Windows3模式，采取模拟windows消息方式,可以支持有多个子窗口的窗口后台\ndx模式,取值可以是以下任意组合. 组合采用"|"符号进行连接 注意此模式需要管理员权限.支持BindWindow中的缩写模式,比如windows2代表"dx.mouse.position.lock.api|dx.mouse.position.lock.message|dx.mouse.state.message"\n 1. "dx.mouse.position.lock.api"  此模式表示通过封锁系统API，来锁定鼠标位置.\n 2. "dx.mouse.position.lock.message" 此模式表示通过封锁系统消息，来锁定鼠标位置.\n 3. "dx.mouse.focus.input.api" 此模式表示通过封锁系统API来锁定鼠标输入焦点.\n 4. "dx.mouse.focus.input.message"此模式表示通过封锁系统消息来锁定鼠标输入焦点.\n 5. "dx.mouse.clip.lock.api" 此模式表示通过封锁系统API来锁定刷新区域。注意，使用这个模式，在绑定前，必须要让窗口完全显示出来.\n 6. "dx.mouse.input.lock.api" 此模式表示通过封锁系统API来锁定鼠标输入接口.\n 7. "dx.mouse.state.api" 此模式表示通过封锁系统API来锁定鼠标输入状态.\n 8. "dx.mouse.state.message" 此模式表示通过封锁系统消息来锁定鼠标输入状态.\n 9. "dx.mouse.api"  此模式表示通过封锁系统API来模拟dx鼠标输入.\n 10. "dx.mouse.cursor"  开启此模式，可以后台获取鼠标特征码. <收费功能，具体详情点击查看>\n 11. "dx.mouse.raw.input"  有些窗口需要这个才可以正常操作鼠标. <收费功能，具体详情点击查看>\n 12. "dx.mouse.input.lock.api2"  部分窗口在后台操作时，前台鼠标会移动,需要这个属性. <收费功能，具体详情点击查看>\n 13. "dx.mouse.input.lock.api3"  部分窗口在后台操作时，前台鼠标会移动,需要这个属性. <收费功能，具体详情点击查看>\n keypad 字符串: 键盘仿真模式 取值有以下几种\n "normal" : 正常模式,平常我们用的前台键盘模式\n "windows": Windows模式,采取模拟windows消息方式 同按键的后台插件.\n dx模式,取值可以是以下任意组合. 组合采用"|"符号进行连接 注意此模式需要管理员权限.支持BindWindow中的缩写模式.比如dx代表" dx.public.active.api|dx.public.active.message| dx.keypad.state.api|dx.keypad.api|dx.keypad.input.lock.api"\n 1. "dx.keypad.input.lock.api" 此模式表示通过封锁系统API来锁定键盘输入接口.\n 2. "dx.keypad.state.api" 此模式表示通过封锁系统API来锁定键盘输入状态.\n 3. "dx.keypad.api" 此模式表示通过封锁系统API来模拟dx键盘输入. \n 4. "dx.keypad.raw.input"  有些窗口需要这个才可以正常操作键盘. <收费功能，具体详情点击查看>\npublic 字符串: 公共属性 dx模式共有  注意以下列表中,前面打五角星的表示需要管理员权限 \n 取值可以是以下任意组合. 组合采用"|"符号进行连接 这个值可以为空\n 1. ★ "dx.public.active.api" 此模式表示通过封锁系统API来锁定窗口激活状态.  注意，部分窗口在此模式下会耗费大量资源 慎用. \n 2. ★ "dx.public.active.message" 此模式表示通过封锁系统消息来锁定窗口激活状态.  注意，部分窗口在此模式下会耗费大量资源 慎用. 另外如果要让此模式生效，必须在绑定前，让绑定窗口处于激活状态,否则此模式将失效. 比如dm.SetWindowState hwnd,1 然后再绑定.\n 3.    "dx.public.disable.window.position" 此模式将锁定绑定窗口位置.不可与"dx.public.fake.window.min"共用.\n 4.    "dx.public.disable.window.size" 此模式将锁定绑定窗口,禁止改变大小. 不可与"dx.public.fake.window.min"共用.\n 5.    "dx.public.disable.window.minmax" 此模式将禁止窗口最大化和最小化,但是付出的代价是窗口同时也会被置顶. 不可与"dx.public.fake.window.min"共用.\n 6.    "dx.public.fake.window.min" 此模式将允许目标窗口在最小化状态时，仍然能够像非最小化一样操作.. 另注意，此模式会导致任务栏顺序重排，所以如果是多开模式下，会看起来比较混乱，建议单开使用，多开不建议使用. <收费功能，具体详情点击查看>\n 7.    "dx.public.hide.dll" 此模式将会隐藏目标进程的大漠插件，避免被检测..另外使用此模式前，请仔细做过测试，此模式可能会造成目标进程不稳定，出现崩溃。<收费功能，具体详情点击查看>\n 8. ★ "dx.public.active.api2" 此模式表示通过封锁系统API来锁定窗口激活状态. 部分窗口遮挡无法后台,需要这个属性. <收费功能，具体详情点击查看>\n 9. ★ "dx.public.input.ime" 此模式是配合SendStringIme使用. 具体可以查看SendStringIme接口. <收费功能，具体详情点击查看>\n 10 ★ "dx.public.graphic.protect" 此模式可以保护dx图色不被恶意检测.同时对dx.keypad.api和dx.mouse.api也有保护效果. <收费功能，具体详情点击查看>\n 11 ★ "dx.public.disable.window.show" 禁止目标窗口显示,这个一般用来配合dx.public.fake.window.min来使用. <收费功能，具体详情点击查看>\n 12 ★ "dx.public.anti.api" 此模式可以突破部分窗口对后台的保护. <收费功能，具体详情点击查看>\n 13 ★ "dx.public.memory" 此模式可以让内存读写函数突破保护.只要绑定成功即可操作内存函数. <收费功能，具体详情点击查看>\n 14 ★ "dx.public.km.protect" 此模式可以保护dx键鼠不被恶意检测.最好配合dx.public.anti.api一起使用. 此属性可能会导致部分后台功能失效. <收费功能，具体详情点击查看>\n 15    "dx.public.prevent.block"  绑定模式1 3 5 7 101 103下，可能会导致部分窗口卡死. 这个属性可以避免卡死. <收费功能，具体详情点击查看>\n 16    "dx.public.ori.proc"  此属性只能用在模式0 1 2 3和101下. 有些窗口在不同的界面下(比如登录界面和登录进以后的界面)，键鼠的控制效果不相同. 那可以用这个属性来尝试让保持一致. 注意的是，这个属性不可以滥用，确保测试无问题才可以使用. 否则可能会导致后台失效. <收费功能，具体详情点击查看>\nmode 整形数: 模式。 取值有以下两种\n     0 : 推荐模式,此模式比较通用，而且后台效果是最好的.\n     1 : 和模式0效果一样，如果模式0会失败时，可以尝试此模式, <收费功能，具体详情点击查看>. \n     2 : 同模式0,此模式为老的模式0,尽量不要用此模式，除非有兼容性问题.\n     3 : 同模式1,此模式为老的模式1,尽量不要用此模式，除非有兼容性问题. <收费功能，具体详情点击查看>\n     4 : 同模式0,如果模式0有崩溃问题，可以尝试此模式.\n     5 : 同模式1, 如果模式0有崩溃问题，可以尝试此模式. <收费功能，具体详情点击查看>\n     6 : 同模式0，如果模式0有崩溃问题，可以尝试此模式. <收费功能，具体详情点击查看>.\n     7 : 同模式1，如果模式1有崩溃问题，可以尝试此模式. <收费功能，具体详情点击查看>.\n     101 : 超级绑定模式. 可隐藏目标进程中的dm.dll.避免被恶意检测.效果要比dx.public.hide.dll好. 推荐使用. <收费功能，具体详情点击查看>\n     103 : 同模式101，如果模式101有崩溃问题，可以尝试此模式. <收费功能，具体详情点击查看>\n需要注意的是: 模式1 3 5 7 101 103在大部分窗口下绑定都没问题。但也有少数特殊的窗口，比如有很多子窗口的窗口，对于这种窗口，在绑定时，一定要把鼠标指向一个可以输入文字的窗口，比如一个文本框，最好能激活这个文本框，这样可以保证绑定的成功.\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n 如果返回0，可以调用GetLastError来查看具体失败错误码,帮助分析问题.\n示例:\n 比如\n dm_ret = dm.BindWindowEx(hwnd,"normal","dx.mouse.position.lock.api|dx.mouse.position.lock.message","windows","dx.public.active.api",0)\ndm_ret = dm.BindWindowEx(hwnd,"dx2","windows","normal","dx.public.active.api",0)\ndm_ret = dm.BindWindowEx(hwnd,"dx.graphic.2d","dx.mouse.position.lock.api|dx.mouse.position.lock.message","dx.keypad.state.api|dx.keypad.api","",0)\ndm_ret = dm.BindWindowEx(hwnd,"dx2","windows","windows","",0)\n dm_ret = dm.BindWindowEx(hwnd,"dx2","windows","windows","dx.public.disable.window.size|dx.public.disable.window.minmax",0)\ndm_ret = dm.BindWindowEx(hwnd,"dx2","windows3","windows","dx.mouse.position.lock.api",0)\n等等.\n 注意:\n 绑定之后,所有的坐标都相对于窗口的客户区坐标(不包含窗口边框)\n 另外,绑定窗口后,必须加以下代码,以保证所有资源正常释放\n这个函数的意思是在脚本结束时,会调用这个函数。需要注意的是，目前的按键版本对于这个函数的执行不是线程级别的，也就是说，这个函数只会在主线程执行，子线程绑定的大漠对象，不保证完全释放。高级语言中则需要自己控制在适当的时候解除绑定.\n Sub OnScriptExit()\n     dm_ret = dm.UnBindWindow() \n End Sub\n另外 绑定dx会比较耗时间,请不要频繁调用此函数.\n另外如果绑定的是dx,要注意不可连续操作dx,中间至少加个10MS的延时,否则可能会导致操作失败.比如绑定图色DX,那么不要连续取色等,键鼠也是一样.\n注意,需要组合的模式,都需要管理员权限才能运行,所以对于WIN7和VISTA用户,在启动窗口进程时,必须用管理员方式启动,否则无法绑定成功！\n还有一点特别要注意的是,有些窗口绑定之后必须加一定的延时,否则后台也无效.一般1秒到2秒的延时就足够.\n发现绑定失败的几种可能(一般是需要管理员权限的模式才有可能会失败)\n 1.     系统登录的帐号必须有Administrators权限\n 2.     如果是vista和win7系统，启动窗口进程必须用管理员模式启动，脚本也必须用管理员模式启动.\n 3.     一些防火墙会防止插件注入窗口所在进程，比如360防火墙等，必须把dm.dll设置为信任.\n 4.     还有一个比较弱智的可能性，那就是插件没有注册到系统中，这时CreateObject压根就是失败的. 检测对象是否创建成功很简单，如下代码\n set dm = createobject("dm.dmsoft")\n ver = dm.Ver()\n If len(ver) = 0 Then\n     MessageBox "创建对象失败,检查系统是否禁用了vbs脚本权限"\n     EndScript\n End If\n 5.     在沙盘中开的窗口，绑定一些需要管理员权限的模式，会失败。\n 解决方法是要配置沙盘参数，参考如何配置沙盘参数.  \n 6.     窗口所在进程有保护，这个我也无能为力.
DownCpu(rate) = 降低目标窗口所在进程的CPU占用\n 参数定义:\n rate 整形数: 取值范围0到100   取值为0 表示关闭CPU优化. 这个值越大表示降低CPU效果越好.\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n dm_ret = dm.BindWindowEx(hwnd,"dx.graphic.3d","normal","normal","",0)\n dm.DownCpu 50\n注意: 此接口必须在绑定窗口成功以后调用，而且必须保证目标窗口可以支持dx.graphic.3d或者dx.graphic.3d.8或者dx.graphic.2d或者dx.graphic.2d.2方式截图，否则降低CPU无效.\n因为降低CPU是通过降低窗口刷新速度来实现，所以注意，开启此功能以后会导致窗口刷新速度变慢.  
EnableBind(enable) = 设置是否暂时关闭或者开启后台功能. 默认是开启.    <收费功能，具体详情点击查看>\n 参数定义:\n enable 整形数: 0 全部关闭(图色键鼠都关闭,也就是说图色,键鼠都是前台,但是如果有指定dx.public.active.message时，在窗口前后台切换时，这个属性会失效.)\n -1 只关闭图色.(也就是说图色是normal前台. 键鼠不变)\n 1 开启(恢复原始状态)\n 5 同0，也是全部关闭，但是这个模式下，就算窗口在前后台切换时，属性dx.public.active.message的效果也一样不会失效.\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n// 绑定为后台\n dm_ret = dm.BindWindow(hwnd,"dx","dx","dx",101)\n // 后台操作\n …\n // 切换到前台\n dm.EnableBind 0\n // 前台操作\n …\n // 再切换回后台\n dm.EnableBind 1\n注: 注意切换到前台以后,相当于dm_ret = dm.BindWindow(hwnd,"normal","normal","normal",0),图色键鼠全部是前台.\n 如果你经常有频繁切换后台和前台的操作，推荐使用这个函数.\n 同时要注意,如果有多个对象绑定了同个窗口，其中任何一个对象禁止了后台,那么其他对象后台也同样失效.
EnableFakeActive(enable) = 设置是否开启后台假激活功能. 默认是关闭. 一般用不到. 除非有人有特殊需求. 注意看注释.     <收费功能，具体详情点击查看>\n 参数定义:\n enable 整形数: 0 关闭\n                1 开启\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n// 绑定以后再调用此函数\n dm.EnableFakeActive 1\n // 这里做需要在窗口非激活状态下,可以操作的接口或者第三方函数\n …\n // 恢复\n dm.EnableFakeActive 0\n注: 此接口的含义并不是关闭或者开启窗口假激活功能(dx.public.active.api或者dx.public.active.message). 而是说有些时候，本来窗口没有激活并且在没有绑定的状态下，可以正常使用的功能，而在窗口绑定以后,并且窗口在非激活状态下,此时由于绑定的锁定导致无法使用. 那么，你就需要把你的部分代码用EnableFakeActive来保护起来。 这样就让我的插件认为你的这段代码是在窗口激活状态下执行.\n另外，此函数开启以后，有可能会让前台影响到后台. 所以如果不是特殊情况，最好是关闭. \n 有些时候，有人会故意利用这个前台影响后台的作用，做类似同步器的软件，那这个函数就很有作用了.
EnableIme(enable) = 设置是否关闭绑定窗口所在进程的输入法.\n 参数定义:\n enable 整形数: 1 开启\n 0 关闭\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n// 绑定为后台\n dm_ret = dm.BindWindow(hwnd,"dx","dx","dx",101)\n …\n // 关闭输入法\n dm.EnableIme 0 \n …\n // 再开启输入法\n dm.EnableIme 1\n注: 此函数必须在绑定后调用才有效果.
EnableKeypadMsg(enable) = 是否在使用dx键盘时开启windows消息.默认开启.      <收费功能，具体详情点击查看>\n 参数定义:\n enable 整形数: 0 禁止\n                1开启\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n dm_ret = dm.BindWindow(hwnd,"dx","dx2","dx",0)\n dm.EnableKeypadMsg 0\n注: 此接口必须在绑定之后才能调用。 特殊时候使用.
EnableKeypadPatch(enable) = 键盘消息发送补丁. 默认是关闭      <收费功能，具体详情点击查看>\n 参数定义:\n enable 整形数: 0 禁止\n                1开启  \n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n dm_ret = dm.BindWindow(hwnd,"dx","dx2","dx",0)\n dm.EnableKeypadPatch 1\n注: 此接口必须在绑定之后才能调用。
EnableKeypadSync(enable,time_out) = 键盘消息采用同步发送模式.默认异步.      <收费功能，具体详情点击查看>\n 参数定义:\n enable 整形数: 0 禁止同步\n                1开启同步\n time_out 整形数: 单位是毫秒,表示同步等待的最大时间.\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n dm_ret = dm.BindWindow(hwnd,"dx","dx2","dx",0)\n dm.EnableKeypadSync 1,200\n注: 此接口必须在绑定之后才能调用。\n有些时候，如果是异步发送，如果发送动作太快,中间没有延时,有可能下个动作会影响前面的.\n而用同步就没有这个担心.
EnableMouseMsg(enable) = 是否在使用dx鼠标时开启windows消息.默认开启.      <收费功能，具体详情点击查看>\n 参数定义:\n enable 整形数: 0 禁止\n                1开启\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n dm_ret = dm.BindWindow(hwnd,"dx","dx2","dx",0)\n dm.EnableMouseMsg 0\n注: 此接口必须在绑定之后才能调用。特殊时候使用.
EnableMouseSync(enable,time_out) = 鼠标消息采用同步发送模式.默认异步.      <收费功能，具体详情点击查看>\n 参数定义:\n enable 整形数: 0 禁止同步\n                1开启同步\n time_out 整形数: 单位是毫秒,表示同步等待的最大时间.\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n dm_ret = dm.BindWindow(hwnd,"dx","dx2","dx",0)\n dm.EnableMouseSync 1,200\n注: 此接口必须在绑定之后才能调用。\n有些时候，如果是异步发送，如果发送动作太快,中间没有延时,有可能下个动作会影响前面的.\n而用同步就没有这个担心.
EnableRealKeypad(enable) = 键盘动作模拟真实操作,点击延时随机.      <收费功能，具体详情点击查看>\n 参数定义:\n enable 整形数: 0 关闭模拟\n                1 开启模拟\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n dm.EnableRealKeypad 1\ndm.KeyPressChar "E"\n注: 此接口对KeyPress KeyPressChar KeyPressStr起作用。具体表现是键盘按下和弹起的间隔会在\n 当前设定延时的基础上,上下随机浮动50%. 假如 设定的键盘延时是100,那么这个延时可能就是50-150之间的一个值.\n设定延时的函数是 SetKeypadDelay
EnableRealMouse(enable,mousedelay,mousestep) = 鼠标动作模拟真实操作,带移动轨迹,以及点击延时随机.      <收费功能，具体详情点击查看>\n 参数定义:\n enable 整形数: 0 关闭模拟\n                1 开启模拟\n mousedelay 整形数: 单位是毫秒. 表示在模拟鼠标移动轨迹时,每移动一次的时间间隔.这个值越大,鼠标移动越慢.\n Mousestep 整形数: 表示在模拟鼠标移动轨迹时,每移动一次的距离. 这个值越大，鼠标移动越快速.\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n dm.EnableRealMouse 1,20,30\ndm.MoveTo 100,100\n dm.MoveTo 500,500\n注: 此接口同样对LeftClick RightClick MiddleClick LeftDoubleClick起作用。具体表现是鼠标按下和弹起的间隔会在\n 当前设定延时的基础上,上下随机浮动50%. 假如 设定的鼠标延时是100,那么这个延时可能就是50-150之间的一个值.\n设定延时的函数是 SetMouseDelay
EnableSpeedDx(enable) = 设置是否开启高速dx键鼠模式。 默认是关闭.\n 参数定义:\n enable 整形数: 0 关闭\n 1 开启\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm.EnableSpeedDx 1\n注: 此函数开启的后果就是，所有dx键鼠操作将不会等待，适用于某些特殊的场合(比如避免窗口无响应导致宿主进程也卡死的问题).\n EnableMouseSync和EnableKeyboardSync开启以后，此函数就无效了.\n 此函数可能在部分窗口下会有副作用，谨慎使用!!
ForceUnBindWindow(hwnd) = 强制解除绑定窗口,并释放系统资源.       <收费功能，具体详情点击查看>\n 参数定义:\n hwnd 整形数: 需要强制解除绑定的窗口句柄.\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n dm_ret = dm.ForceUnBindWindow(hwnd)\n注: 此接口一般用在BindWindow和BindWindowEx中，使用了模式1 3 5 7或者属性dx.public.hide.dll后，在线程或者进程结束后，没有正确调用UnBindWindow而导致下次绑定无法成功时，可以先调用这个函数强制解除绑定，并释放资源，再进行绑定.\n 此接口不可替代UnBindWindow. 只是用在非常时刻. 切记.\n 一般情况下可以无条件的在BindWindow或者BindWindowEx之前调用一次此函数。保证此刻窗口处于非绑定状态.\n 另外，需要注意的是,此函数只可以强制解绑在同进程绑定的窗口.  不可在不同的进程解绑别的进程绑定的窗口.(会产生异常)
IsBind(hwnd) = 判定指定窗口是否已经被后台绑定. (前台无法判定)  <收费功能，具体详情点击查看>\n 参数定义:\n hwnd 整形数: 窗口句柄 \n返回值:\n整形数:\n 0: 没绑定,或者窗口不存在.\n 1: 已经绑定.\n示例:\ndm_ret = dm.IsBind(hwnd)
LockDisplay(lock) = 锁定指定窗口的图色数据(不刷新).  <收费功能，具体详情点击查看>\n 参数定义:\n lock 整形数: 0关闭锁定\n              1 开启锁定  \n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n dm_ret = dm.BindWindow(hwnd,"dx","dx2","dx",0)\n dm.LockDisplay 1\n // 这里做需要锁定做的事情\n dm.LockDisplay 0\n注意: 此接口只对图色为dx.graphic.3d  dx.graphic.3d.8 dx.graphic.2d  dx.graphic.2d.2有效.  
LockInput(lock) = 禁止外部输入到指定窗口\n 参数定义:\n lock 整形数: 0关闭锁定\n        1 开启锁定(键盘鼠标都锁定)\n        2 只锁定鼠标\n        3 只锁定键盘\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n dm_ret = dm.BindWindow(hwnd,"dx","dx2","dx",0)\n dm.LockInput 1\n // 这里做需要锁定输入做的事情\n dm.LockInput 0\n注意:此接口只针对dx键鼠. 普通键鼠无效. \n 有时候，绑定为dx2 鼠标模式时(或者没有锁定鼠标位置或状态时)，在脚本处理过程中，在某个时候需要临时锁定外部输入，以免外部干扰，那么这个函数就非常有用.\n 比如某个信息，需要鼠标移动到某个位置才可以获取，但这时，如果外部干扰，那么很可能就会获取失败，所以，这时候就很有必要锁定外部输入. \n 当然，锁定完以后，记得要解除锁定，否则外部永远都无法输入了，除非解除了窗口绑定.
LockMouseRect(x1,y1,x2,y2) = 设置前台鼠标在屏幕上的活动范围.\n 参数定义:\nx1 整形数:区域的左上X坐标. 屏幕坐标.\n y1 整形数:区域的左上Y坐标. 屏幕坐标.\n x2 整形数:区域的右下X坐标. 屏幕坐标.\n y2 整形数:区域的右下Y坐标. 屏幕坐标.\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n// 限制鼠标只能在10,10,800,600区域内活动.\n dm.LockMouseRect 10,10,800,600\n …\n Sub OnScriptExit()\n     // 恢复,4个参数都是0,表示恢复鼠标活动范围为整个屏幕区域.\n     dm.LockMouseRect 0,0,0,0\n End Sub\n注: 调用此函数后，一旦有窗口切换或者窗口移动的动作，那么限制立刻失效.\n 如果想一直限制鼠标范围在指定的窗口客户区域，那么你需要启动一个线程，并且时刻监视当前活动窗口，然后根据情况调用此函数限制鼠标范围.
SetDisplayDelay(time) = 设置dx截图最长等待时间。内部默认是3000毫秒. 一般用不到调整这个.\n 参数定义:\n time  整形数: 等待时间，单位是毫秒。 注意这里不能设置的过小，否则可能会导致截图失败,从而导致图色函数和文字识别失败.\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm.SetDisplayDelay 500\n 注: 此接口仅对 图色为dx.graphic.3d   dx.graphic.3d.8  dx.graphic.2d   dx.graphic.2d.2有效. 其他图色模式无效.\n 默认情况下，截图需要等待一个延时，超时就认为截图失败. 这个接口可以调整这个延时. 某些时候或许有用.比如当窗口图色卡死(这时获取图色一定都是超时)，并且要判断窗口卡死，那么这个设置就很有用了。
SetSimMode(mode) = 设置前台键鼠的模拟方式.     <收费功能，具体详情点击查看>\n 参数定义:\n mode 整形数: 0 正常模式(默认模式)\n              1 超级模拟\n              2 硬件模拟\n返回值:\n整形数:\n 0  : 插件没注册\n -1 : 64位平台不支持\n -2 : 驱动释放失败.\n -3 : 驱动加载失败.可能是权限不够. 参考UAC权限设置.\n 1  : 成功\n示例:\ndm.SetSimMode 1\n …\n dm_ret = dm.BindWindow(hwnd,"normal","normal","normal",0)\n ...\n dm.UnBindWindow\n注: 超级模拟和硬件模拟方式目前仅支持32位平台(目前测试正常的系统有xp,2003,vista,win7,2008). 64位平台暂时不支持.\n 超级模拟方式需要加载驱动，所以调用进程必须有管理员权限,参考如何关闭UAC.\n 加载驱动时，必须让安全软件放行. 否则模拟无效.
UnBindWindow() = 解除绑定窗口,并释放系统资源.一般在OnScriptExit调用\n 参数定义:\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n Sub OnScriptExit()\n     dm_ret = dm.UnBindWindow() \n End Sub
AppendPicAddr(pic_info,addr,size) = 对指定的数据地址和长度，组合成新的参数. FindPicMem FindPicMemE 以及FindPicMemEx专用\n参数定义:\npic_info 字符串: 老的地址描述串\naddr 整形数: 数据地址\nsize 整形数: 数据长度\n返回值:\n 字符串:\n 新的地址描述串\n示例:\npic_info = ""\n pic_info = dm.AppendPicAddr(pic_info,12034,643)\n pic_info = dm.AppendPicAddr(pic_info,328435,8935)\n pic_info = dm.AppendPicAddr(pic_info,809234,789) 
BGR2RGB(bgr_color) = 把BGR(按键格式)的颜色格式转换为RGB\n参数定义:\n bgr_color 字符串:bgr格式的颜色字符串\n返回值:\n字符串:\n RGB格式的字符串\n示例:\n rgb_color = dm.BGR2RGB(bgr_color)
Capture(x1, y1, x2, y2, file) = 抓取指定区域(x1, y1, x2, y2)的图像,保存为file(24位位图)\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n file 字符串:保存的文件名,保存的地方一般为SetPath中设置的目录\n     当然这里也可以指定全路径名.\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm_ret = dm.Capture(0,0,2000,2000,"screen.bmp")
CaptureGif(x1, y1, x2, y2, file,delay,time) = 抓取指定区域(x1, y1, x2, y2)的动画，保存为gif格式\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n file 字符串:保存的文件名,保存的地方一般为SetPath中设置的目录\n     当然这里也可以指定全路径名.\n delay 整形数: 动画间隔，单位毫秒。 如果为0，表示只截取静态图片\n time 整形数: 总共截取多久的动画，单位毫秒。\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n// 截取动画\n dm_ret = dm.CaptureGif(0,0,2000,2000,"screen.gif",100,3000)\n // 截取静态\n dm_ret = dm.CaptureGif(0,0,2000,2000,"screen.gif",0,0)
CaptureJpg(x1, y1, x2, y2, file, quality) = 抓取指定区域(x1, y1, x2, y2)的图像,保存为file(JPG压缩格式)\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n file 字符串:保存的文件名,保存的地方一般为SetPath中设置的目录\n     当然这里也可以指定全路径名.\n quality 整形数: jpg压缩比率(1-100) 越大图片质量越好\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm_ret = dm.CaptureJpg(0,0,2000,2000,"screen.jpg",50)
CapturePng(x1,y1,x2,y2,file) = 同Capture函数，只是保存的格式为PNG.\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n file 字符串:保存的文件名,保存的地方一般为SetPath中设置的目录\n     当然这里也可以指定全路径名.  \n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm_ret = dm.CapturePng(0,0,2000,2000,"screen.png")
CapturePre(file) = 抓取上次操作的图色区域，保存为file(24位位图)\n参数定义:\n file 字符串:保存的文件名,保存的地方一般为SetPath中设置的目录\n     当然这里也可以指定全路径名.\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm_ret = dm.CapturePre("screen.bmp")\n注意，要开启此函数，必须先调用EnableDisplayDebug\n 任何图色或者文字识别函数，都可以通过这个来截取. 具体可以查看常见问题中"本机文字识别正常,别的机器为何不正常"这一节.
CmpColor(x,y,color,sim) = 比较指定坐标点(x,y)的颜色\n参数定义:\nx 整形数: X坐标\ny 整形数: Y坐标\ncolor 字符串: 颜色字符串,可以支持偏色,多色,例如 "ffffff-202020|000000-000000" 这个表示白色偏色为202020,和黑色偏色为000000.颜色最多支持10种颜色组合. 注意，这里只支持RGB颜色.\nsim 双精度浮点数: 相似度(0.1-1.0)\n返回值:\n整形数:\n 0: 颜色匹配\n 1: 颜色不匹配\n示例:\ndm_ret = dm.CmpColor(200,300,"000000-000000|ff00ff-101010",0.9)\n If dm_ret = 0 Then\n     MessageBox "相等" \n End If 
EnableDisplayDebug(enable_debug) = 开启图色调试模式，此模式会稍许降低图色和文字识别的速度.默认不开启.\n参数定义:\n enable_debug 整形数: 0 为关闭\n               1 为开启\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.EnableDisplayDebug 1\n dm_ret = dm.CapturePre("screen.bmp")
EnableGetColorByCapture(enable) = 允许调用GetColor GetColorBGR GetColorHSV 以及 CmpColor时，以截图的方式来获取颜色。\n参数定义:\nenable 整形数: 0 关闭\n         1 打开\n返回值:\n整形数:\n 0 : 失败\n 1 : 成功\n示例:\n dm.EnableGetColorByCapture 1\n TracePrint dm.GetColor(300,300)\n注 : 某些窗口上，可能GetColor会获取不到颜色，可以尝试此接口.
FindColor(x1, y1, x2, y2, color, sim, dir,intX,intY) = 查找指定区域内的颜色,颜色格式"RRGGBB-DRDGDB",注意,和按键的颜色格式相反\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n color 字符串:颜色 格式为"RRGGBB-DRDGDB",比如"123456-000000|aabbcc-202020".注意，这里只支持RGB颜色.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 \n              1: 从左到右,从下到上 \n              2: 从右到左,从上到下 \n              3: 从右到左,从下到上 \n              4：从中心往外查找\n              5: 从上到下,从左到右 \n              6: 从上到下,从右到左\n              7: 从下到上,从左到右\n              8: 从下到上,从右到左\n intX 变参指针:返回X坐标\n intY 变参指针:返回Y坐标\n 返回值: \n整形数:\n 0:没找到\n 1:找到\n示例:\n dm_ret = dm.FindColor(0,0,2000,2000,"123456-000000|aabbcc-030303|ddeeff-202020",1.0,0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n     MessageBox "找到"\n End If
FindColorE(x1, y1, x2, y2, color, sim, dir) = 查找指定区域内的颜色,颜色格式"RRGGBB-DRDGDB",注意,和按键的颜色格式相反\n易语言用不了FindColor可以用此接口来代替\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n color 字符串:颜色 格式为"RRGGBB-DRDGDB",比如"123456-000000|aabbcc-202020".注意，这里只支持RGB颜色.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 \n              1: 从左到右,从下到上 \n              2: 从右到左,从上到下 \n              3: 从右到左,从下到上 \n              4：从中心往外查找\n              5: 从上到下,从左到右 \n              6: 从上到下,从右到左\n              7: 从下到上,从左到右\n              8: 从下到上,从右到左\n 返回值: \n字符串:\n 返回X和Y坐标 形式如"x|y", 比如"100|200"\n示例:\n pos = dm.FindColorE(0,0,2000,2000,"123456-000000|aabbcc-030303|ddeeff-202020",1.0,0)\n pos = split(pos,"|")\n If int(pos(0)) > 0 Then\n     MessageBox "找到"\n End If
FindColorEx(x1, y1, x2, y2, color, sim, dir) = 查找指定区域内的所有颜色,颜色格式"RRGGBB-DRDGDB",注意,和按键的颜色格式相反\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n color 字符串:颜色 格式为"RRGGBB-DRDGDB" 比如"aabbcc-000000|123456-202020".注意，这里只支持RGB颜色.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 \n              1: 从左到右,从下到上 \n              2: 从右到左,从上到下 \n              3: 从右到左,从下到上 \n              5: 从上到下,从左到右 \n              6: 从上到下,从右到左\n              7: 从下到上,从左到右\n              8: 从下到上,从右到左  \n 返回值: \n字符串:\n 返回所有颜色信息的坐标值,然后通过GetResultCount等接口来解析 (由于内存限制,返回的颜色数量最多为1800个左右)\n示例:\n s = dm.FindColorEx(0,0,2000,2000,"123456-000000|abcdef-202020",1.0,0)\n count = dm.GetResultCount(s)\n index = 0\n Do While index < count\n     dm_ret = dm.GetResultPos(s,index,intX,intY)\n     MessageBox intX&","&intY \n     index = index + 1 \n Loop 
FindMulColor(x1, y1, x2, y2, color, sim) = 查找指定区域内的所有颜色.   <收费功能，具体详情点击查看>\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n color 字符串:颜色 格式为"RRGGBB-DRDGDB",比如"123456-000000|aabbcc-202020".注意，这里只支持RGB颜色.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n 返回值: \n整形数:\n 0:没找到或者部分颜色没找到\n 1:所有颜色都找到\n示例:\n dm_ret = dm.FindMulColor(0,0,2000,2000,"123456-000000|aabbcc-030303|ddeeff-202020",1.0)\n if dm_ret = 1 then\n      MessageBox "找到了"\n end if
FindMultiColor(x1, y1, x2, y2,first_color,offset_color,sim, dir,intX,intY) = 根据指定的多点查找颜色坐标\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n first_color 字符串:颜色 格式为"RRGGBB-DRDGDB",比如"123456-000000"\n 这里的含义和按键自带Color插件的意义相同，只不过我的可以支持偏色\n 所有的偏移色坐标都相对于此颜色.注意，这里只支持RGB颜色.\n offset_color 字符串: 偏移颜色 可以支持任意多个点 格式和按键自带的Color插件意义相同\n  格式为"x1|y1|RRGGBB-DRDGDB,……xn|yn|RRGGBB-DRDGDB"\n 比如"1|3|aabbcc,-5|-3|123456-000000"等任意组合都可以，支持偏色\n 还可以支持反色模式，比如"1|3|-aabbcc,-5|-3|-123456-000000","-"表示除了指定颜色之外的颜色.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 1: 从左到右,从下到上 2: 从右到左,从上到下 3: 从右到左, 从下到上\n intX 变参指针:返回X坐标(坐标为first_color所在坐标)\n intY 变参指针:返回Y坐标(坐标为first_color所在坐标)\n 返回值: \n整形数:\n 0:没找到\n 1:找到\n示例:\n dm_ret = dm.FindMultiColor(0,0,2000,2000,"cc805b-020202","9|2|-00ff00,15|2|2dff1c-010101,6|11|a0d962,11|14|-ffffff",1.0,1,intX,intY)\n dm.MoveTo intX,intY
FindMultiColorE(x1, y1, x2, y2,first_color,offset_color,sim, dir) = 根据指定的多点查找颜色坐标\n易语言用不了FindMultiColor可以用此接口来代替\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n first_color 字符串:颜色 格式为"RRGGBB-DRDGDB",比如"123456-000000"\n 这里的含义和按键自带Color插件的意义相同，只不过我的可以支持偏色\n 所有的偏移色坐标都相对于此颜色.注意，这里只支持RGB颜色.\n offset_color 字符串: 偏移颜色 可以支持任意多个点 格式和按键自带的Color插件意义相同\n  格式为"x1|y1|RRGGBB-DRDGDB,……xn|yn|RRGGBB-DRDGDB"\n 比如"1|3|aabbcc,-5|-3|123456-000000"等任意组合都可以，支持偏色\n 还可以支持反色模式，比如"1|3|-aabbcc,-5|-3|-123456-000000","-"表示除了指定颜色之外的颜色.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 1: 从左到右,从下到上 2: 从右到左,从上到下 3: 从右到左, 从下到上  \n 返回值: \n字符串:\n 返回X和Y坐标 形式如"x|y", 比如"100|200"\n示例:\n pos = dm.FindMultiColorE(0,0,2000,2000,"cc805b-020202","9|2|-00ff00,15|2|-2dff1c-010101,6|11|a0d962,11|14|-ffffff",1.0,1)\n pos = split(pos,"|")\n dm.MoveTo int(pos(0)),int(pos(1))
FindMultiColorEx(x1, y1, x2, y2,first_color,offset_color,sim, dir) = 根据指定的多点查找所有颜色坐标\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n first_color 字符串:颜色 格式为"RRGGBB-DRDGDB",比如"123456-000000"\n 这里的含义和按键自带Color插件的意义相同，只不过我的可以支持偏色\n 所有的偏移色坐标都相对于此颜色.注意，这里只支持RGB颜色.\n offset_color 字符串: 偏移颜色 可以支持任意多个点 格式和按键自带的Color插件意义相同\n  格式为"x1|y1|RRGGBB-DRDGDB,……xn|yn|RRGGBB-DRDGDB"\n 比如"1|3|aabbcc,-5|-3|123456-000000"等任意组合都可以，支持偏色\n 还可以支持反色模式，比如"1|3|-aabbcc,-5|-3|-123456-000000","-"表示除了指定颜色之外的颜色\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 1: 从左到右,从下到上 2: 从右到左,从上到下 3: 从右到左, 从下到上  \n 返回值: \n字符串:\n 返回所有颜色信息的坐标值,然后通过GetResultCount等接口来解析(由于内存限制,返回的坐标数量最多为1800个左右)\n坐标是first_color所在的坐标\n示例:\n dm_ret = dm.FindMultiColorEx(0,0,2000,2000,"cc805b-020202","9|2|-00ff00,15|2|2dff1c-010101,6|11|a0d962,11|14|-ffffff",1.0,1)\n count = dm.GetResultCount(dm_ret)\n index = 0\n Do While index < count \n    aa = dm.GetResultPos(dm_ret,index,intX,intY)\n    dm.MoveTo intX,intY\n    index = index + 1\n    Delay  1000\n Loop
FindPic(x1, y1, x2, y2, pic_name, delta_color,sim, dir,intX, intY) = 查找指定区域内的图片,位图必须是24位色格式,支持透明色,当图像上下左右4个顶点的颜色一样时,则这个颜色将作为透明色处理.\n这个函数可以查找多个图片,只返回第一个找到的X Y坐标.\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n pic_name 字符串:图片名,可以是多个图片,比如"test.bmp|test2.bmp|test3.bmp"\n delta_color 字符串:颜色色偏 比如"203040" 表示RGB的色偏分别是20 30 40 (这里是16进制表示)\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 1: 从左到右,从下到上 2: 从右到左,从上到下 3: 从右到左, 从下到上\n intX 变参指针:返回图片左上角的X坐标\n intY 变参指针:返回图片左上角的Y坐标\n返回值:\n整形数:\n 返回找到的图片的序号,从0开始索引.如果没找到返回-1\n示例:\n dm_ret = dm.FindPic(0,0,2000,2000,"1.bmp|2.bmp|3.bmp","000000",0.9,0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n     MessageBox "找到"\n End If
FindPicE(x1, y1, x2, y2, pic_name, delta_color,sim, dir) = 查找指定区域内的图片,位图必须是24位色格式,支持透明色,当图像上下左右4个顶点的颜色一样时,则这个颜色将作为透明色处理.\n这个函数可以查找多个图片,只返回第一个找到的X Y坐标.\n易语言用不了FindPic可以用此接口来代替\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n pic_name 字符串:图片名,可以是多个图片,比如"test.bmp|test2.bmp|test3.bmp"\n delta_color 字符串:颜色色偏 比如"203040" 表示RGB的色偏分别是20 30 40 (这里是16进制表示)\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 1: 从左到右,从下到上 2: 从右到左,从上到下 3: 从右到左, 从下到上\n返回值:\n 字符串:\n 返回找到的图片序号(从0开始索引)以及X和Y坐标 形式如"index|x|y", 比如"3|100|200"\n示例:\n pos = dm.FindPicE(0,0,2000,2000,"1.bmp|2.bmp|3.bmp","000000",0.9,0)\n pos = split(pos,"|")\n If int(pos(1)) > 0 Then\n     MessageBox "找到"\n End If
FindPicEx(x1, y1, x2, y2, pic_name, delta_color,sim, dir) = 查找指定区域内的图片,位图必须是24位色格式,支持透明色,当图像上下左右4个顶点的颜色一样时,则这个颜色将作为透明色处理.\n这个函数可以查找多个图片,并且返回所有找到的图像的坐标.\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n pic_name 字符串:图片名,可以是多个图片,比如"test.bmp|test2.bmp|test3.bmp"\n delta_color 字符串:颜色色偏 比如"203040" 表示RGB的色偏分别是20 30 40 (这里是16进制表示)\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 1: 从左到右,从下到上 2: 从右到左,从上到下 3: 从右到左, 从下到上\n返回值:\n字符串:\n 返回的是所有找到的坐标格式如下:"id,x,y|id,x,y..|id,x,y" (图片左上角的坐标)\n比如"0,100,20|2,30,40" 表示找到了两个,第一个,对应的图片是图像序号为0的图片,坐标是(100,20),第二个是序号为2的图片,坐标(30,40)\n (由于内存限制,返回的图片数量最多为1500个左右)\n示例:\n dm_ret = dm.FindPicEx(0,0,2000,2000,"test.bmp|test2.bmp|test3.bmp|test4.bmp|test5.bmp","020202",1.0,0)\n If len(dm_ret) > 0 Then\n    ss = split(dm_ret,"|")\n    index = 0\n    count = UBound(ss) + 1\n    Do While index < count\n       TracePrint ss(index)\n       sss = split(ss(index),",")\n       id = int(sss(0))\n       x = int(sss(1))\n       y = int(sss(2))\n       dm.MoveTo x,y\n       Delay 1000\n       index = index+1\n    Loop\n End If
FindPicExS(x1, y1, x2, y2, pic_name, delta_color,sim, dir) = 查找指定区域内的图片,位图必须是24位色格式,支持透明色,当图像上下左右4个顶点的颜色一样时,则这个颜色将作为透明色处理.\n这个函数可以查找多个图片,并且返回所有找到的图像的坐标. 此函数同FindPicEx.只是返回值不同. <收费功能，具体详情点击查看>\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n pic_name 字符串:图片名,可以是多个图片,比如"test.bmp|test2.bmp|test3.bmp"\n delta_color 字符串:颜色色偏 比如"203040" 表示RGB的色偏分别是20 30 40 (这里是16进制表示)\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 1: 从左到右,从下到上 2: 从右到左,从上到下 3: 从右到左, 从下到上\n返回值:\n字符串:\n 返回的是所有找到的坐标格式如下:"file,x,y| file,x,y..| file,x,y" (图片左上角的坐标)\n比如"1.bmp,100,20|2.bmp,30,40" 表示找到了两个,第一个,对应的图片是1.bmp,坐标是(100,20),第二个是2.bmp,坐标(30,40)\n (由于内存限制,返回的图片数量最多为1500个左右)\n示例:\n dm_ret = dm.FindPicExS(0,0,2000,2000,"test.bmp|test2.bmp|test3.bmp|test4.bmp|test5.bmp","020202",1.0,0)\n If len(dm_ret) > 0 Then\n    ss = split(dm_ret,"|")\n    index = 0\n    count = UBound(ss) + 1\n    Do While index < count\n       TracePrint ss(index)\n       sss = split(ss(index),",")\n       f = sss(0)\n       x = int(sss(1))\n       y = int(sss(2))\n       dm.MoveTo x,y\n       Delay 1000\n       index = index+1\n    Loop\n End If
FindPicMem(x1, y1, x2, y2, pic_info, delta_color,sim, dir,intX, intY) = 查找指定区域内的图片,位图必须是24位色格式,支持透明色,当图像上下左右4个顶点的颜色一样时,则这个颜色将作为透明色处理.\n这个函数可以查找多个图片,只返回第一个找到的X Y坐标. 这个函数要求图片是数据地址.   <收费功能，具体详情点击查看>\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n pic_info 字符串: 图片数据地址集合. 格式为"地址1,长度1|地址2,长度2.....|地址n,长度n". 可以用AppendPicAddr来组合. \n           地址表示24位位图资源在内存中的首地址，用十进制的数值表示\n           长度表示位图资源在内存中的长度，用十进制数值表示.\n delta_color 字符串:颜色色偏 比如"203040" 表示RGB的色偏分别是20 30 40 (这里是16进制表示)\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 1: 从左到右,从下到上 2: 从右到左,从上到下 3: 从右到左, 从下到上\n intX 变参指针:返回图片左上角的X坐标\n intY 变参指针:返回图片左上角的Y坐标\n返回值:\n整形数:\n 返回找到的图片的序号,从0开始索引.如果没找到返回-1\n示例:\npic_info = ""\n pic_info = dm.AppendPicAddr(pic_info,12034,643)\n pic_info = dm.AppendPicAddr(pic_info,328435,8935)\n pic_info = dm.AppendPicAddr(pic_info,809234,789)\n dm_ret = dm.FindPicMem(0,0,2000,2000, pic_info,"000000",0.9,0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n     MessageBox "找到"\n End If\n注 : 内存中的图片格式必须是24位色，并且不能加密.
FindPicMemE(x1, y1, x2, y2, pic_info, delta_color,sim, dir) = 查找指定区域内的图片,位图必须是24位色格式,支持透明色,当图像上下左右4个顶点的颜色一样时,则这个颜色将作为透明色处理.\n这个函数可以查找多个图片,只返回第一个找到的X Y坐标. 这个函数要求图片是数据地址.   <收费功能，具体详情点击查看>\n 易语言用不了FindPicMem可以用此接口来代替\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n pic_info 字符串: 图片数据地址集合. 格式为"地址1,长度1|地址2,长度2.....|地址n,长度n". 可以用AppendPicAddr来组合. \n           地址表示24位位图资源在内存中的首地址，用十进制的数值表示\n           长度表示位图资源在内存中的长度，用十进制数值表示.\n delta_color 字符串:颜色色偏 比如"203040" 表示RGB的色偏分别是20 30 40 (这里是16进制表示)\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 1: 从左到右,从下到上 2: 从右到左,从上到下 3: 从右到左, 从下到上\n返回值:\n 字符串:\n 返回找到的图片序号(从0开始索引)以及X和Y坐标 形式如"index|x|y", 比如"3|100|200"\n示例:\npic_info = ""\n pic_info = dm.AppendPicAddr(pic_info,12034,643)\n pic_info = dm.AppendPicAddr(pic_info,328435,8935)\n pic_info = dm.AppendPicAddr(pic_info,809234,789)\n pos = dm.FindPicE(0,0,2000,2000, pic_info,"000000",0.9,0)\n pos = split(pos,"|")\n If int(pos(1)) > 0 Then\n     MessageBox "找到"\n End If\n注 : 内存中的图片格式必须是24位色，并且不能加密.
FindPicMemEx(x1, y1, x2, y2, pic_info, delta_color,sim, dir) = 查找指定区域内的图片,位图必须是24位色格式,支持透明色,当图像上下左右4个顶点的颜色一样时,则这个颜色将作为透明色处理.\n这个函数可以查找多个图片,并且返回所有找到的图像的坐标. 这个函数要求图片是数据地址.   <收费功能，具体详情点击查看>\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n pic_info 字符串: 图片数据地址集合. 格式为"地址1,长度1|地址2,长度2.....|地址n,长度n". 可以用AppendPicAddr来组合. \n           地址表示24位位图资源在内存中的首地址，用十进制的数值表示\n           长度表示位图资源在内存中的长度，用十进制数值表示.\n delta_color 字符串:颜色色偏 比如"203040" 表示RGB的色偏分别是20 30 40 (这里是16进制表示)\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 1: 从左到右,从下到上 2: 从右到左,从上到下 3: 从右到左, 从下到上\n返回值:\n字符串:\n 返回的是所有找到的坐标格式如下:"id,x,y|id,x,y..|id,x,y" (图片左上角的坐标)\n比如"0,100,20|2,30,40" 表示找到了两个,第一个,对应的图片是图像序号为0的图片,坐标是(100,20),第二个是序号为2的图片,坐标(30,40)\n (由于内存限制,返回的图片数量最多为1500个左右)\n示例:\npic_info = ""\n pic_info = dm.AppendPicAddr(pic_info,12034,643)\n pic_info = dm.AppendPicAddr(pic_info,328435,8935)\n pic_info = dm.AppendPicAddr(pic_info,809234,789)\n dm_ret = dm.FindPicMemEx(0,0,2000,2000, pic_info,"020202",1.0,0)\n If len(dm_ret) > 0 Then\n    ss = split(dm_ret,"|")\n    index = 0\n    count = UBound(ss) + 1\n    Do While index < count\n       TracePrint ss(index)\n       sss = split(ss(index),",")\n       id = int(sss(0))\n       x = int(sss(1))\n       y = int(sss(2))\n       dm.MoveTo x,y\n       Delay 1000\n       index = index+1\n    Loop\n End If\n注 : 内存中的图片格式必须是24位色，并且不能加密.
FindPicS(x1, y1, x2, y2, pic_name, delta_color,sim, dir,intX, intY) = 查找指定区域内的图片,位图必须是24位色格式,支持透明色,当图像上下左右4个顶点的颜色一样时,则这个颜色将作为透明色处理.\n这个函数可以查找多个图片,只返回第一个找到的X Y坐标. 此函数同FindPic.只是返回值不同. <收费功能，具体详情点击查看>\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n pic_name 字符串:图片名,可以是多个图片,比如"test.bmp|test2.bmp|test3.bmp"\n delta_color 字符串:颜色色偏 比如"203040" 表示RGB的色偏分别是20 30 40 (这里是16进制表示)\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 1: 从左到右,从下到上 2: 从右到左,从上到下 3: 从右到左, 从下到上\n intX 变参指针:返回图片左上角的X坐标\n intY 变参指针:返回图片左上角的Y坐标\n返回值:\n字符串:\n 返回找到的图片的文件名. 没找到返回长度为0的字符串.\n示例:\n dm_ret = dm.FindPicS(0,0,2000,2000,"1.bmp|2.bmp|3.bmp","000000",0.9,0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n     MessageBox "找到"&dm_ret\n End If
FindShape(x1, y1, x2, y2, offset_color,sim, dir,intX,intY) = 查找指定的形状. 形状的描述同按键的抓抓. 具体可以参考按键的抓抓. \n 和按键的语法不同，需要用大漠综合工具的颜色转换. <收费功能，具体详情点击查看>\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n offset_color 字符串: 坐标偏移描述 可以支持任意多个点 格式和按键自带的Color插件意义相同\n  格式为"x1|y1|e1,……xn|yn|en"\n 比如"1|3|1,-5|-3|0"等任意组合都可以\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 1: 从左到右,从下到上 2: 从右到左,从上到下 3: 从右到左, 从下到上\n intX 变参指针:返回X坐标(坐标为形状(0,0)所在坐标)\n intY 变参指针:返回Y坐标(坐标为形状(0,0)所在坐标)\n 返回值: \n整形数:\n 0:没找到\n 1:找到\n示例:\n dm_ret = dm.FindShape(0,0,2000,2000, "1|1|0,1|6|1,0|10|1,9|10|1,7|6|1,7|8|0,8|9|0,2|2|1,3|1|1",1.0,0,x,y)\n dm.MoveTo x,y
FindShapeE(x1, y1, x2, y2, offset_color,sim, dir) = 查找指定的形状. 形状的描述同按键的抓抓. 具体可以参考按键的抓抓. \n 和按键的语法不同，需要用大漠综合工具的颜色转换. <收费功能，具体详情点击查看>\n易语言用不了FindShape可以用此接口来代替\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n offset_color 字符串: 坐标偏移描述 可以支持任意多个点 格式和按键自带的Color插件意义相同\n  格式为"x1|y1|e1,……xn|yn|en"\n 比如"1|3|1,-5|-3|0"等任意组合都可以\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 1: 从左到右,从下到上 2: 从右到左,从上到下 3: 从右到左, 从下到上  \n 返回值: \n字符串:\n 返回X和Y坐标 形式如"x|y", 比如"100|200"\n示例:\n pos = dm.FindShapeE(0,0,2000,2000,"1|1|0,1|6|1,0|10|1,9|10|1,7|6|1,7|8|0,8|9|0,2|2|1,3|1|1",1.0,0)\n pos = split(pos,"|")\n dm.MoveTo int(pos(0)),int(pos(1))
FindShapeEx(x1, y1, x2, y2,offset_color,sim, dir) = 查找所有指定的形状的坐标. 形状的描述同按键的抓抓. 具体可以参考按键的抓抓. \n 和按键的语法不同，需要用大漠综合工具的颜色转换. <收费功能，具体详情点击查看>\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n offset_color 字符串: 坐标偏移描述 可以支持任意多个点 格式和按键自带的Color插件意义相同\n  格式为"x1|y1|e1,……xn|yn|en"\n 比如"1|3|1,-5|-3|0"等任意组合都可以\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 1: 从左到右,从下到上 2: 从右到左,从上到下 3: 从右到左, 从下到上  \n 返回值: \n字符串:\n 返回所有形状的坐标值,然后通过GetResultCount等接口来解析(由于内存限制,返回的坐标数量最多为1800个左右)\n示例:\n dm_ret = dm.FindShapeEx(0,0,2000,2000,"1|1|0,1|6|1,0|10|1,9|10|1,7|6|1,7|8|0,8|9|0,2|2|1,3|1|1",1.0,1)\n count = dm.GetResultCount(dm_ret)\n index = 0\n Do While index < count \n    aa = dm.GetResultPos(dm_ret,index,intX,intY)\n    dm.MoveTo intX,intY\n    index = index + 1\n    Delay  1000\n Loop
FreePic(pic_name) = 释放指定的图片,此函数不必要调用,除非你想节省内存.\n参数定义:\n pic_name 字符串: 文件名 比如"1.bmp|2.bmp|3.bmp" 等,可以使用通配符,比如\n          "*.bmp" 这个对应了所有的bmp文件\n          "a?c*.bmp" 这个代表了所有第一个字母是a 第三个字母是c 第二个字母任意的所有bmp文件\n          "abc???.bmp|1.bmp|aa??.bmp" 可以这样任意组合.\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n PutAttachment "c:\test","*.bmp"\n dm_ret = dm.SetPath("c:\test")\nall_pic = "1.bmp|2.bmp|3.bmp"\n dm_ret = dm.LoadPic(all_pic)\ndm_ret = dm.FreePic(all_pic)
GetAveHSV(x1,y1,x2,y2) = 获取范围(x1,y1,x2,y2)颜色的均值,返回格式"H.S.V"\n参数定义:\n x1 整形数: 左上角X\ny1 整形数: 左上角Y\nx2 整形数: 右下角X\ny2 整形数: 右下角Y\n返回值:\n字符串:\n 颜色字符串\n示例:\n color = dm.GetAveHSV(30,30,100,100)\n MessageBox color
GetAveRGB(x1,y1,x2,y2) = 获取范围(x1,y1,x2,y2)颜色的均值,返回格式"RRGGBB"\n参数定义:\n x1 整形数: 左上角X\ny1 整形数: 左上角Y\nx2 整形数: 右下角X\ny2 整形数: 右下角Y\n返回值:\n字符串:\n 颜色字符串\n示例:\n color = dm.GetAveRGB(30,30,100,100)\n MessageBox color
GetColor(x,y) = 获取(x,y)的颜色,颜色返回格式"RRGGBB",注意,和按键的颜色格式相反\n参数定义:\n x 整形数:X坐标\n y 整形数:Y坐标\n返回值:\n字符串:\n 颜色字符串(注意这里都是小写字符，和工具相匹配)\n示例:\n color = dm.GetColor(30,30)\n If color = "ffffff" Then\n      MessageBox "是白色"\n End If
GetColorBGR(x,y) = 获取(x,y)的颜色,颜色返回格式"BBGGRR"\n参数定义:\n x 整形数:X坐标\n y 整形数:Y坐标\n返回值:\n字符串:\n 颜色字符串(注意这里都是小写字符，和工具相匹配)\n示例:\n color = dm.GetColorBGR(30,30)\n If color = "0000ff" Then\n       MessageBox "是红色"\n End If
GetColorHSV(x,y) = 获取(x,y)的HSV颜色,颜色返回格式"H.S.V"\n参数定义:\n x 整形数:X坐标\n y 整形数:Y坐标\n返回值:\n字符串:\n 颜色字符串\n示例:\n color = dm.GetColorHSV(30,30)\n If color = "100.20.20" Then\n       MessageBox "ok"\n End If
GetColorNum(x1, y1, x2, y2, color, sim) = 获取指定区域的颜色数量,颜色格式"RRGGBB-DRDGDB",注意,和按键的颜色格式相反\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n color 字符串:颜色 格式为"RRGGBB-DRDGDB",比如"123456-000000|aabbcc-202020".注意，这里只支持RGB颜色.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n 返回值: \n整形数:\n 颜色数量\n示例:\n TracePrint dm.GetColorNum(0,0,2000,2000,"123456-000000|aabbcc-030303|ddeeff-202020",1.0)  
GetPicSize(pic_name) = 获取指定图片的尺寸，如果指定的图片已经被加入缓存，则从缓存中获取信息.\n 此接口也会把此图片加入缓存. \n参数定义:\n pic_name 字符串: 文件名 比如"1.bmp"\n返回值:\n字符串:\n 形式如 "w,h" 比如"30,20"\n示例:\n PutAttachment "c:\test","*.bmp"\n dm_ret = dm.SetPath("c:\test")\npic_size = dm.GetPicSize("1.bmp")\n pic_size = split(pic_size,",")\n w = int(pic_size(0))\n h = int(pic_size(1))\n Trace "宽度:"&w\n Trace "高度:"&h
GetScreenData(x1,y1,x2,y2) = 获取指定区域的图像,用二进制数据的方式返回,（不适合按键使用）方便二次开发.\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n返回值:\n整形数:\n 返回的是指定区域的二进制颜色数据地址,每个颜色是4个字节,表示方式为(00RRGGBB)\n示例:\n无示例,开发者都懂的。\n注意,调用完此接口后，返回的数据指针在当前dm对象销毁时，或者再次调用GetScreenData时，会自动释放.\n从2.1120版本之后，调用完此函数后，没必要再调用FreenScreenData了,插件会自动释放.
GetScreenDataBmp(x1,y1,x2,y2,data,size) = 获取指定区域的图像,用24位位图的数据格式返回,（不适合按键使用）方便二次开发. <收费功能，具体详情点击查看>\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n data 变参指针:返回图片的数据指针\n size 变参指针:返回图片的数据长度\n返回值:\n整形数:\n 0 : 失败\n 1 : 成功\n示例:\n以下是在E语言中的示例.\n.局部变量 data, 整数型\n.局部变量 size, 整数型\ndm.数值方法 (“GetScreenDataBmp”, 0, 0, 100, 200, data, size)\n图片框1.图片 ＝ 指针到字节集 (data, size)
ImageToBmp(pic_name,bmp_name) = 转换图片格式为24位BMP格式.\n参数定义:\npic_name 字符串: 要转换的图片名\n bmp_name 字符串: 要保存的BMP图片名 \n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm.ImageToBmp "1.png","1.bmp"\n dm.ImageToBmp "2.jpg","2.bmp"\n dm.ImageToBmp "3.gif","3.bmp"
IsDisplayDead(x1,y1,x2,y2,t) = 判断指定的区域，在指定的时间内(秒),图像数据是否一直不变.(卡屏).\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n t  整形数:需要等待的时间,单位是秒 \n返回值:\n整形数:\n 0 : 没有卡屏，图像数据在变化.\n 1 : 卡屏. 图像数据在指定的时间内一直没有变化.\n示例:\n TracePrint dm.IsDisplayDead(0,0,100,100,5)\n注:此函数的原理是不停的截取指定区域的图像，然后比较，如果改变就立刻返回0,否则等待直到指定的时间到达.
LoadPic(pic_name) = 预先加载指定的图片,这样在操作任何和图片相关的函数时,将省去了加载图片的时间。调用此函数后,没必要一定要调用FreePic,插件自己会自动释放.\n另外,此函数不是必须调用的,所有和图形相关的函数只要调用过一次，图片会自动加入缓存.\n如果想对一个已经加入缓存的图片进行修改，那么必须先用FreePic释放此图片在缓存中占用\n的内存，然后重新调用图片相关接口，就可以重新加载此图片. \n参数定义:\n pic_name 字符串: 文件名 比如"1.bmp|2.bmp|3.bmp" 等,可以使用通配符,比如\n          "*.bmp" 这个对应了所有的bmp文件\n          "a?c*.bmp" 这个代表了所有第一个字母是a 第三个字母是c 第二个字母任意的所有bmp文件\n          "abc???.bmp|1.bmp|aa??.bmp" 可以这样任意组合.\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n PutAttachment "c:\test","*.bmp"\n dm_ret = dm.SetPath("c:\test")\nall_pic = "abc???.bmp|1.bmp|aa??.bmp"\n dm_ret = dm.LoadPic(all_pic)
MatchPicName(pic_name) = 根据通配符获取文件集合. 方便用于FindPic和FindPicEx\n参数定义:\n pic_name 字符串: 文件名 比如"1.bmp|2.bmp|3.bmp" 等,可以使用通配符,比如\n          "*.bmp" 这个对应了所有的bmp文件\n          "a?c*.bmp" 这个代表了所有第一个字母是a 第三个字母是c 第二个字母任意的所有bmp文件\n          "abc???.bmp|1.bmp|aa??.bmp" 可以这样任意组合.\n返回值:\n字符串:\n 返回的是通配符对应的文件集合，每个图片以|分割\n示例:\n PutAttachment "c:\test","*.bmp"\n dm_ret = dm.SetPath("c:\test")\nall_pic = "abc*.bmp"\n pic_name = dm.MatchPicName(all_pic)\n// 比如c:\test目录下有abc001.bmp abc002.bmp abc003.bmp\n// 那么pic_name 的值为abc001.bmp|abc002.bmp|abc003.bmp
RGB2BGR(rgb_color) = 把RGB的颜色格式转换为BGR(按键格式)\n参数定义:\n rgb_color 字符串:rgb格式的颜色字符串\n返回值:\n字符串:\n BGR格式的字符串\n示例:\n bgr_color = dm.RGB2BGR(rgb_color)
SetPicPwd(pwd) = 设置图片密码，如果图片本身没有加密，那么此设置不影响不加密的图片，一样正常使用.\n参数定义:\n pwd 字符串: 图片密码\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm_ret = dm.SetPicPwd("123")\n注意,此函数必须在使用图片之前调用.
GetBasePath() = 获取注册在系统中的dm.dll的路径.\n参数定义:\n 返回值:\n字符串:\n 返回dm.dll所在路径\n示例:\n base_path = dm.GetBasePath()\n MessageBox base_path
GetDmCount() = 返回当前进程已经创建的dm对象个数.       <收费功能，具体详情点击查看>\n参数定义:\n返回值:\n整形数:\n 个数.\n示例:\n TracePrint dm.GetDmCount()
GetID() = 返回当前大漠对象的ID值，这个值对于每个对象是唯一存在的。可以用来判定两个大漠对象是否一致.\n参数定义:\n返回值:\n整形数:\n 当前对象的ID值.\n示例:\n TracePrint dm.GetID()
GetLastError() = 获取插件命令的最后错误\n参数定义:\n返回值:\n整形数:\n 返回值表示错误值。 0表示无错误.\n-1 : 表示你使用了绑定里的收费功能，但是没注册，无法使用.\n -2 : 使用模式0 2 4 6时出现，因为目标窗口有保护，或者目标窗口没有以管理员权限打开. 常见于win7以上系统.或者有安全软件拦截插件.解决办法: 关闭所有安全软件，并且关闭系统UAC,然后再重新尝试. 如果还不行就可以肯定是目标窗口有特殊保护. \n -3 : 使用模式0 2 4 6时出现，可能目标窗口有保护，也可能是异常错误.\n -4 : 使用模式1 3 5 7 101 103时出现，这是异常错误.\n -5 : 使用模式1 3 5 7 101 103时出现, 这个错误的解决办法就是关闭目标窗口，重新打开再绑定即可. 也可能是运行脚本的进程没有管理员权限. \n -6 -7 -9 : 使用模式1 3 5 7 101 103时出现,异常错误. 还有可能是安全软件的问题，比如360等。尝试卸载360.\n -8 -10 : 使用模式1 3 5 7 101 103时出现, 目标进程可能有保护,也可能是插件版本过老，试试新的或许可以解决.\n -11 : 使用模式1 3 5 7 101 103时出现, 目标进程有保护. 告诉我解决。\n -12 : 使用模式1 3 5 7 101 103时出现, 目标进程有保护. 告诉我解决。\n -13 : 使用模式1 3 5 7 101 103时出现, 目标进程有保护. 或者是因为上次的绑定没有解绑导致。 尝试在绑定前调用ForceUnBindWindow.\n -14 : 使用模式0 1 4 5时出现, 有可能目标机器兼容性不太好. 可以尝试其他模式. 比如2 3 6 7\n -16 : 可能使用了绑定模式 0 1 2 3 和 101，然后可能指定了一个子窗口.导致不支持.可以换模式4 5 6 7或者103来尝试. 另外也可以考虑使用父窗口或者顶级窗口.来避免这个错误。还有可能是目标窗口没有正常解绑 然后再次绑定的时候.\n -17 : 模式1 3 5 7 101 103时出现. 这个是异常错误. 告诉我解决.\n -18 : 句柄无效.\n -19 : 使用模式0 1 2 3 101时出现,说明你的系统不支持这几个模式. 可以尝试其他模式.\n示例:\nTracePrint dm.GetLastError()  \n注: 此函数必须紧跟上一句函数调用，中间任何的语句调用都会改变这个值.
GetPath() = 获取全局路径.(可用于调试)\n参数定义:\n返回值:\n字符串:\n 以字符串的形式返回当前设置的全局路径\n示例:\n path = dm.GetPath()\n MessageBox path
Reg(reg_code,ver_info) = 非简单游平台使用，调用此函数来注册，从而使用插件的高级功能.推荐使用此函数.\n参数定义:\n reg_code 字符串: 注册码. (从大漠插件后台获取)\nver_info 字符串: 版本附加信息. 可以在后台详细信息查看. 可以任意填写. 可留空. 长度不能超过10. 并且只能包含数字和字母以及小数点. 这个版本信息不是插件版本.\n返回值:\n整形数:\n -1 : 无法连接网络,(可能防火墙拦截,如果可以正常访问大漠插件网站，那就可以肯定是被防火墙拦截)\n -2 : 进程没有以管理员方式运行. (出现在win7 vista 2008.建议关闭uac)\n 0 : 失败 (未知错误)\n 1 : 成功\n 2 : 余额不足\n 3 : 绑定了本机器，但是账户余额不足50元.\n 4 : 注册码错误\n 5 : 你的机器或者IP在黑名单列表中或者不在白名单列表中.\n -8 : 版本附加信息长度超过了10\n -9 : 版本附加信息里包含了非法字母.\n 空 : 这是不可能返回空的，如果出现空，那肯定是当前使用的版本不对,老的插件里没这个函数导致返回为空.最好参考文档中的标准写法,判断插件版本号.\n示例:\n dm_ret = dm.Reg("abcdefg","")\n if dm_ret <> 1 then\n     MessageBox "注册失败,只能使用免费功能"\n end if\n 注: 简单游平台调用此函数，不会有任何效果. 也不会扣费.\n注册码在大漠插件后台可以查看.\n此函数每个进程调用一次即可，不需要每个DM对象都调用.\n必须保证此函数在创建完对象以后立即调用，尤其必须在绑定窗口之前调用，否则可能会出现异常.\n如果有多个进程操作同个窗口，必须保证每个进程要么都调用Reg,要么都不要调用Reg，以免出现异常.
RegEx(reg_code,ver_info,ip) = 非简单游平台使用，调用此函数来注册，从而使用插件的高级功能. 可以根据指定的IP列表来注册. 新手不建议使用!\n参数定义:\n reg_code 字符串: 注册码. (从大漠插件后台获取)\nver_info 字符串: 版本附加信息. 可以在后台详细信息查看.可留空. 长度不能超过10. 并且只能包含数字和字母以及小数点. 这个版本信息不是插件版本.\nip 字符串: 插件注册的ip地址.可以用|来组合,依次对ip中的地址进行注册，直到成功. ip地址列表在VIP群中获取.\n返回值:\n整形数:\n -1 : 无法连接网络,(可能防火墙拦截,如果可以正常访问大漠插件网站，那就可以肯定是被防火墙拦截)\n -2 : 进程没有以管理员方式运行. (出现在win7 vista 2008.建议关闭uac)\n 0 : 失败 (未知错误)\n 1 : 成功\n 2 : 余额不足\n 3 : 绑定了本机器，但是账户余额不足50元.\n 4 : 注册码错误\n 5 : 你的机器或者IP在黑名单列表中或者不在白名单列表中.\n -8 : 版本附加信息长度超过了10\n -9 : 版本附加信息里包含了非法字母.\n -10 : 非法的参数ip\n 空 : 这是不可能返回空的，如果出现空，那肯定是当前使用的版本不对,老的插件里没这个函数导致返回为空.最好参考文档中的标准写法,判断插件版本号.\n示例:\n// 严重注意,这个例子的IP只是示例，实际并无效。真实IP要去VIP群里获取.\n dm_ret = dm.RegEx("abcdefg","0001","123.45.4.6|78.79.26.3")\n if dm_ret <> 1 then\n     MessageBox "注册失败,只能使用免费功能"\n end if\n 注: 简单游平台调用此函数，不会有任何效果. 也不会扣费.\n注册码在大漠插件后台可以查看.\n此函数每个进程调用一次即可，不需要每个DM对象都调用.\n必须保证此函数在创建完对象以后立即调用，尤其必须在绑定窗口之前调用，否则可能会出现异常.\n如果有多个进程操作同个窗口，必须保证每个进程要么都调用RegEx,要么都不要调用RegEx，以免出现异常.
RegExNoMac(reg_code,ver_info,ip) = 非简单游平台使用，调用此函数来注册，从而使用插件的高级功能. 可以根据指定的IP列表来注册.新手不建议使用! 此函数同RegEx函数的不同在于,此函数用于注册的机器码是不带mac地址的.\n参数定义:\n reg_code 字符串: 注册码. (从大漠插件后台获取)\nver_info 字符串: 版本附加信息. 可以在后台详细信息查看.可留空. 长度不能超过10. 并且只能包含数字和字母以及小数点. 这个版本信息不是插件版本.\nip 字符串: 插件注册的ip地址.可以用|来组合,依次对ip中的地址进行注册，直到成功. ip地址列表在VIP群中获取.\n返回值:\n整形数:\n -1 : 无法连接网络,(可能防火墙拦截,如果可以正常访问大漠插件网站，那就可以肯定是被防火墙拦截)\n -2 : 进程没有以管理员方式运行. (出现在win7 vista 2008.建议关闭uac)\n 0 : 失败 (未知错误)\n 1 : 成功\n 2 : 余额不足\n 3 : 绑定了本机器，但是账户余额不足50元.\n 4 : 注册码错误\n 5 : 你的机器或者IP在黑名单列表中或者不在白名单列表中.\n -8 : 版本附加信息长度超过了10\n -9 : 版本附加信息里包含了非法字母.\n -10 : 非法的参数ip\n 空 : 这是不可能返回空的，如果出现空，那肯定是当前使用的版本不对,老的插件里没这个函数导致返回为空.最好参考文档中的标准写法,判断插件版本号.\n示例:\n// 严重注意,这个例子的IP只是示例，实际并无效。真实IP要去VIP群里获取.\n dm_ret = dm.RegExNoMac("abcdefg","0001","123.45.4.6|78.79.26.3")\n if dm_ret <> 1 then\n     MessageBox "注册失败,只能使用免费功能"\n end if\n 注: 简单游平台调用此函数，不会有任何效果. 也不会扣费.\n注册码在大漠插件后台可以查看.\n此函数每个进程调用一次即可，不需要每个DM对象都调用.\n必须保证此函数在创建完对象以后立即调用，尤其必须在绑定窗口之前调用，否则可能会出现异常.\n如果有多个进程操作同个窗口，必须保证每个进程要么都调用RegExNoMac,要么都不要调用RegExNoMac，以免出现异常.
RegNoMac(reg_code,ver_info) = 非简单游平台使用，调用此函数来注册，从而使用插件的高级功能.推荐使用此函数. 新手不建议使用! 此函数同Reg函数的不同在于,此函数用于注册的机器码是不带mac地址的.\n参数定义:\n reg_code 字符串: 注册码. (从大漠插件后台获取)\nver_info 字符串: 版本附加信息. 可以在后台详细信息查看. 可以任意填写. 可留空. 长度不能超过10. 并且只能包含数字和字母以及小数点. 这个版本信息不是插件版本.\n返回值:\n整形数:\n -1 : 无法连接网络,(可能防火墙拦截,如果可以正常访问大漠插件网站，那就可以肯定是被防火墙拦截)\n -2 : 进程没有以管理员方式运行. (出现在win7 vista 2008.建议关闭uac)\n 0 : 失败 (未知错误)\n 1 : 成功\n 2 : 余额不足\n 3 : 绑定了本机器，但是账户余额不足50元.\n 4 : 注册码错误\n 5 : 你的机器或者IP在黑名单列表中或者不在白名单列表中.\n -8 : 版本附加信息长度超过了10\n -9 : 版本附加信息里包含了非法字母.\n 空 : 这是不可能返回空的，如果出现空，那肯定是当前使用的版本不对,老的插件里没这个函数导致返回为空.最好参考文档中的标准写法,判断插件版本号.\n示例:\n dm_ret = dm.RegNoMac("abcdefg","")\n if dm_ret <> 1 then\n     MessageBox "注册失败,只能使用免费功能"\n end if\n 注: 简单游平台调用此函数，不会有任何效果. 也不会扣费.\n注册码在大漠插件后台可以查看.\n此函数每个进程调用一次即可，不需要每个DM对象都调用.\n必须保证此函数在创建完对象以后立即调用，尤其必须在绑定窗口之前调用，否则可能会出现异常.\n如果有多个进程操作同个窗口，必须保证每个进程要么都调用RegNoMac,要么都不要调用RegNoMac，以免出现异常.
SetDisplayInput(mode) =  设定图色的获取方式，默认是显示器或者后台窗口(具体参考BindWindow)\n参数定义:\n mode 字符串: 图色输入模式 取值有以下几种\n 1.     "screen" 这个是默认的模式，表示使用显示器或者后台窗口\n 2.     "pic:file" 指定输入模式为指定的图片,如果使用了这个模式，则所有和图色相关的函数\n 均视为对此图片进行处理，比如文字识别 查找图片 颜色 等等一切图色函数.\n 需要注意的是，设定以后，此图片就已经加入了缓冲，如果更改了源图片内容，那么需要\n 释放此缓冲，重新设置.\n返回值:\n整形数:\n 0: 失败\n1: 成功\n示例:\n // 设定为默认的模式\n dm_ret = dm.SetDisplayInput("screen")\n// 设定为图片模式 图片采用相对路径模式 相对于SetPath的路径\n dm_ret = dm.SetDisplayInput("pic:test.bmp")\n// 设为图片模式 图片采用绝对路径模式\n dm_ret = dm.SetDisplayInput("pic:d:\test\test.bmp")\n// 设为图片模式 但是每次设置前 先清除缓冲\n dm_ret = dm.FreePic("test.bmp")\n dm_ret = dm.SetDisplayInput("pic:test.bmp")  
SetEnumWindowDelay(delay) =  设置EnumWindow  EnumWindowByProcess  EnumWindowSuper的最长延时. 内部默认超时是5秒.   <收费功能，具体详情点击查看>\n参数定义:\n delay 整形数: 单位毫秒\n返回值:\n整形数:\n 0: 失败\n1: 成功\n示例:\n dm.SetEnumWindowDelay  300000  \n注: 有些时候，窗口过多，并且窗口结构过于复杂，可能枚举的时间过长. 那么需要调用这个函数来延长时间。避免漏掉窗口.
SetPath(path) = 设置全局路径,设置了此路径后,所有接口调用中,相关的文件都相对于此路径. 比如图片,字库等.\n参数定义:\n path 字符串: 路径,可以是相对路径,也可以是绝对路径\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n // 以下代码把全局路径设置到了c盘根目录\n dm_ret = dm.SetPath("c:\")\n// 如下是把全局路径设置到了相对于当前exe所在的路径\n dm.SetPath ".\MyData"\n // 以上，如果exe在c:\test\a.exe 那么，就相当于把路径设置到了c:\test\MyData
SetShowErrorMsg (show) = 设置是否弹出错误信息,默认是打开.\n参数定义:\nshow 整形数: 0表示不打开,1表示打开\n 返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.SetShowErrorMsg(0)  
Ver() = 返回当前插件版本号\n参数定义:\n返回值:\n字符串:\n 当前插件的版本描述字符串\n示例:\n // 返回版本号\n ver = dm.Ver()\n MessageBox ver
CopyFile(src_file,dst_file,over) = 拷贝文件. \n参数定义:\nsrc_file 字符串: 原始文件名\ndst_file 字符串: 目标文件名.\nover整形数: 取值如下,\n             0 : 如果dst_file文件存在则不覆盖返回.\n             1 : 如果dst_file文件存在则覆盖.\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n // 绝对路径\n dm.CopyFile "c:\123.txt","d:\456.txt",1\n // 相对路径\n dm.SetPath "c:\test_game"\n dm.CopyFile "123.txt","456.txt",1
CreateFolder(folder) = 创建指定目录. \n参数定义:\nfolder 字符串: 目录名\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n dm.CreateFolder "c:\123\456\789"
DecodeFile(file,pwd) = 解密指定的文件.  <收费功能，具体详情点击查看>\n参数定义:\nfile 字符串: 文件名.\npwd 字符串: 密码.\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n // 绝对路径\n dm.DecodeFile "c:\test_game\cfg.ini","1234"\n // 相对路径\n dm.SetPath "c:\test_game"\n dm.DecodeFile "1.bmp","1234"\n如果此文件没加密，调用此函数不会有任何效果.\n 插件所有的字库 图片 ini都是用此接口来解密.
DeleteFile(file) = 删除文件. \n参数定义:\nfile 字符串: 文件名\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n // 绝对路径\n dm.DeleteFile "c:\123.txt"\n // 相对路径\n dm.SetPath "c:\test_game"\n dm.DeleteFile "123.txt"
DeleteFolder(folder) = 删除指定目录. \n参数定义:\nfolder 字符串: 目录名\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n dm.DeleteFolder "c:\123"
DeleteIni(section,key,file) = 删除指定的ini小节.  \n参数定义:\nsection 字符串: 小节名\nkey 字符串: 变量名. 如果这个变量为空串，则删除整个section小节.\nfile 字符串: ini文件名.\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n // 绝对路径\n dm.DeleteIni "Global","var1" ,"c:\test_game\cfg.ini"\n // 相对路径\n dm.SetPath "c:\test_game"\n dm.DeleteIni "Global","" ,"cfg.ini"\n注 : 此函数是多线程安全的. 多线程同时读写同个文件不会造成文件错乱.
DeleteIniPwd(section,key,file,pwd) = 删除指定的ini小节.支持加密文件  <收费功能，具体详情点击查看>\n参数定义:\nsection 字符串: 小节名\nkey 字符串: 变量名. 如果这个变量为空串，则删除整个section小节.\nfile 字符串: ini文件名.\npwd 字符串: 密码.\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n // 绝对路径\n dm.DeleteIniPwd "Global","var1","c:\test_game\cfg.ini","1234"\n // 相对路径\n dm.SetPath "c:\test_game"\n dm.DeleteIniPwd "Global","","cfg.ini","1234"\n注 : 此函数是多线程安全的. 多线程同时读写同个文件不会造成文件错乱.\n如果此文件没加密，调用此函数会自动加密.
DownloadFile(url,save_file,timeout) = 从internet上下载一个文件. \n参数定义:\nurl 字符串: 下载的url地址.\nsave_file 字符串: 要保存的文件名.\ntimeout整形数: 连接超时时间，单位是毫秒.\n返回值:\n 整形数:\n 1 : 成功\n -1 : 网络连接失败\n -2 : 写入文件失败\n示例:\n dm.DownloadFile "www.sohu.com","sohu.html",3000\ndm.DownloadFile "http://www.sohu.com","d:\sohu.html",3000
EncodeFile(file,pwd) = 加密指定的文件.  <收费功能，具体详情点击查看>\n参数定义:\nfile 字符串: 文件名.\npwd 字符串: 密码.\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n // 绝对路径\n dm.EncodeFile "c:\test_game\cfg.ini","1234"\n // 相对路径\n dm.SetPath "c:\test_game"\n dm.EncodeFile "1.bmp","1234"\n如果此文件已经加密，调用此函数不会有任何效果.\n 插件所有的字库 图片 ini都是用此接口来加密.
GetFileLength(file) = 获取指定的文件长度. \n参数定义:\nfile 字符串: 文件名\n返回值:\n 整形数:\n 文件长度(字节数)\n示例:\n // 绝对路径\n TracePrint dm.GetFileLength("c:\123.txt")\n // 相对路径\n dm.SetPath "c:\test_game"\n TracePrint dm.GetFileLength("123.txt")
IsFileExist(file) = 判断指定文件是否存在. \n参数定义:\nfile 字符串: 文件名\n返回值:\n 整形数:\n 0 : 不存在\n 1 : 存在\n示例:\n // 绝对路径\n TracePrint dm.IsFileExist("c:\123.txt")\n // 相对路径\n dm.SetPath "c:\test_game"\n TracePrint dm.IsFileExist("123.txt")
MoveFile(src_file,dst_file) = 移动文件. \n参数定义:\nsrc_file 字符串: 原始文件名\ndst_file 字符串: 目标文件名.\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n // 绝对路径\n dm.MoveFile "c:\123.txt","d:\456.txt"\n // 相对路径\n dm.SetPath "c:\test_game"\n dm.MoveFile "123.txt","456.txt"
ReadFile(file) = 从指定的文件读取内容. \n参数定义:\nfile 字符串: 文件\n返回值:\n 字符串:\n 读入的文件内容\n示例:\n // 绝对路径\n TracePrint dm.ReadFile("c:\123.txt")\n // 相对路径\n dm.SetPath "c:\test_game"\n TracePrint dm.ReadFile("123.txt")
ReadIni(section,key,file) = 从Ini中读取指定信息. \n参数定义:\nsection 字符串: 小节名\nkey 字符串: 变量名.\nfile 字符串: ini文件名.\n返回值:\n 字符串:\n 字符串形式表达的读取到的内容\n示例:\n // 绝对路径\n Text = dm.ReadIni("Global","var1","c:\test_game\cfg.ini")\n // 相对路径\n dm.SetPath "c:\test_game"\n Text = dm.ReadIni("Global","var1","cfg.ini")\n注 : 此函数是多线程安全的. 多线程同时读写同个文件不会造成文件错乱.
ReadIniPwd(section,key,file,pwd) = 从Ini中读取指定信息.可支持加密文件       <收费功能，具体详情点击查看>\n参数定义:\nsection 字符串: 小节名\nkey 字符串: 变量名.\nfile 字符串: ini文件名.\npwd 字符串: 密码\n返回值:\n 字符串:\n 字符串形式表达的读取到的内容\n示例:\n // 绝对路径\n Text = dm.ReadIniPwd("Global","var1","c:\test_game\cfg.ini","1234")\n // 相对路径\n dm.SetPath "c:\test_game"\n Text = dm.ReadIniPwd("Global","var1","cfg.ini","1234")\n注 : 此函数是多线程安全的. 多线程同时读写同个文件不会造成文件错乱.\n如果文件没加密，也可以正常读取.
SelectDirectory() = 弹出选择文件夹对话框，并返回选择的文件夹.\n参数定义:\n返回值:\n 字符串:\n 选择的文件夹全路径\n示例:\nTracePrint dm.SelectDirectory()
SelectFile() = 弹出选择文件对话框，并返回选择的文件.\n参数定义:\n返回值:\n 字符串:\n 选择的文件全路径\n示例:\nTracePrint dm.SelectFile()
WriteFile(file,content) = 向指定文件追加字符串. \n参数定义:\nfile 字符串: 文件\ncontent 字符串: 写入的字符串.\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n // 绝对路径\n dm.WriteFile "c:\123.txt","哈哈哈"\n // 相对路径\n dm.SetPath "c:\test_game"\n dm.WriteFile "123.txt","哈哈哈"
WriteIni(section,key,value,file) = 向指定的Ini写入信息.  \n参数定义:\nsection 字符串: 小节名\nkey 字符串: 变量名.\nvalue 字符串: 变量内容\nfile 字符串: ini文件名.\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n // 绝对路径\n dm.WriteIni "Global","var1","123","c:\test_game\cfg.ini"\n // 相对路径\n dm.SetPath "c:\test_game"\n dm.WriteIni "Global","var1","123","cfg.ini"\n注 : 此函数是多线程安全的. 多线程同时读写同个文件不会造成文件错乱.
WriteIniPwd(section,key,value,file,pwd) = 向指定的Ini写入信息.支持加密文件  <收费功能，具体详情点击查看>\n参数定义:\nsection 字符串: 小节名\nkey 字符串: 变量名.\nvalue 字符串: 变量内容\nfile 字符串: ini文件名.\npwd 字符串: 密码.\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n // 绝对路径\n dm.WriteIniPwd "Global","var1","123","c:\test_game\cfg.ini","1234"\n // 相对路径\n dm.SetPath "c:\test_game"\n dm.WriteIniPwd "Global","var1","123","cfg.ini","1234"\n注 : 此函数是多线程安全的. 多线程同时读写同个文件不会造成文件错乱.\n如果此文件没加密，调用此函数会自动加密.
AddDict(index,dict_info) = 给指定的字库中添加一条字库信息.\n参数定义:\nindex 整形数:字库的序号,取值为0-9,目前最多支持10个字库\n dict_info 字符串:字库描述串，具体参考大漠综合工具中的字符定义\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.AddDict(0,"081101BF8020089FD10A21443F85038$记$0.0$11")  \n注意: 此函数尽量在小字库中使用，大字库中使用AddDict速度比较慢\n另，此函数是向指定的字库所在的内存中添加,而不是往文件中添加. 添加以后立刻就可以用于文字识别。无须再SetDict\n如果要保存添加进去的字库信息，需要调用SaveDict
ClearDict(index) = 清空指定的字库.\n参数定义:\nindex 整形数:字库的序号,取值为0-9,目前最多支持10个字库\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.ClearDict 0\n注意: 此函数尽量在小字库中使用，大字库中使用AddDict速度比较慢\n另外，此函数支持清空内存中的字库，而不是字库文件本身.
FetchWord(x1, y1, x2, y2, color, word) = 根据指定的范围,以及指定的颜色描述，提取点阵信息，类似于大漠工具里的单独提取.\n参数定义:\n x1 整形数:左上角X坐标\ny1 整形数:左上角Y坐标\nx2 整形数:右下角X坐标\ny2 整形数:右下角Y坐标\ncolor 字符串: 颜色格式串.注意，RGB和HSV格式都支持.\nword 字符串: 待定义的文字,不能为空，且不能为关键符号"$"\n返回值:\n字符串:\n 识别到的点阵信息，可用于AddDict\n 如果失败，返回空\n示例:\n info = dm.FetchWord(200,200,250,220,"abcdef-101010|ffffff-101010","张三")\n If len(info) > 0 Then\n     dm.AddDict 3,info\n End if\ninfo = dm.FetchWord(200,200,250,220,"b@abcdef-101010|ffffff-101010","李四")\n If len(info) > 0 Then\n     dm.AddDict 2,info\n End if\ninfo = dm.FetchWord(200,200,250,220,"b@0.100.100-0.0.0","张三")\n If len(info) > 0 Then\n     dm.AddDict 4,info\n End if\ninfo = dm.FetchWord(200,200,250,220,"0.100.100-0.0.0|100.0.0-0.0.0","王")\n If len(info) > 0 Then\n     dm.AddDict 4,info\n End if
FindStr(x1,y1,x2,y2,string,color_format,sim,intX,intY) = 在屏幕范围(x1,y1,x2,y2)内,查找string(可以是任意个字符串的组合),并返回符合color_format的坐标位置,相似度sim同Ocr接口描述.\n(多色,差色查找类似于Ocr接口,不再重述)\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串,可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例 .注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n intX 变参指针:返回X坐标 没找到返回-1\n intY 变参指针:返回Y坐标 没找到返回-1\n返回值:\n整形数:\n 返回字符串的索引 没找到返回-1, 比如"长安|洛阳",若找到长安，则返回0\n示例:\n dm_ret = dm.FindStr(0,0,2000,2000,"长安","9f2e3f-000000",1.0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\ndm_ret = dm.FindStr(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",1.0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\n// 查找时,对多行文本进行换行,换行分隔符是"|". 语法是在","后增加换行字符串.任意字符串都可以.\n dm_ret = dm.FindStr(0,0,2000,2000,"长安|洛阳","9f2e3f-000000,|",1.0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\n注: 此函数的原理是先Ocr识别，然后再查找。所以速度比FindStrFast要慢，尤其是在字库\n 很大，或者模糊度不为1.0时。\n一般字库字符数量小于100左右，模糊度为1.0时，用FindStr要快一些,否则用FindStrFast.
FindStrE(x1,y1,x2,y2,string,color_format,sim) = 在屏幕范围(x1,y1,x2,y2)内,查找string(可以是任意个字符串的组合),并返回符合color_format的坐标位置,相似度sim同Ocr接口描述.\n(多色,差色查找类似于Ocr接口,不再重述)\n易语言用不了FindStr可以用此接口来代替\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串, 可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0  \n返回值:\n字符串:\n 返回字符串序号以及X和Y坐标,形式如"id|x|y", 比如"0|100|200",没找到时，id和X以及Y均为-1，"-1|-1|-1"\n示例:\n pos = dm.FindStrE(0,0,2000,2000,"长安","9f2e3f-000000",1.0)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\npos = dm.FindStrE(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",1.0)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\n// 查找时,对多行文本进行换行,换行分隔符是"|". 语法是在","后增加换行字符串.任意字符串都可以.\n pos = dm.FindStrE(0,0,2000,2000,"长安|洛阳","9f2e3f-000000,|",1.0)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\n注: 此函数的原理是先Ocr识别，然后再查找。所以速度比FindStrFastE要慢，尤其是在字库\n 很大，或者模糊度不为1.0时。\n一般字库字符数量小于100左右，模糊度为1.0时，用FindStrE要快一些,否则用FindStrFastE.
FindStrEx(x1,y1,x2,y2,string,color_format,sim) = 在屏幕范围(x1,y1,x2,y2)内,查找string(可以是任意字符串的组合),并返回符合color_format的所有坐标位置,相似度sim同Ocr接口描述.\n(多色,差色查找类似于Ocr接口,不再重述)\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串, 可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n返回值:\n字符串:\n 返回所有找到的坐标集合,格式如下:\n "id,x0,y0|id,x1,y1|......|id,xn,yn"\n 比如"0,100,20|2,30,40" 表示找到了两个,第一个,对应的是序号为0的字符串,坐标是(100,20),第二个是序号为2的字符串,坐标(30,40)\n 示例:\n dm_ret = dm.FindStrEx(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",1.0)\n If len(dm_ret) > 0 Then\n    ss = split(dm_ret,"|")\n    index = 0\n    count = UBound(ss) + 1\n    Do While index < count\n       TracePrint ss(index)\n       sss = split(ss(index),",")\n       id = int(sss(0))\n       x = int(sss(1))\n       y = int(sss(2))\n       dm.MoveTo x,y\n       Delay 1000\n       index = index+1\n    Loop\n End If  \n注: 此函数的原理是先Ocr识别，然后再查找。所以速度比FindStrExFast要慢，尤其是在字库\n 很大，或者模糊度不为1.0时。\n一般字库字符数量小于100左右，模糊度为1.0时，用FindStrEx要快一些,否则用FindStrFastEx.
FindStrExS(x1,y1,x2,y2,string,color_format,sim) = 在屏幕范围(x1,y1,x2,y2)内,查找string(可以是任意字符串的组合),并返回符合color_format的所有坐标位置,相似度sim同Ocr接口描述.\n(多色,差色查找类似于Ocr接口,不再重述). 此函数同FindStrEx,只是返回值不同. <收费功能，具体详情点击查看>\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串, 可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n返回值:\n字符串:\n 返回所有找到的坐标集合,格式如下:\n "str,x0,y0| str,x1,y1|......| str,xn,yn"\n 比如"长安,100,20|大雁塔,30,40" 表示找到了两个,第一个是长安 ,坐标是(100,20),第二个是大雁塔,坐标(30,40)\n 示例:\n dm_ret = dm.FindStrExS(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",1.0)\n If len(dm_ret) > 0 Then\n    ss = split(dm_ret,"|")\n    index = 0\n    count = UBound(ss) + 1\n    Do While index < count\n       TracePrint ss(index)\n       sss = split(ss(index),",")\n       str = sss(0)\n       x = int(sss(1))\n       y = int(sss(2))\n       dm.MoveTo x,y\n       Delay 1000\n       index = index+1\n    Loop\n End If  \n注: 此函数的原理是先Ocr识别，然后再查找。所以速度比FindStrExFastS要慢，尤其是在字库\n 很大，或者模糊度不为1.0时。\n一般字库字符数量小于100左右，模糊度为1.0时，用FindStrExS要快一些,否则用FindStrFastExS.
FindStrFast(x1,y1,x2,y2,string,color_format,sim,intX,intY) = 同FindStr。\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串,可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n intX 变参指针:返回X坐标 没找到返回-1\n intY 变参指针:返回Y坐标 没找到返回-1\n返回值:\n整形数:\n 返回字符串的索引 没找到返回-1, 比如"长安|洛阳",若找到长安，则返回0\n示例:\n dm_ret = dm.FindStrFast(0,0,2000,2000,"长安","9f2e3f-000000",1.0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\ndm_ret = dm.FindStrFast(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",0.9,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\n// 查找时,对多行文本进行换行,换行分隔符是"|". 语法是在","后增加换行字符串.任意字符串都可以.\n dm_ret = dm.FindStrFast(0,0,2000,2000,"长安|洛阳","9f2e3f-000000,|",0.9,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\n注: 此函数比FindStr要快很多，尤其是在字库很大时，或者模糊识别时，效果非常明显。\n 推荐使用此函数。\n 另外由于此函数是只识别待查找的字符，所以可能会有如下情况出现问题。\n比如 字库中有"张和三" 一共3个字符数据，然后待识别区域里是"张和三",如果用FindStr查找\n "张三"肯定是找不到的，但是用FindStrFast却可以找到，因为"和"这个字符没有列入查找计划中\n 所以，在使用此函数时，也要特别注意这一点。
FindStrFastE(x1,y1,x2,y2,string,color_format,sim) = 同FindStrE\n易语言用不了FindStrFast可以用此接口来代替\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串, 可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0  \n返回值:\n字符串:\n 返回字符串序号以及X和Y坐标,形式如"id|x|y", 比如"0|100|200",没找到时，id和X以及Y均为-1，"-1|-1|-1"\n示例:\n pos = dm.FindStrFastE(0,0,2000,2000,"长安","9f2e3f-000000",1.0)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\npos = dm.FindStrFastE(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",0.9)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\n// 查找时,对多行文本进行换行,换行分隔符是"|". 语法是在","后增加换行字符串.任意字符串都可以.\n pos = dm.FindStrFastE(0,0,2000,2000,"长安|洛阳","9f2e3f-000000,|",0.9)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\n注: 此函数比FindStrE要快很多，尤其是在字库很大时，或者模糊识别时，效果非常明显。\n 推荐使用此函数。\n另外由于此函数是只识别待查找的字符，所以可能会有如下情况出现问题。\n比如 字库中有"张和三" 一共3个字符数据，然后待识别区域里是"张和三",如果用FindStrE查找\n "张三"肯定是找不到的，但是用FindStrFastE却可以找到，因为"和"这个字符没有列入查找计划中\n 所以，在使用此函数时，也要特别注意这一点。
FindStrFastEx(x1,y1,x2,y2,string,color_format,sim) = 同FindStrEx\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串, 可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n返回值:\n字符串:\n 返回所有找到的坐标集合,格式如下:\n "id,x0,y0|id,x1,y1|......|id,xn,yn"\n 比如"0,100,20|2,30,40" 表示找到了两个,第一个,对应的是序号为0的字符串,坐标是(100,20),第二个是序号为2的字符串,坐标(30,40)\n 示例:\n dm_ret = dm.FindStrFastEx(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",0.9)\n If len(dm_ret) > 0 Then\n    ss = split(dm_ret,"|")\n    index = 0\n    count = UBound(ss) + 1\n    Do While index < count\n       TracePrint ss(index)\n       sss = split(ss(index),",")\n       id = int(sss(0))\n       x = int(sss(1))\n       y = int(sss(2))\n       dm.MoveTo x,y\n       Delay 1000\n       index = index+1\n    Loop\n End If  \n注: 此函数比FindStrEx要快很多，尤其是在字库很大时，或者模糊识别时，效果非常明显。\n 推荐使用此函数。\n另外由于此函数是只识别待查找的字符，所以可能会有如下情况出现问题。\n比如 字库中有"张和三" 一共3个字符数据，然后待识别区域里是"张和三",如果用FindStrEx查找\n "张三"肯定是找不到的，但是用FindStrFastEx却可以找到，因为"和"这个字符没有列入查找计划中\n 所以，在使用此函数时，也要特别注意这一点。
FindStrFastExS(x1,y1,x2,y2,string,color_format,sim) = 同FindStrExS.  <收费功能，具体详情点击查看>\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串, 可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例 .注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n返回值:\n字符串:\n 返回所有找到的坐标集合,格式如下:\n "str,x0,y0| str,x1,y1|......| str,xn,yn"\n 比如"长安,100,20|大雁塔,30,40" 表示找到了两个,第一个是长安 ,坐标是(100,20),第二个是大雁塔,坐标(30,40)\n 示例:\n dm_ret = dm.FindStrFastExS(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",0.9)\n If len(dm_ret) > 0 Then\n    ss = split(dm_ret,"|")\n    index = 0\n    count = UBound(ss) + 1\n    Do While index < count\n       TracePrint ss(index)\n       sss = split(ss(index),",")\n       str = sss(0)\n       x = int(sss(1))\n       y = int(sss(2))\n       dm.MoveTo x,y\n       Delay 1000\n       index = index+1\n    Loop\n End If  \n注: 此函数比FindStrExS要快很多，尤其是在字库很大时，或者模糊识别时，效果非常明显。\n 推荐使用此函数。\n另外由于此函数是只识别待查找的字符，所以可能会有如下情况出现问题。\n比如 字库中有"张和三" 一共3个字符数据，然后待识别区域里是"张和三",如果用FindStrExS查找\n "张三"肯定是找不到的，但是用FindStrFastExS却可以找到，因为"和"这个字符没有列入查找计划中\n 所以，在使用此函数时，也要特别注意这一点。
FindStrFastS(x1,y1,x2,y2,string,color_format,sim,intX,intY) = 同FindStrS.        <收费功能，具体详情点击查看>\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串,可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例 .注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n intX 变参指针:返回X坐标 没找到返回-1\n intY 变参指针:返回Y坐标 没找到返回-1\n返回值:\n字符串:\n 返回找到的字符串. 没找到的话返回长度为0的字符串.\n示例:\n dm_ret = dm.FindStrFastS(0,0,2000,2000,"长安","9f2e3f-000000",1.0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\ndm_ret = dm.FindStrFastS(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",0.9,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\n// 查找时,对多行文本进行换行,换行分隔符是"|". 语法是在","后增加换行字符串.任意字符串都可以.\n dm_ret = dm.FindStrFastS(0,0,2000,2000,"长安|洛阳","9f2e3f-000000,|",0.9,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\n注: 此函数比FindStrS要快很多，尤其是在字库很大时，或者模糊识别时，效果非常明显。\n 推荐使用此函数。\n 另外由于此函数是只识别待查找的字符，所以可能会有如下情况出现问题。\n比如 字库中有"张和三" 一共3个字符数据，然后待识别区域里是"张和三",如果用FindStrS查找\n "张三"肯定是找不到的，但是用FindStrFastS却可以找到，因为"和"这个字符没有列入查找计划中\n 所以，在使用此函数时，也要特别注意这一点。
FindStrS(x1,y1,x2,y2,string,color_format,sim,intX,intY) = 在屏幕范围(x1,y1,x2,y2)内,查找string(可以是任意个字符串的组合),并返回符合color_format的坐标位置,相似度sim同Ocr接口描述.\n(多色,差色查找类似于Ocr接口,不再重述).此函数同FindStr,只是返回值不同. <收费功能，具体详情点击查看>\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串,可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例 .注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n intX 变参指针:返回X坐标 没找到返回-1\n intY 变参指针:返回Y坐标 没找到返回-1\n返回值:\n字符串:\n 返回找到的字符串. 没找到的话返回长度为0的字符串.\n示例:\n dm_ret = dm.FindStrS(0,0,2000,2000,"长安","9f2e3f-000000",1.0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\ndm_ret = dm.FindStrS(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",1.0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\n// 查找时,对多行文本进行换行,换行分隔符是"|". 语法是在","后增加换行字符串.任意字符串都可以.\n dm_ret = dm.FindStrS(0,0,2000,2000,"长安|洛阳","9f2e3f-000000,|",1.0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\n注: 此函数的原理是先Ocr识别，然后再查找。所以速度比FindStrFastS要慢，尤其是在字库\n 很大，或者模糊度不为1.0时。\n一般字库字符数量小于100左右，模糊度为1.0时，用FindStrS要快一些,否则用FindStrFastS.
FindStrWithFont(x1,y1,x2,y2,string,color_format,sim,font_name,font_size,flag,intX,intY) = 同FindStr，但是不使用SetDict设置的字库，而利用系统自带的字库，速度比FindStr稍慢.\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串,可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例 .注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n font_name 字符串:系统字体名,比如"宋体"\n font_size 整形数:系统字体尺寸，这个尺寸一定要以大漠综合工具获取的为准.如果获取尺寸看视频教程.\n flag 整形数:字体类别 取值可以是以下值的组合,比如1+2+4+8,2+4. 0表示正常字体.\n     1 : 粗体\n     2 : 斜体\n     4 : 下划线\n     8 : 删除线\n intX 变参指针:返回X坐标 没找到返回-1\n intY 变参指针:返回Y坐标 没找到返回-1\n返回值:\n整形数:\n 返回字符串的索引 没找到返回-1, 比如"长安|洛阳",若找到长安，则返回0\n示例:\n dm_ret = dm.FindStrWithFont(0,0,2000,2000,"长安","9f2e3f-000000",1.0,"宋体",9,0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\ndm_ret = dm.FindStrWithFont(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",1.0,"宋体",9,1+2,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\n// 查找时,对多行文本进行换行,换行分隔符是"|". 语法是在","后增加换行字符串.任意字符串都可以.\n dm_ret = dm.FindStrWithFont(0,0,2000,2000,"长安|洛阳","9f2e3f-000000,|",1.0,"宋体",9,1+2,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\n注: 对于如何获取字体尺寸以及名字等信息，可以参考视频教程，如何使用系统字库.
FindStrWithFontE(x1,y1,x2,y2,string,color_format,sim,font_name,font_size,flag) = 同FindStrE，但是不使用SetDict设置的字库，而利用系统自带的字库，速度比FindStrE稍慢\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串, 可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n font_name 字符串:系统字体名,比如"宋体"\n font_size 整形数:系统字体尺寸，这个尺寸一定要以大漠综合工具获取的为准.如果获取尺寸看视频教程.\n flag 整形数:字体类别 取值可以是以下值的组合,比如1+2+4+8,2+4. 0表示正常字体.\n     1 : 粗体\n     2 : 斜体\n     4 : 下划线\n     8 : 删除线  \n返回值:\n字符串:\n 返回字符串序号以及X和Y坐标,形式如"id|x|y", 比如"0|100|200",没找到时，id和X以及Y均为-1，"-1|-1|-1"\n示例:\n pos = dm.FindStrWithFontE(0,0,2000,2000,"长安","9f2e3f-000000",1.0,"宋体",9,0)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\npos = dm.FindStrWithFontE(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",1.0,"宋体",9,1+2)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\n// 查找时,对多行文本进行换行,换行分隔符是"|". 语法是在","后增加换行字符串.任意字符串都可以.\n pos = dm.FindStrWithFontE(0,0,2000,2000,"长安|洛阳","9f2e3f-000000,|",1.0,"宋体",9,1+2)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\n注: 对于如何获取字体尺寸以及名字等信息，可以参考视频教程，如何使用系统字库.
FindStrWithFontEx(x1,y1,x2,y2,string,color_format,sim,font_name,font_size,flag) = 同FindStrEx，但是不使用SetDict设置的字库，而利用系统自带的字库，速度比FindStrEx稍慢\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串, 可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n font_name 字符串:系统字体名,比如"宋体"\n font_size 整形数:系统字体尺寸，这个尺寸一定要以大漠综合工具获取的为准.如果获取尺寸看视频教程.\n flag 整形数:字体类别 取值可以是以下值的组合,比如1+2+4+8,2+4. 0表示正常字体.\n     1 : 粗体\n     2 : 斜体\n     4 : 下划线\n     8 : 删除线\n返回值:\n字符串:\n 返回所有找到的坐标集合,格式如下:\n "id,x0,y0|id,x1,y1|......|id,xn,yn"\n 比如"0,100,20|2,30,40" 表示找到了两个,第一个,对应的是序号为0的字符串,坐标是(100,20),第二个是序号为2的字符串,坐标(30,40)\n 示例:\n dm_ret = dm.FindStrWithFontEx(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",1.0,"宋体",9,1+2)\n If len(dm_ret) > 0 Then\n    ss = split(dm_ret,"|")\n    index = 0\n    count = UBound(ss) + 1\n    Do While index < count\n       TracePrint ss(index)\n       sss = split(ss(index),",")\n       id = int(sss(0))\n       x = int(sss(1))\n       y = int(sss(2))\n       dm.MoveTo x,y\n       Delay 1000\n       index = index+1\n    Loop\n End If  \n注: 对于如何获取字体尺寸以及名字等信息，可以参考视频教程，如何使用系统字库.
GetDict(index,font_index) = 获取指定字库中指定条目的字库信息. <收费功能，具体详情点击查看>\n参数定义:\n index 整形数: 字库序号(0-9)\n font_index 整形数: 字库条目序号(从0开始计数,数值不得超过指定字库的字库上限,具体参考GetDictCount)\n返回值:\n字符串:\n 返回字库条目信息. 失败返回空串.\n示例:\n s = dm.GetDict(0,1245)\n TracePrint s\n s = dm.GetDict(1,678)\n TracePrint s
GetDictCount(index) = 获取指定的字库中的字符数量.\n参数定义:\nindex 整形数: 字库序号(0-9)\n返回值:\n整形数:\n 字库数量\n示例:\n count = dm.GetDictCount(0)\n TracePrint "0号字库使用的字库数量是:"&count
GetDictInfo(str,font_name,font_size,flag) = 根据指定的文字，以及指定的系统字库信息，获取字库描述信息.\n参数定义:\nstr 字符串:需要获取的字符串\n font_name 字符串:系统字体名,比如"宋体"\n font_size 整形数:系统字体尺寸，这个尺寸一定要以大漠综合工具获取的为准.如何获取尺寸看视频教程.\n flag 整形数:字体类别 取值可以是以下值的组合,比如1+2+4+8,2+4. 0表示正常字体.\n     1 : 粗体\n     2 : 斜体\n     4 : 下划线\n     8 : 删除线\n返回值:\n字符串:\n 返回字库信息,每个字符的字库信息用"|"来分割\n示例:\n// 下面的代码是获取"回收站"这3个字符的字库信息，然后加入到字库1中.\n font_desc = dm.GetDictInfo("回收站","宋体",9,0)\n font_desc = split(font_desc,"|")\n count = ubound(font_desc)\n for i = 0 to count\n     TracePrint font_desc(i)\n     dm.AddDict 1,font_desc(i)\n next
GetNowDict() = 获取当前使用的字库序号(0-9)\n参数定义:\n返回值:\n整形数:\n 字库序号(0-9)\n示例:\n index = dm.GetNowDict()\n TracePrint "当前使用的字库序号是:"&index
GetResultCount(ret) = 对插件部分接口的返回值进行解析,并返回ret中的坐标个数\n参数定义:\n ret 字符串: 部分接口的返回串\n返回值:\n整形数:\n 返回ret中的坐标个数\n示例:\n s = dm.FindColorEx(0,0,2000,2000,"123456-000000|abcdef-202020",1.0,0)\n count = dm.GetResultCount(s)\n MessageBox count
GetResultPos(ret,index,intX,intY) = 对插件部分接口的返回值进行解析,并根据指定的第index个坐标,返回具体的值\n参数定义:\n ret 字符串:部分接口的返回串\n index 整形数: 第几个坐标\n intX 变参指针: 返回X坐标\n intY 变参指针: 返回Y坐标\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n s = dm.FindColorEx(0,0,2000,2000,"123456-000000|abcdef-202020",1.0,0)\n count = dm.GetResultCount(s)\n index = 0\n Do While index < count\n     dm_ret = dm.GetResultPos(s,index,intX,intY)\n     MessageBox intX&","&intY \n     index = index + 1 \n Loop
GetWordResultCount(str) = 在使用GetWords进行词组识别以后,可以用此接口进行识别词组数量的计算.\n参数定义:\n str 字符串: GetWords接口调用以后的返回值\n返回值:\n整形数:\n 返回词组数量\n示例:\n s = dm.GetWords(0,0,2000,2000,"000000-000000",1.0)\n count = dm.GetWordResultCount(s)\n MessageBox count 
GetWordResultPos(str,index,intX,intY) = 在使用GetWords进行词组识别以后,可以用此接口进行识别各个词组的坐标\n参数定义:\n str 字符串: GetWords的返回值\nindex 整形数: 表示第几个词组\nintX 变参指针: 返回的X坐标\nintY 变参指针: 返回的Y坐标\n返回值:\n整形数:\n 0: 失败\n1: 成功\n示例:\n s = dm.GetWords(0,0,2000,2000,"000000-000000",1.0)\n count = dm.GetWordResultCount(s)\n index = 0\n Do While index < count\n     dm_ret = dm.GetWordResultPos(s,index,intX,intY)\n     MessageBox intX&","&intY \n     index = index + 1 \n Loop 
GetWordResultStr(str,index) = 在使用GetWords进行词组识别以后,可以用此接口进行识别各个词组的内容\n参数定义:\n str 字符串: GetWords的返回值\nindex 整形数: 表示第几个词组\n返回值:\n字符串:\n 返回的第index个词组内容\n示例:\n s = dm.GetWords(0,0,2000,2000,"000000-000000",1.0)\n count = dm.GetWordResultCount(s)\n index = 0\n Do While index < count\n     word = dm.GetWordResultStr(s,index)\n     MessageBox word \n     index = index + 1 \n Loop 
GetWords(x1, y1, x2, y2, color, sim) = 根据指定的范围,以及设定好的词组识别参数(一般不用更改,除非你真的理解了)\n识别这个范围内所有满足条件的词组. 比较适合用在未知文字的情况下,进行不定识别.\n参数定义:\n x1 整形数:左上角X坐标\n y1 整形数:左上角Y坐标\n x2 整形数:右下角X坐标\n y2 整形数:右下角Y坐标\n color 字符串: 颜色格式串.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度 0.1-1.0 \n返回值:\n字符串:\n 识别到的格式串,要用到专用函数来解析\n示例:\n s = dm.GetWords(0,0,2000,2000,"000000-000000",1.0)\n count = dm.GetWordResultCount(s)\n index = 0\n Do While index < count\n     dm_ret = dm.GetWordResultPos(s,index,intX,intY)\n     word = dm.GetWordResultStr(s,index)\n     MessageBox intX&","&intY&","&word\n     index = index + 1 \n Loop 
GetWordsNoDict(x1, y1, x2, y2, color) = 根据指定的范围,以及设定好的词组识别参数(一般不用更改,除非你真的理解了)\n识别这个范围内所有满足条件的词组. 这个识别函数不会用到字库。只是识别大概形状的位置 \n参数定义:\n x1 整形数:左上角X坐标\ny1 整形数:左上角Y坐标\nx2 整形数:右下角X坐标\ny2 整形数:右下角Y坐标\ncolor 字符串: 颜色格式串.注意，RGB和HSV格式都支持.\n返回值:\n字符串:\n 识别到的格式串,要用到专用函数来解析\n示例:\n s = dm.GetWordsNoDict(0,0,2000,2000,"000000-000000")\n count = dm.GetResultCount(s)\n index = 0\n Do While index < count\n     dm_ret = dm.GetResultPos(s,index,intX,intY)\n     MessageBox intX&","&intY\n     index = index + 1 \n Loop 
Ocr(x1,y1,x2,y2,color_format,sim) = 识别屏幕范围(x1,y1,x2,y2)内符合color_format的字符串,并且相似度为sim,sim取值范围(0.1-1.0),\n这个值越大越精确,越大速度越快,越小速度越慢,请斟酌使用!\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n color_format 字符串:颜色格式串. 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n返回值:\n字符串:\n 返回识别到的字符串\n示例:\n //RGB单色识别\n s = dm.Ocr(0,0,2000,2000,"9f2e3f-000000",1.0)\n MessageBox s\n//RGB单色差色识别\n s = dm.Ocr(0,0,2000,2000,"9f2e3f-030303",1.0)\n MessageBox s\n//RGB多色识别(最多支持10种,每种颜色用"|"分割)\n s = dm.Ocr(0,0,2000,2000,"9f2e3f-030303|2d3f2f-000000|3f9e4d-100000",1.0)\n MessageBox s\n//HSV多色识别(最多支持10种,每种颜色用"|"分割)\n s = dm.Ocr(0,0,2000,2000,"20.30.40-0.0.0|30.40.50-0.0.0",1.0)\n MessageBox s\n//识别后,每行字符串用指定字符分割\n 比如用"|"字符分割\n s = dm.Ocr(0,0,2000,2000,"9f2e3f-000000,|",1.0)\n MessageBox s\n//比如用回车换行分割\n s = dm.Ocr(0,0,2000,2000,"9f2e3f-000000,"+vbcrlf,1.0)\n MessageBox s\n//背景色识别\n //比如要识别背景色为白色,文字颜色未知的字形\n s = dm.Ocr(0,0,2000,2000,"b@ffffff-000000",1.0)\n MessageBox s\n //注: 在color_fomat最前面加上"b@"表示后面的颜色描述是针对背景色,而非字的颜色.
OcrEx(x1,y1,x2,y2,color_format,sim) = 识别屏幕范围(x1,y1,x2,y2)内符合color_format的字符串,并且相似度为sim,sim取值范围(0.1-1.0),\n这个值越大越精确,越大速度越快,越小速度越慢,请斟酌使用!\n这个函数可以返回识别到的字符串，以及每个字符的坐标.\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n color_format 字符串:颜色格式串.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n返回值:\n字符串:\n 返回识别到的字符串 格式如  "识别到的信息|x0,y0|…|xn,yn"\n示例:\n和Ocr函数相同，只是结果处理有所不同 如下\nss = dm.OcrEx(0,0,2000,2000,"ffffff|000000",1.0)\n ss = split(ss,"|")\n MessageBox "识别到的字符串:"&ss(0)\n ss_len = len(ss(0))\n for i = 1 to ss_len \n     MessageBox "第("&i&")的坐标是"&ss(i)\n next
OcrInFile(x1, y1, x2, y2, pic_name, color_format, sim) = 识别位图中区域(x1,y1,x2,y2)的文字\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n pic_name 字符串:图片文件名\n color_format 字符串:颜色格式串.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n返回值:\n 字符串:\n 返回识别到的字符串\n示例:\n s = dm.OcrInFile(0,0,2000,2000,"test.bmp","000000-000000",1.0)\n MessageBox s
SaveDict(index,file) = 保存指定的字库到指定的文件中.\n参数定义:\n index 整形数:字库索引序号 取值为0-9对应10个字库\n file 字符串:文件名\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.SetPath "c:\test_game"\n dm.AddDict 0,"FFF00A7D49292524A7D402805FFC$回$0.0.54$11"\n dm.AddDict 0,"3F0020087FF08270B9A108268708808$收$0.0.43$11"\n dm.AddDict 0,"2055C98617420807C097F222447C800$站$0.0.44$11"\n dm.SaveDict 0,"test.txt"  
SetColGapNoDict(col_gap) = 高级用户使用,在不使用字库进行词组识别前,可设定文字的列距,默认列距是1\n参数定义:\n col_gap 整形数:文字列距\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetColGapNoDict(3)
SetDict(index,file) = 设置字库文件\n参数定义:\nindex 整形数:字库的序号,取值为0-9,目前最多支持10个字库\n file 字符串:字库文件名\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetDict(0,"test.txt")\n 注: 此函数速度很慢，全局初始化时调用一次即可，切换字库用UseDict
SetDictMem(index,addr,size) = 从内存中设置字库.  <收费功能，具体详情点击查看>\n参数定义:\nindex 整形数:字库的序号,取值为0-9,目前最多支持10个字库\n addr 整形数: 数据地址\n size 整形数: 字库长度\n返回值:\n 整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetDictMem(0,234324,1000)\n 注: 此函数速度很慢，全局初始化时调用一次即可，切换字库用UseDict\n 另外，此函数不支持加密的内存字库.
SetDictPwd(pwd) = 设置字库的密码,在SetDict前调用,目前的设计是,所有字库通用一个密码.\n参数定义:\n pwd 字符串:字库密码\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetDictPwd("1234")\n注意:如果使用了多字库,所有字库的密码必须一样. 此函数必须在SetDict之前调用,否则会解密失败.
SetExactOcr(exact_ocr) = 高级用户使用,在使用文字识别功能前，设定是否开启精准识别.\n参数定义:\n exact_ocr 整形数: 0 表示关闭精准识别\n            1 开启精准识别\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n// 开启精准识别\n dm_ret = dm.SetExactOcr(1)\n注意: 精准识别开启后，行间距和列间距会对识别结果造成较大影响，可以在工具中进行测试.
SetMinColGap(min_col_gap) = 高级用户使用,在识别前,如果待识别区域有多行文字,可以设定列间距,默认的列间距是0,\n如果根据情况设定,可以提高识别精度。一般不用设定。\n参数定义:\n min_col_gap 整形数:最小列间距\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetMinColGap(1)\n注意：此设置如果不为0,那么将不能识别连体字 慎用.
SetMinRowGap(min_row_gap) = 高级用户使用,在识别前,如果待识别区域有多行文字,可以设定行间距,默认的行间距是1,\n如果根据情况设定,可以提高识别精度。一般不用设定。\n参数定义:\n min_row_gap 整形数:最小行间距\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetMinRowGap(2)
SetRowGapNoDict(row_gap) = 高级用户使用,在不使用字库进行词组识别前,可设定文字的行距,默认行距是1\n参数定义:\n row_gap 整形数:文字行距\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm_ret = dm.SetRowGapNoDict(3)
SetWordGap(word_gap) = 高级用户使用,在识别词组前,可设定词组间的间隔,默认的词组间隔是5\n参数定义:\n word_gap 整形数:单词间距\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetWordGap(5)
SetWordGapNoDict(word_gap) = 高级用户使用,在不使用字库进行词组识别前,可设定词组间的间隔,默认的词组间隔是5\n参数定义:\n word_gap 整形数:单词间距\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetWordGapNoDict(1)
SetWordLineHeight(line_height) = 高级用户使用,在识别词组前,可设定文字的平均行高,默认的词组行高是10\n参数定义:\n line_height 整形数:行高\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetWordLineHeight(15)
SetWordLineHeightNoDict(line_height) = 高级用户使用,在不使用字库进行词组识别前,可设定文字的平均行高,默认的词组行高是10\n参数定义:\n line_height 整形数:行高\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetWordLineHeightNoDict(15)
UseDict(index) = 表示使用哪个字库文件进行识别(index范围:0-9)\n设置之后，永久生效，除非再次设定  \n参数定义:\n index 整形数:字库编号(0-9)\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.UseDict(1)\n ss = dm.Ocr(0,0,2000,2000,"FFFFFF-000000",1.0)\n dm_ret = dm.UseDict(0)
ActiveInputMethod(hwnd,input_method) = 激活指定窗口所在进程的输入法. \n参数定义:\nhwnd 整形数: 窗口句柄\n input_method 字符串: 输入法名字。 具体输入法名字对应表查看注册表中以下位置:\nHKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layouts\n下面的每一项下的Layout Text的值就是输入法名字\n比如 "中文 - QQ拼音输入法"  \n以此类推.\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm_ret = dm.ActiveInputMethod(hwnd,"中文 - QQ拼音输入法")\n if dm_ret = 1 then\n     msgbox "QQ输入法开启成功"\n end if  
CheckInputMethod(hwnd,input_method) = 检测指定窗口所在线程输入法是否开启\n参数定义:\nhwnd 整形数: 窗口句柄\n input_method 字符串: 输入法名字。 具体输入法名字对应表查看注册表中以下位置:\nHKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layouts\n下面的每一项下的Layout Text的值就是输入法名字\n比如 "中文 - QQ拼音输入法"  \n以此类推.\n返回值:\n整形数:\n 0 : 未开启\n1 : 开启\n示例:\n dm_ret = dm.CheckInputMethod(hwnd,"中文 - QQ拼音输入法")\n if dm_ret = 1 then\n     msgbox "QQ输入法开启拉"\n end if
FindInputMethod(input_method) = 检测系统中是否安装了指定输入法\n参数定义:\n input_method 字符串: 输入法名字。 具体输入法名字对应表查看注册表中以下位置:\nHKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layouts\n下面的每一项下的Layout Text的值就是输入法名字\n比如 "中文 - QQ拼音输入法"  \n以此类推.\n返回值:\n整形数:\n 0 : 未安装\n1 : 安装了\n示例:\n dm_ret = dm.FindInputMethod("中文 - QQ拼音输入法")\n if dm_ret = 1 then\n     msgbox "QQ输入法安装啦"\n end if
AsmAdd(asm_ins) = 添加指定的MASM汇编指令\n 参数定义:\n asm_ins 字符串:MASM汇编指令,大小写均可以  比如 "mov eax,1"\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.AsmAdd "push 0100"\n dm.AsmAdd "push 060304d"\n dm.AsmAdd "call 0678fed"  \n注: 简单游平台不支持此接口
AsmCall(hwnd,mode) = 执行用AsmAdd加到缓冲中的指令. 多线程下是收费功能, 免费版本多线程会异常. <收费功能，具体详情点击查看>\n 参数定义:\n hwnd 整形数: 窗口句柄\nmode 整形数: 模式，取值如下\n       0 : 在本进程中进行执行，这时hwnd无效\n       1 : 对hwnd指定的进程内执行,注入模式为创建远程线程\n返回值:\n整形数:\n 获取执行汇编代码以后的EAX的值.一般是函数的返回值.\n示例:\ndm.AsmClear\n dm.AsmAdd "mov eax,1"\n dm.AsmAdd "push 0123456"\n dm.AsmAdd "call 0343434"\n dm.AsmCall hwnd,1  \n注: 简单游平台不支持此接口\n另要注意的是，AsmAdd里所有的数值都是16进制，并且每个数值必须以0打头，否则解析会出错.
AsmClear() = 清除汇编指令缓冲区 用AsmAdd添加到缓冲的指令全部清除\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.AsmClear  \n注: 简单游平台不支持此接口
AsmCode(base_addr) = 把汇编缓冲区的指令转换为机器码 并用16进制字符串的形式输出\n 参数定义:\nbase_addr 字符串: 用AsmAdd添加到缓冲区的第一条指令所在的地址\n返回值:\n字符串:\n 机器码，比如 "aa bb cc"这样的形式\n示例:\ncode = dm.AsmCode(&H405940)\n MessageBox code  \n注: 简单游平台不支持此接口
Assemble(asm_code,base_addr,is_upper) = 把指定的机器码转换为汇编语言输出\n 参数定义:\n asm_code 字符串: 机器码，形式如 "aa bb cc"这样的16进制表示的字符串(空格无所谓)\nbase_addr 整形数: 指令所在的地址\nis_upper 整形数: 表示转换的汇编语言是否以大写输出\n返回值:\n字符串:\n MASM汇编语言字符串\n示例:\ndm_ret = dm.Assemble("81 05 E0 5A 47 00 01 00 00 00",&H435fde,0)\n MessageBox dm_ret  \n注: 简单游平台不支持此接口
ClientToScreen(hwnd,x,y) = 把窗口坐标转换为屏幕坐标 \n参数定义:\n hwnd 整形数: 指定的窗口句柄\nx 变参指针: 窗口X坐标\ny 变参指针: 窗口Y坐标\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\nx = 0:y = 0 \n dm_ret = dm.ClientToScreen(hwnd,x,y) 
EnumWindow(parent,title,class_name,filter) = 根据指定条件,枚举系统中符合条件的窗口,可以枚举到按键自带的无法枚举到的窗口\n参数定义:\n parent 整形数: 获得的窗口句柄是该窗口的子窗口的窗口句柄,取0时为获得桌面句柄\ntitle 字符串: 窗口标题. 此参数是模糊匹配.\nclass_name 字符串: 窗口类名. 此参数是模糊匹配.\nfilter整形数: 取值定义如下\n1 : 匹配窗口标题,参数title有效 \n2 : 匹配窗口类名,参数class_name有效.\n4 : 只匹配指定父窗口的第一层孩子窗口\n8 : 匹配所有者窗口为0的窗口,即顶级窗口\n16 : 匹配可见的窗口\n32 : 匹配出的窗口按照窗口打开顺序依次排列 <收费功能，具体详情点击查看>\n这些值可以相加,比如4+8+16就是类似于任务管理器中的窗口列表\n返回值:\n字符串 :\n 返回所有匹配的窗口句柄字符串,格式"hwnd1,hwnd2,hwnd3"\n示例:\nhwnds = dm.EnumWindow(0,"QQ三国","",1+4+8+16)\n这句是获取到所有标题栏中有QQ三国这个字符串的窗口句柄集合\nhwnds = split(hwnds,",")\n转换为数组后,就可以处理了\n这里注意,hwnds数组里的是字符串,要用于使用,比如BindWindow时,还得强制类型转换,比如int(hwnds(0))
EnumWindowByProcess(process_name,title,class_name,filter) = 根据指定进程以及其它条件,枚举系统中符合条件的窗口,可以枚举到按键自带的无法枚举到的窗口\n参数定义:\n process_name 字符串: 进程映像名.比如(svchost.exe). 此参数是精确匹配,但不区分大小写.\ntitle 字符串: 窗口标题. 此参数是模糊匹配.\nclass_name 字符串: 窗口类名. 此参数是模糊匹配.\nfilter 整形数: 取值定义如下\n1 : 匹配窗口标题,参数title有效\n2 : 匹配窗口类名,参数class_name有效\n4 : 只匹配指定映像的所对应的第一个进程. 可能有很多同映像名的进程，只匹配第一个进程的.\n8 : 匹配所有者窗口为0的窗口,即顶级窗口\n16 : 匹配可见的窗口\n32 : 匹配出的窗口按照窗口打开顺序依次排列<收费功能，具体详情点击查看>\n这些值可以相加,比如4+8+16\n返回值:\n字符串:\n 返回所有匹配的窗口句柄字符串,格式"hwnd1,hwnd2,hwnd3"\n示例:\nhwnds = dm.EnumWindowByProcess("game.exe","天龙八部","",1+8+16)\n这句是获取到所有标题栏中有"天龙八部"这个字符串的窗口句柄集合,并且所在进程是"game.exe"指定的进程集合.\nhwnds = split(hwnds,",")\n转换为数组后,就可以处理了\n这里注意,hwnds数组里的是字符串,要用于使用,比如BindWindow时,还得强制类型转换,比如int(hwnds(0))
EnumWindowSuper(spec1,flag1,type1,spec2,flag2,type2,sort) = 根据两组设定条件来枚举指定窗口. <收费功能，具体详情点击查看>\n参数定义:\nspec1 字符串: 查找串1. (内容取决于flag1的值)\nflag1整形数: 取值如下:\n   0表示spec1的内容是标题\n   1表示spec1的内容是程序名字. (比如notepad)\n   2表示spec1的内容是类名\n   3表示spec1的内容是程序路径.(不包含盘符,比如\windows\system32)\n   4表示spec1的内容是父句柄.(十进制表达的串)\n   5表示spec1的内容是父窗口标题\n   6表示spec1的内容是父窗口类名\n   7表示spec1的内容是顶级窗口句柄.(十进制表达的串)\n   8表示spec1的内容是顶级窗口标题\n   9表示spec1的内容是顶级窗口类名\ntype1 整形数: 取值如下\n 0精确判断\n 1模糊判断\nspec2 字符串: 查找串2. (内容取决于flag2的值)\nflag2 整形数: 取值如下:\n   0表示spec2的内容是标题\n   1表示spec2的内容是程序名字. (比如notepad)\n   2表示spec2的内容是类名\n   3表示spec2的内容是程序路径.(不包含盘符,比如\windows\system32)\n   4表示spec2的内容是父句柄.(十进制表达的串)\n   5表示spec2的内容是父窗口标题\n   6表示spec2的内容是父窗口类名\n   7表示spec2的内容是顶级窗口句柄.(十进制表达的串)\n   8表示spec2的内容是顶级窗口标题\n   9表示spec2的内容是顶级窗口类名\ntype2  整形数: 取值如下\n 0精确判断\n 1模糊判断\nsort  整形数: 取值如下\n 0不排序.\n 1对枚举出的窗口进行排序,按照窗口打开顺序.\n返回值:\n 字符串:\n 返回所有匹配的窗口句柄字符串,格式"hwnd1,hwnd2,hwnd3"\n示例:\nhwnds = dm.EnumWindowSuper("记事本",0,1,"notepad",1,0,0) \nhwnds = split(hwnds,",")\n转换为数组后,就可以处理了\n这里注意,hwnds数组里的是字符串,要用于使用,比如BindWindow时,还得强制类型转换,比如int(hwnds(0))
FindWindow(class,title) = 查找符合类名或者标题名的顶层可见窗口\n参数定义:\n class 字符串: 窗口类名，如果为空，则匹配所有. 这里的匹配是模糊匹配.\ntitle 字符串: 窗口标题,如果为空，则匹配所有.这里的匹配是模糊匹配.\n返回值:\n整形数:\n 整形数表示的窗口句柄，没找到返回0\n示例:\nhwnd = dm.FindWindow("","记事本") 
FindWindowByProcess(process_name,class,title) = 根据指定的进程名字，来查找可见窗口.  <收费功能，具体详情点击查看>\n参数定义:\n process_name 字符串: 进程名. 比如(notepad.exe).这里是精确匹配,但不区分大小写.\n class 字符串: 窗口类名，如果为空，则匹配所有. 这里的匹配是模糊匹配.\ntitle 字符串: 窗口标题,如果为空，则匹配所有.这里的匹配是模糊匹配.\n返回值:\n 整形数:\n 整形数表示的窗口句柄，没找到返回0\n示例:\nhwnd = dm.FindWindowByProcess("noteapd.exe","","记事本") 
FindWindowByProcessId(process_id,class,title) = 根据指定的进程Id，来查找可见窗口.  <收费功能，具体详情点击查看>\n参数定义:\n process_id 整形数: 进程id. \n class 字符串: 窗口类名，如果为空，则匹配所有. 这里的匹配是模糊匹配.\ntitle 字符串: 窗口标题,如果为空，则匹配所有.这里的匹配是模糊匹配.\n返回值:\n 整形数:\n 整形数表示的窗口句柄，没找到返回0\n示例:\nhwnd = dm.FindWindowByProcessId(123456,"","记事本") 
FindWindowEx(parent,class,title) = 查找符合类名或者标题名的顶层可见窗口,如果指定了parent,则在parent的第一层子窗口中查找.\n参数定义:\n parent 整形数: 父窗口句柄，如果为空，则匹配所有顶层窗口\n class 字符串: 窗口类名，如果为空，则匹配所有. 这里的匹配是模糊匹配.\ntitle 字符串: 窗口标题,如果为空，则匹配所有. 这里的匹配是模糊匹配.\n返回值:\n整形数:\n 整形数表示的窗口句柄，没找到返回0\n示例:\nhwnd = dm.FindWindowEx(0,"","记事本") 
FindWindowSuper(spec1,flag1,type1,spec2,flag2,type2) = 根据两组设定条件来查找指定窗口. <收费功能，具体详情点击查看>\n参数定义:\nspec1 字符串: 查找串1. (内容取决于flag1的值)\nflag1整形数: 取值如下:\n   0表示spec1的内容是标题\n   1表示spec1的内容是程序名字. (比如notepad)\n   2表示spec1的内容是类名\n   3表示spec1的内容是程序路径.(不包含盘符,比如\windows\system32)\n   4表示spec1的内容是父句柄.(十进制表达的串)\n   5表示spec1的内容是父窗口标题\n   6表示spec1的内容是父窗口类名\n   7表示spec1的内容是顶级窗口句柄.(十进制表达的串)\n   8表示spec1的内容是顶级窗口标题\n   9表示spec1的内容是顶级窗口类名\ntype1 整形数: 取值如下\n 0精确判断\n 1模糊判断\nspec2 字符串: 查找串2. (内容取决于flag2的值)\nflag2 整形数: 取值如下:\n   0表示spec2的内容是标题\n   1表示spec2的内容是程序名字. (比如notepad)\n   2表示spec2的内容是类名\n   3表示spec2的内容是程序路径.(不包含盘符,比如\windows\system32)\n   4表示spec2的内容是父句柄.(十进制表达的串)\n   5表示spec2的内容是父窗口标题\n   6表示spec2的内容是父窗口类名\n   7表示spec2的内容是顶级窗口句柄.(十进制表达的串)\n   8表示spec2的内容是顶级窗口标题\n   9表示spec2的内容是顶级窗口类名\ntype2  整形数: 取值如下\n 0精确判断\n 1模糊判断\n返回值:\n 整形数:\n 整形数表示的窗口句柄，没找到返回0\n示例:\nhwnd = dm.FindWindowSuper("记事本",0,1,"notepad",1,0) 
GetClientRect(hwnd,x1,y1,x2,y2) = 获取窗口客户区域在屏幕上的位置\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n x1 变参指针: 返回窗口客户区左上角X坐标\ny1 变参指针: 返回窗口客户区左上角Y坐标\nx2 变参指针: 返回窗口客户区右下角X坐标\ny2 变参指针: 返回窗口客户区右下角Y坐标\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm_ret = dm.GetClientRect(hwnd,x1,y1,x2,y2)
GetClientSize(hwnd,width,height) = 获取窗口客户区域的宽度和高度\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n width 变参指针: 宽度\nheight 变参指针: 高度\n返回值:\n 整形数:\n 0: 失败\n 1: 成功\n示例:\ndm_ret = dm.GetClientSize(hwnd,w,h) \n TracePrint "宽度:"& w &",高度:"& h
GetForegroundFocus() = 获取顶层活动窗口中具有输入焦点的窗口句柄 \n参数定义:\n返回值:\n整形数:\n 返回整型表示的窗口句柄\n示例:\nhwnd = dm.GetForegroundFocus()
GetForegroundWindow() = 获取顶层活动窗口,可以获取到按键自带插件无法获取到的句柄\n参数定义:\n返回值:\n整形数:\n 返回整型表示的窗口句柄\n示例:\nhwnd = dm.GetForegroundWindow()
GetMousePointWindow() = 获取鼠标指向的窗口句柄,可以获取到按键自带的插件无法获取到的句柄\n参数定义:\n返回值:\n整形数:\n 返回整型表示的窗口句柄\n示例:\nhwnd = dm.GetMousePointWindow()
GetPointWindow(x,y) = 获取给定坐标的窗口句柄,可以获取到按键自带的插件无法获取到的句柄\n参数定义:\nX 整形数: 屏幕X坐标\nY 整形数: 屏幕Y坐标\n返回值:\n整形数:\n 返回整型表示的窗口句柄\n示例:\nhwnd = dm.GetPointWindow(100,100)
GetSpecialWindow(flag) = 获取特殊窗口\n参数定义:\nFlag 整形数: 取值定义如下\n0 : 获取桌面窗口\n1 : 获取任务栏窗口\n返回值:\n整形数:\n 以整型数表示的窗口句柄\n示例:\ndesk_win = dm.GetSpecialWindow(0) 
GetWindow(hwnd,flag) = 获取给定窗口相关的窗口句柄\n参数定义:\nhwnd 整形数: 窗口句柄\nflag 整形数: 取值定义如下\n0 : 获取父窗口\n1 : 获取第一个儿子窗口\n2 : 获取First 窗口\n3 : 获取Last窗口\n4 : 获取下一个窗口\n5 : 获取上一个窗口\n6 : 获取拥有者窗口\n7 : 获取顶层窗口\n返回值:\n整形数:\n 返回整型表示的窗口句柄\n示例:\nown_hwnd = dm.GetWindow(hwnd,6)
GetWindowClass(hwnd) = 获取窗口的类名\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n返回值:\n字符串:\n 窗口的类名\n示例:\nclass_name = dm.GetWindowClass(hwnd) 
GetWindowProcessId(hwnd) = 获取指定窗口所在的进程ID.\n参数定义:\nhwnd 整形数: 窗口句柄\n返回值:\n整形数:\n 返回整型表示的是进程ID\n示例:\nprocess_id = dm.GetWindowProcessId(hwnd)
GetWindowProcessPath(hwnd) = 获取指定窗口所在的进程的exe文件全路径.\n参数定义:\nhwnd 整形数: 窗口句柄\n返回值:\n字符串:\n 返回字符串表示的是exe全路径名\n示例:\nprocess_path = dm.GetWindowProcessPath(hwnd)
GetWindowRect(hwnd,x1,y1,x2,y2) = 获取窗口在屏幕上的位置\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n x1 变参指针: 返回窗口左上角X坐标\ny1 变参指针: 返回窗口左上角Y坐标\nx2 变参指针: 返回窗口右下角X坐标\ny2 变参指针: 返回窗口右下角Y坐标\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm_ret = dm.GetWindowRect(hwnd,x1,y1,x2,y2)
GetWindowState(hwnd,flag) = 获取指定窗口的一些属性\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n flag 整形数: 取值定义如下\n0 : 判断窗口是否存在\n1 : 判断窗口是否处于激活\n2 : 判断窗口是否可见\n3 : 判断窗口是否最小化\n4 : 判断窗口是否最大化\n5 : 判断窗口是否置顶\n6 : 判断窗口是否无响应\n返回值:\n整形数:\n 0: 不满足条件\n 1: 满足条件\n示例:\ndm_ret = dm.GetWindowState(hwnd,3) \n If dm_ret = 1 Then\n     MessageBox "窗口已经最小化了"\n End If
GetWindowTitle(hwnd) = 获取窗口的标题\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n返回值:\n字符串:\n 窗口的标题\n示例:\ntitle = dm.GetWindowTitle(hwnd) 
MoveWindow(hwnd,x,y) = 移动指定窗口到指定位置\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n x 整形数: X坐标\ny 整形数: Y坐标\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm.MoveWindow hwnd,-10,-10
ScreenToClient(hwnd,x,y) = 把屏幕坐标转换为窗口坐标\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n x 变参指针: 屏幕X坐标\ny 变参指针: 屏幕Y坐标\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\nx = 100:y = 100 \n dm_ret = dm.ScreenToClient(hwnd,x,y) 
SendPaste(hwnd) = 向指定窗口发送粘贴命令. 把剪贴板的内容发送到目标窗口.\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm.SetClipboard "abcd"\n dm.SendPaste hwnd\n注:剪贴板是公共资源，多个线程同时设置剪贴板时,会产生冲突，必须用互斥信号保护.
SendString(hwnd,str) = 向指定窗口发送文本数据\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n str 字符串: 发送的文本数据\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm.SendString hwnd,"我是来测试的"
SendString2(hwnd,str) = 向指定窗口发送文本数据\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n str 字符串: 发送的文本数据\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm.SendString2 hwnd,"我是来测试的"\n注: 此接口为老的SendString，如果新的SendString不能输入，可以尝试此接口.
SendStringIme(str) = 向绑定的窗口发送文本数据.必须配合dx.public.input.ime属性.  <收费功能，具体详情点击查看>\n参数定义:\n str 字符串: 发送的文本数据\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm_ret = dm.BindWindowEx(hwnd,"normal","normal","normal","dx.public.input.ime",0)\n dm.SendStringIme "我是来测试的"
SetClientSize(hwnd,width,height) = 设置窗口客户区域的宽度和高度\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n width 整形数: 宽度\nheight 整形数: 高度\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm_ret = dm.SetClientSize(hwnd,800,600) 
SetWindowSize(hwnd,width,height) = 设置窗口的大小\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n width 整形数: 宽度\nheight 整形数: 高度\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm_ret = dm.SetWindowSize(hwnd,300,400)
SetWindowState(hwnd,flag) = 设置窗口的状态\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n flag 整形数: 取值定义如下\n0 : 关闭指定窗口\n1 : 激活指定窗口\n2 : 最小化指定窗口,但不激活\n3 : 最小化指定窗口,并释放内存,但同时也会激活窗口.\n4 : 最大化指定窗口,同时激活窗口.\n5 : 恢复指定窗口 ,但不激活\n6 : 隐藏指定窗口\n7 : 显示指定窗口\n8 : 置顶指定窗口\n9 : 取消置顶指定窗口\n10 : 禁止指定窗口\n11 : 取消禁止指定窗口\n12 : 恢复并激活指定窗口\n13 : 强制结束窗口所在进程.\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm_ret = dm.SetWindowState(hwnd,0) 
SetWindowText(hwnd,title) = 设置窗口的标题\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n titie 字符串: 标题\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm_ret = dm.SetWindowText(hwnd,"test") 
SetWindowTransparent(hwnd,trans) = 设置窗口的透明度\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n trans 整形数: 透明度 取值(0-255) 越小透明度越大 0为完全透明(不可见) 255为完全显示(不透明)\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm_ret = dm.SetWindowTransparent(hwnd,200) \n注 :  此接口不支持WIN98
FaqCancel() = 可以把上次FaqPost的发送取消,接着下一次FaqPost\n参数定义:\n返回值:\n整形数:\n 0 : 失败\n 1 : 成功\n示例:\n// 截取这个范围内,3秒动画,图像质量为中等50,动画帧率间隔为100ms\n handle = dm.FaqCapture(50,50,300,400,50,100,3000)\n // 调用FaqPost异步发送\n dm.FaqCancel\n dm_ret = dm.FaqPost("192.168.1.100:12345",handle,1,3 * 60 * 1000)\n If dm_ret = 0 Then\n     MessageBox "发送失败，可能上个FaqPost还未处理完毕"\n     EndScript\n End If\n // 不影响脚本运行\n    result = dm.FaqFetch()\n    If len(result) > 0 Then\n         MessageBox "服务器返回结果 = "&result\n    End If\n    // 做其他的事情 这里就假设为延时\n    Delay 1000\n Loop
FaqCapture(x1, y1, x2, y2, quality, delay, time) = 截取指定范围内的动画或者图像,并返回此句柄.\n参数定义:\n x1 整形数: 左上角X坐标\ny1 整形数: 左上角Y坐标\nx2 整形数: 右下角X坐标\ny2 整形数: 右下角Y坐标\nquality 整形数: 图像或动画品质,或者叫压缩率,此值越大图像质量越好 取值范围（1-100）\ndelay 整形数: 截取动画时用,表示相隔两帧间的时间间隔,单位毫秒 （如果只是截取静态图像,这个参数必须是0）\ntime 整形数: 表示总共截取多久的动画,单位毫秒 （如果只是截取静态图像,这个参数必须是0）\n返回值:\n整形数:\n 图像或者动画句柄\n示例:\n// 截取这个范围内,3秒动画,图像质量为中等50,动画帧率间隔为100ms\n handle = dm.FaqCapture(intX - 50,intY - 232,intX+272,intY-12,50,100,3000)\n注 : 从插件版本2.1119之后，接口FaqCapture返回handle，不需要再手动调用FaqRelease释放了。插件已经自动释放了.
FaqCaptureFromFile(x1, y1, x2, y2, file, quality) = 截取指定图片中的图像,并返回此句柄.  <收费功能，具体详情点击查看>\n参数定义:\n x1 整形数: 左上角X坐标\ny1 整形数: 左上角Y坐标\nx2 整形数: 右下角X坐标\ny2 整形数: 右下角Y坐标\nfile 字符串: 图片文件名,图像格式基本都支持.\nquality 整形数: 图像或动画品质,或者叫压缩率,此值越大图像质量越好 取值范围（1-100）\n返回值:\n整形数:\n 图像或者动画句柄\n示例:\n handle = dm.FaqCaptureFromFile(0,0,2000,2000,"c:\test.bmp",50)
FaqFetch() = 获取由FaqPost发送后，由服务器返回的答案.\n参数定义:\n返回值:\n字符串:\n 如果此函数调用失败,那么返回值如下\n"Error:错误描述" \n如果函数调用成功,那么返回值如下\n"OK:答案"\n根据FaqPost中 request_type取值的不同,返回值不同\n当request_type 为0时,答案的格式为"x,y" (不包含引号)\n当request_type 为1时,答案的格式为"1" "2" "3" "4" "5" "6" (不包含引号)\n当request_type 为2时,答案就是要求的答案 比如 "李白" (不包含引号)\n当request_type 为3时,答案的格式为"x1,y1|x2,y2" 比如 "20,30|78,68" (不包含引号)\n如果返回为空字符串，表示FaqPost还未处理完毕,或者没有调用过FaqPost.\n示例:\n// 截取这个范围内,3秒动画,图像质量为中等50,动画帧率间隔为100ms\n handle = dm.FaqCapture(50,50,300,400,50,100,3000)\n // 调用FaqPost异步发送\n dm_ret = dm.FaqPost("192.168.1.100:12345",handle,1,3 * 60 * 1000)\n If dm_ret = 0 Then\n     MessageBox "发送失败，可能上个FaqPost还未处理完毕"\n     EndScript\n End If\n // 不影响脚本运行\n    result = dm.FaqFetch()\n    If len(result) > 0 Then\n         MessageBox "服务器返回结果 = "&result\n    End If\n    // 做其他的事情 这里就假设为延时\n    Delay 1000\n Loop\n注: 如果此函数调用成功后，插件内部状态会再次重置为未处理状态，可以接着处理FaqPost接口.
FaqGetSize(handle) = 获取句柄所对应的数据包的大小,单位是字节\n参数定义:\n handle 整形数: 由FaqCapture返回的句柄\n返回值:\n整形数:\n 数据包大小,一般用于判断数据大小,选择合适的压缩比率.\n示例:\n// 截取这个范围内,3秒动画,图像质量为中等50,动画帧率间隔为100ms\n handle = dm.FaqCapture(intX - 50,intY - 232,intX+272,intY-12,50,100,3000)\n packet_size = dm.FaqGetSize(handle)\n MessageBox packet_size  
FaqPost(server, handle, request_type, time_out) = 发送指定的图像句柄到指定的服务器,并立即返回(异步操作).\n参数定义:\n server 字符串: 服务器地址以及端口,格式为(ip:port),例如 "192.168.1.100:12345"\nhandle 整形数: 由FaqCapture获取到的句柄\nrequest_type 整形数: 取值定义如下\n             0 : 要求获取坐标\n             1 : 要求获取选项,比如(ABCDE)\n             2 : 要求获取文字答案\n 3 : 要求获取两个坐标.此功能要求答题器必须是v15之后的版本. <收费功能，具体详情点击查看>\ntime_out 整形数: 表示等待多久,单位是毫秒\n返回值:\n整形数:\n 0 : 失败，一般情况下是由于上个FaqPost还没有处理完毕(服务器还没返回)\n1 : 成功\n示例:\n// 截取这个范围内,静态图片,图像质量为中等50 \n handle = dm.FaqCapture(50,50,300,400,50,0,0)\n // 调用FaqPost异步发送\n dm_ret = dm.FaqPost("192.168.1.100:12345",handle,1,3 * 60 * 1000)\n If dm_ret = 0 Then\n     MessageBox "发送失败，可能上个FaqPost还未处理完毕"\n     EndScript\n End If\n // 不影响脚本运行\n    result = dm.FaqFetch()\n    If len(result) > 0 Then\n         result = split(result,":")\n         If result(0) = "OK" Then\n              MessageBox result(1)\n         Else\n              MessageBox "错误:"& result(1)\n         End If \n    End If\n    // 做其他的事情 这里就假设为延时\n    Delay 1000\n Loop\n注 : 从插件版本2.1119之后，接口FaqCapture返回handle，不需要再手动调用FaqRelease释放了。插件已经自动释放了.\n本接口不支持多ip发送.
FaqSend(server, handle, request_type, time_out) = 发送指定的图像句柄到指定的服务器,并等待返回结果(同步等待).\n参数定义:\n server 字符串: 服务器地址以及端口,格式为(ip:port),例如 "192.168.1.100:12345"\n          多个地址可以用"|"符号连接。比如"192.168.1.100:12345|192.168.1.101:12345"。\nhandle 整形数: 由FaqCapture获取到的句柄\nrequest_type 整形数: 取值定义如下\n             0 : 要求获取坐标\n             1 : 要求获取选项,比如(ABCDE)\n             2 : 要求获取文字答案\n 3 : 要求获取两个坐标.此功能要求答题器必须是v15之后的版本. <收费功能，具体详情点击查看>\ntime_out 整形数: 表示等待多久,单位是毫秒\n返回值:\n整形数:\n如果此函数调用失败,那么返回值如下\n"Error:错误描述" \n如果函数调用成功,那么返回值如下\n"OK:答案"\n根据request_type取值的不同,返回值不同\n当request_type 为0时,答案的格式为"x,y" (不包含引号)\n当request_type 为1时,答案的格式为"1" "2" "3" "4" "5" "6" (不包含引号)\n当request_type 为2时,答案就是要求的答案 比如 "李白" (不包含引号)\n当request_type 为3时,答案的格式为"x1,y1|x2,y2" 比如 "20,30|78,68" (不包含引号)\n示例:\n// 截取这个范围内,3秒动画,图像质量为中等50,动画帧率间隔为100ms\n handle = dm.FaqCapture(20,20,100,100,50,100,3000)\n // 等待3分钟,答案要求是选项\n result = dm.FaqSend("192.168.1.100:12345|192.168.1.101:12345",handle,1,3 * 60 * 1000)\n result = split(result,":")\n If result(0) = "OK" Then\n    If result(1) = "1" Then\n       MessageBox "1"\n    ElseIf result(1) = "2" Then\n       MessageBox "2"\n    ElseIf result(1) = "3" Then\n       MessageBox "3"\n    ElseIf result(1) = "4" Then\n       MessageBox "4"\n    End If \n Else\n    MessageBox "错误:"& result(1)\n End If \n注 : 从插件版本2.1119之后，接口FaqCapture返回handle，不需要再手动调用FaqRelease释放了。插件已经自动释放了.\n另外，当向多个地址发送题目时，只要有任意一个服务器返回答案，函数就返回结果。
ExcludePos(all_pos,type,x1,y1,x2,y2) = 根据部分Ex接口的返回值，排除指定范围区域内的坐标.\n参数定义:\n all_pos 字符串: 坐标描述串。  一般是FindStrEx,FindStrFastEx,FindStrWithFontEx, FindColorEx, FindMultiColorEx,和FindPicEx的返回值.\n type 整形数:  取值为0或者1\n     如果all_pos的内容是由FindPicEx,FindStrEx,FindStrFastEx,FindStrWithFontEx返回，那么取值为0\n     如果all_pos的内容是由FindColorEx, FindMultiColorEx返回，那么取值为1\nx1 整形数: 左上角横坐标\n y1 整形数: 左上角纵坐标\n x2 整形数: 右下角横坐标\n y2 整形数: 右下角纵坐标\n返回值:\n字符串:\n 经过筛选以后的返回值，格式和type指定的一致.\n示例:\nret = dm.FindColorEx(0,0,2000,2000,"aaaaaa-000000",1.0,0)\n ret = dm.ExcludePos(ret,1,100,100,300,400)\n TracePrint ret\nret = dm.FindPicEx(0,0,2000,2000,"a.bmp","000000",1.0,0)\n ret = dm.ExcludePos(ret,0,100,100,300,400)\n TracePrint ret
FindNearestPos(all_pos,type,x,y) = 根据部分Ex接口的返回值，然后在所有坐标里找出距离指定坐标最近的那个坐标.\n参数定义:\n all_pos 字符串: 坐标描述串。  一般是FindStrEx,FindStrFastEx,FindStrWithFontEx, FindColorEx, FindMultiColorEx,和FindPicEx的返回值.\n type 整形数:  取值为0或者1\n     如果all_pos的内容是由FindPicEx,FindStrEx,FindStrFastEx,FindStrWithFontEx返回，那么取值为0\n     如果all_pos的内容是由FindColorEx, FindMultiColorEx返回，那么取值为1\nx 整形数: 横坐标\n y 整形数: 纵坐标\n返回值:\n 字符串:\n 返回的格式和type有关，如果type为0，那么返回的格式是"id,x,y"\n如果type为1,那么返回的格式是"x,y".\n示例:\nret = dm.FindColorEx(0,0,2000,2000,"aaaaaa-000000",1.0,0)\n ret = dm.FindNearestPos(ret,1,100,100)\n TracePrint ret\nret = dm.FindPicEx(0,0,2000,2000,"a.bmp","000000",1.0,0)\n ret = dm.FindNearestPos(ret,0,100,100)\n TracePrint ret
SortPosDistance(all_pos,type,x,y) = 根据部分Ex接口的返回值，然后对所有坐标根据对指定坐标的距离进行从小到大的排序.\n参数定义:\n all_pos 字符串: 坐标描述串。  一般是FindStrEx,FindStrFastEx,FindStrWithFontEx, FindColorEx, FindMultiColorEx,和FindPicEx的返回值.\n type 整形数:  取值为0或者1\n     如果all_pos的内容是由FindPicEx,FindStrEx,FindStrFastEx,FindStrWithFontEx返回，那么取值为0\n     如果all_pos的内容是由FindColorEx, FindMultiColorEx返回，那么取值为1\nx 整形数: 横坐标\n y 整形数: 纵坐标\n返回值:\n 字符串:\n 返回的格式和type指定的格式一致.\n示例:\nret = dm.FindColorEx(0,0,2000,2000,"aaaaaa-000000",1.0,0)\n ret = dm.SortPosDistance(ret,1,100,100)\n TracePrint ret\nret = dm.FindPicEx(0,0,2000,2000,"a.bmp","000000",1.0,0)\n ret = dm.SortPosDistance(ret,0,100,100)\n TracePrint ret
Beep(f,duration) = 蜂鸣器.\n参数定义:\nf 整形数: 频率\nduration 整形数: 时长(ms).\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm.Beep 1000,1000
CheckFontSmooth() = 检测当前系统是否有开启屏幕字体平滑. <收费功能，具体详情点击查看>\n参数定义:\n返回值:\n 整形数:\n 0 : 系统没开启平滑字体.\n1 : 系统有开启平滑字体.\n示例:\n if dm.CheckFontSmooth () = 1 then\n     TracePrint "当前系统有开启平滑字体"\n end if
CheckUAC() = 检测当前系统是否有开启UAC(用户账户控制).\n参数定义:\n返回值:\n整形数:\n 0 : 没开启UAC\n1 : 开启了UAC\n示例:\n if dm.CheckUAC() = 1 then\n     TracePrint "当前系统开启了用户账户控制"\n end if\n注: 只有WIN7 VISTA WIN2008以及以上系统才有UAC设置
Delay(mis) = 延时指定的毫秒,过程中不阻塞UI操作. 一般高级语言使用.按键用不到. <收费功能，具体详情点击查看>\n参数定义:\nmis整形数: 毫秒数.\n返回值:\n 整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm.Delay 1000\n注: 由于是com组件,调用此函数必须保证调用线程的模型为STA.否则此函数会阻塞当前线程UI.
DisableFontSmooth() = 关闭当前系统屏幕字体平滑.同时关闭系统的ClearType功能. <收费功能，具体详情点击查看>\n参数定义:\n返回值:\n 整形数:\n 0 : 失败\n1 : 成功\n示例:\nif dm.CheckFontSmooth() = 1 then\n    if dm.DisableFontSmooth() = 1 then\n       MessageBox "关闭了当前系统平滑字体,重启生效"\n       dm.ExitOs 2\n       Delay 2000\n       EndScript\n    end if\n end if\n 注: 关闭之后要让系统生效，必须重启系统才有效.
DisablePowerSave() = 关闭电源管理，不会进入睡眠.\n参数定义:\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm.DisablePowerSave\n注 :此函数调用以后，并不会更改系统电源设置. \n 此函数经常用在后台操作过程中. 避免被系统干扰.
DisableScreenSave() = 关闭屏幕保护.\n参数定义:\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm.DisableScreenSave\n注 : 调用此函数后，可能在系统中还是看到屏保是开启状态。但实际上屏保已经失效了.\n系统重启后，会失效。必须再重新调用一次.\n此函数经常用在后台操作过程中. 避免被系统干扰.
ExitOs(type) = 退出系统(注销 重启 关机) \n参数定义:\ntype 整形数: 取值为以下类型\n     0 : 注销系统\n     1 : 关机\n     2 : 重新启动\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm_ret = dm.ExitOs(1)  
GetClipboard() = 获取剪贴板的内容\n参数定义:\n返回值:\n字符串:\n 以字符串表示的剪贴板内容\n示例:\nTracePrint dm.GetClipboard()  
GetDir(type) = 得到系统的路径 \n参数定义:\ntype 整形数: 取值为以下类型\n     0 : 获取当前路径\n     1 : 获取系统路径(system32路径)\n     2 : 获取windows路径(windows所在路径)\n     3 : 获取临时目录路径(temp)\n     4 : 获取当前进程(exe)所在的路径\n返回值:\n字符串:\n 返回路径\n示例:\n path = dm.GetDir(2)  
GetDiskSerial() = 获取本机的硬盘序列号.支持ide scsi硬盘. 要求调用进程必须有管理员权限. 否则返回空串.\n参数定义:\n返回值:\n字符串:\n 字符串表达的硬盘序列号\n示例:\n sirial = dm.GetDiskSerial()
GetMachineCode() = 获取本机的机器码.(带网卡). 此机器码用于插件网站后台. 要求调用进程必须有管理员权限. 否则返回空串.\n参数定义:\n返回值:\n字符串:\n 字符串表达的机器机器码\n示例:\n machine_code = dm.GetMachineCode()\n注: 此机器码包含的硬件设备有硬盘,显卡,网卡等. 其它不便透露. 重装系统不会改变此值.\n另要注意,插拔任何USB设备,(U盘，U盾,USB移动硬盘,USB键鼠等),以及安装任何网卡驱动程序,(开启或者关闭无线网卡等)都会导致机器码改变.  
GetMachineCodeNoMac() = 获取本机的机器码.(不带网卡) 要求调用进程必须有管理员权限. 否则返回空串.\n参数定义:\n返回值:\n字符串:\n 字符串表达的机器机器码\n示例:\n machine_code = dm.GetMachineCodeNoMac()\n注: 此机器码包含的硬件设备有硬盘,显卡,等. 其它不便透露. 重装系统不会改变此值.\n另要注意,插拔任何USB设备,(U盘，U盾,USB移动硬盘,USB键鼠等),都会导致机器码改变.  
GetNetTime() = 从网络获取当前北京时间.\n参数定义:\n返回值:\n字符串:\n 时间格式. 和now返回一致. 比如"2001-11-01 23:14:08"\n示例:\n t = dm.GetNetTime()\n TracePrint "当前北京时间是:"&t  
GetNetTimeSafe() = 从网络获取当前北京时间. 同GetNetTime. 但此接口数据是加密传送,以免被人破解. <收费功能，具体详情点击查看>\n参数定义:\n返回值:\n 字符串:\n 时间格式. 和now返回一致. 比如"2001-11-01 23:14:08"\n示例:\n t = dm.GetNetTimeSafe()\n TracePrint "当前北京时间是:"&t\n 注: 此接口不支持简单游平台.
GetOsType() = 得到操作系统的类型\n参数定义:\n返回值:\n整形数:\n 0 : win95/98/me/nt4.0\n1 : xp/2000\n2 : 2003\n3 : win7/vista/2008\n示例:\n os_type = dm.GetOsType()  
GetScreenDepth() = 获取屏幕的色深. \n参数定义:\n返回值:\n整形数:\n 返回系统颜色深度.(16或者32等)\n示例:\n Depth = dm.GetScreenDepth()  
GetScreenHeight() = 获取屏幕的高度. \n参数定义:\n返回值:\n整形数:\n 返回屏幕的高度\n示例:\n ScreenH = dm.GetScreenHeight()  
GetScreenWidth() = 获取屏幕的宽度. \n参数定义:\n返回值:\n整形数:\n 返回屏幕的宽度\n示例:\n ScreenW = dm.GetScreenWidth()  
GetTime() = 获取当前系统从开机到现在所经历过的时间，单位是毫秒\n参数定义:\n返回值:\n整形数:\n 时间(单位毫秒)\n示例:\n t1 = dm.GetTime()\n dm_ret = dm.FindPic(0,0,2000,2000,"test.bmp","000000",1.0,0,x,y)\n t2 = dm.GetTime()\n MessageBox (t2-t1)  
Is64Bit() = 判断当前系统是否是64位操作系统\n参数定义:\n返回值:\n整形数:\n 0 : 不是64位系统\n 1 : 是64位系统\n示例:\nif dm.Is64Bit() = 1 then\n     MessageBox "64位系统"\n else\n     MessageBox "不是64位系统"\n end if  
Play(media_file) = 播放指定的MP3或者wav文件.\n参数定义:\nmedia_file 字符串: 指定的音乐文件，可以采用文件名或者绝对路径的形式.\n返回值:\n整形数:\n 0 : 失败\n 非0表示当前播放的ID。可以用Stop来控制播放结束.\n示例:\n // test.mp3放于d:\test目录下\n dm.SetPath "d:\test"\n id = dm.Play("test.mp3")  \n// 绝对路径\n id = dm.Play("d:\test\test.mp3")\n Delay 1000\n dm.Stop id
RunApp(app_path,mode) = 运行指定的应用程序. <收费功能，具体详情点击查看>\n参数定义:\napp_path 字符串: 指定的可执行程序全路径.\nmode 整形数: 取值如下\n      0 : 普通模式\n      1 : 加强模式\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm.RunApp "c:\windows\notepad.exe",0\ndm.RunApp "notepad",1
SetClipboard(value) = 设置剪贴板的内容\n参数定义:\nvalue 字符串: 以字符串表示的剪贴板内容\n返回值:\n整形数:\n 0 : 失败\n 1 : 成功\n示例:\n dm.SetClipboard "abcd"  
SetDisplayAcceler(level) = 设置当前系统的硬件加速级别. <收费功能，具体详情点击查看>\n参数定义:\nlevel整形数: 取值范围为0-5.  0表示关闭硬件加速。5表示完全打开硬件加速.\n返回值:\n 整形数:\n 0 : 失败.\n1 : 成功.\n示例:\n// 关闭硬件加速\n TracePrint SetDisplayAcceler(0) \n注: 此函数只在XP 2003系统有效.
SetScreen(width,height,depth) = 设置系统的分辨率 系统色深 \n参数定义:\nwidth 整形数: 屏幕宽度\nheight 整形数: 屏幕高度\ndepth 整形数: 系统色深\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm_ret = dm.SetScreen(1024,768,16)  
SetUAC(enable) = 设置当前系统的UAC(用户账户控制).\n参数定义:\nenable 整形数: 取值如下\n       0 : 关闭UAC\n        1 : 开启UAC\n返回值:\n 整形数:\n 0 : 操作失败\n1 : 操作成功\n示例:\n if dm.SetUAC(0) = 1 then\n     TracePrint "成功关闭了当前系统UAC设置"\n end if\n注: 只有WIN7 VISTA WIN2008以及以上系统才有UAC设置. 关闭UAC以后，必须重启系统才会生效.\n如果关闭了UAC，那么默认启动所有应用程序都是管理员权限，就不会再发生绑定失败这样的尴尬情况了.
Stop(id) = 停止指定的音乐.\n参数定义:\nid 整形数: Play返回的播放id.\n返回值:\n整形数:\n 0 : 失败\n 1 : 成功.\n示例:\n // test.mp3放于d:\test目录下\n dm.SetPath "d:\test"\n id = dm.Play("test.mp3")  \n// 绝对路径\n id = dm.Play("d:\test\test.mp3")\n Delay 1000\n dm.Stop id
GetCursorPos(x,y) = 获取鼠标位置.\n参数定义:\n x 变参指针: 返回X坐标\ny 变参指针: 返回Y坐标\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm.GetCursorPos x,y\n MessageBox x&","&y\n注: 此接口在3.1223版本之后，返回的值的定义修改。  同大多数接口一样,返回的x,y坐标是根据绑定的鼠标参数来决定.  如果绑定了窗口，那么获取的坐标是相对于绑定窗口，否则是屏幕坐标.  \n 另外，此函数获取的坐标是真实的鼠标坐标，对于某些自绘鼠标位置不一定准确。请自行测试.
GetCursorShape() = 获取鼠标特征码. 当BindWindow或者BindWindowEx中的mouse参数含有dx.mouse.cursor时，\n获取到的是后台鼠标特征，否则是前台鼠标特征.   后台特征码是收费功能. <收费功能，具体详情点击查看>.\n参数定义:\n返回值:\n字符串:\n 成功时，返回鼠标特征码.  \n 失败时，返回空的串.\n示例:\n mouse_tz = dm.GetCursorShape()\n If mouse_tz = "7d7160fe" Then\n     MessageBox "找到特征码"\n End If\n注:此接口和GetCursorShapeEx(0)等效. 相当于工具里的方式1获取的特征码. 当此特征码在某些情况下无法区分鼠标形状时，可以考虑使用GetCursorShapeEx(1).\n另要特别注意,WIN7以及以上系统，必须在字体显示设置里把文字大小调整为默认(100%),否则特征码会变.如图所示.
GetCursorShapeEx(int type) = 获取鼠标特征码. 当BindWindow或者BindWindowEx中的mouse参数含有dx.mouse.cursor时，\n获取到的是后台鼠标特征，否则是前台鼠标特征.   后台特征码是收费功能. <收费功能，具体详情点击查看>.\n参数定义:\ntype 整形数:获取鼠标特征码的方式. 和工具中的方式1 方式2对应. 方式1此参数值为0. 方式2此参数值为1.\n返回值:\n字符串:\n 成功时，返回鼠标特征码.  \n 失败时，返回空的串.\n示例:\n mouse_tz = dm.GetCursorShapeEx(0)\n If mouse_tz = "7d7160fe" Then\n     MessageBox "找到特征码"\n End If\n注: 当type为0时，和GetCursorShape等效.\n 另要特别注意,WIN7以及以上系统，必须在字体显示设置里把文字大小调整为默认(100%),否则特征码会变.如图所示.
GetCursorSpot() = 获取鼠标热点位置.(参考工具中抓取鼠标后，那个闪动的点就是热点坐标,不是鼠标坐标)\n当BindWindow或者BindWindowEx中的mouse参数含有dx.mouse.cursor时，\n获取到的是后台鼠标热点位置，否则是前台鼠标热点位置.  后台热点位置是收费功能. <收费功能，具体详情点击查看>.\n参数定义:\n返回值:\n字符串:\n 成功时，返回形如"x,y"的字符串  \n 失败时，返回空的串.\n示例:\n hot_pos = dm.GetCursorSpot()\n if len(hot_pos) > 0 Then\n     hot_pos = split(hot_pos,",")\n     x = int(hot_pos(0))\n     y = int(hot_pos(1))\n end if  
GetKeyState(vk_code) = 获取指定的按键状态.(前台信息,不是后台)\n参数定义:\n vk_code 整形数:虚拟按键码\n返回值:\n整形数:\n 0:弹起\n 1:按下\n示例:\n TracePrint dm.GetKeyState(13)
KeyDown(vk_code) = 按住指定的虚拟键码\n 参数定义:\n vk_code 整形数:虚拟按键码\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.KeyDown 13  
KeyDownChar(key_str) = 按住指定的虚拟键码\n 参数定义:\n key_str 字符串: 字符串描述的键码. 大小写无所谓. 点这里查看具体对应关系.\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.KeyDownChar "enter"\n dm.KeyDownChar "1"\n dm.KeyDownChar "F1"\n dm.KeyDownChar "a"\n dm.KeyDownChar "B"  
KeyPress(vk_code) = 按下指定的虚拟键码\n参数定义:\n vk_code 整形数:虚拟按键码\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.KeyPress 13
KeyPressChar(key_str) = 按下指定的虚拟键码\n参数定义:\n key_str 字符串: 字符串描述的键码. 大小写无所谓. 点这里查看具体对应关系.\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.KeyPressChar "enter"\n dm.KeyPressChar "1"\n dm.KeyPressChar "F1"\n dm.KeyPressChar "a"\n dm.KeyPressChar "B"
KeyPressStr(key_str,delay) = 根据指定的字符串序列，依次按顺序按下其中的字符.   <收费功能，具体详情点击查看>.\n参数定义:\n key_str 字符串: 需要按下的字符串序列. 比如"1234","abcd","7389,1462"等.\ndelay 整形数: 每按下一个按键，需要延时多久. 单位毫秒.这个值越大，按的速度越慢。\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.KeyPressStr "123,456",20\n注: 在某些情况下，SendString和SendString2都无法输入文字时，可以考虑用这个来输入.\n但这个接口只支持"a-z 0-9 ~-=[]\;',./"和空格,其它字符一律不支持.(包括中国)
KeyUp(vk_code) = 弹起来虚拟键vk_code\n参数定义:\n vk_code 整形数:虚拟按键码\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.KeyUp 13
KeyUpChar(key_str) = 弹起来虚拟键key_str\n参数定义:\n key_str 字符串: 字符串描述的键码. 大小写无所谓. 点这里查看具体对应关系.\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.KeyUpChar "enter"\n dm.KeyUpChar "1"\n dm.KeyUpChar "F1"\n dm.KeyUpChar "a"\n dm.KeyUpChar "B"
LeftClick() = 按下鼠标左键\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.LeftClick
LeftDoubleClick() = 双击鼠标左键\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.LeftDoubleClick
LeftDown() = 按住鼠标左键\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.LeftDown
LeftUp() = 弹起鼠标左键\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.LeftUp
MiddleClick() = 按下鼠标中键\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.MiddleClick
MoveR(rx,ry) = 鼠标相对于上次的位置移动rx,ry\n参数定义:\n rx 整形数:相对于上次的X偏移\n ry 整形数:相对于上次的Y偏移\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.MoveR rx,ry  
MoveTo(x,y) = 把鼠标移动到目的点(x,y)\n参数定义:\n x 整形数:X坐标\n y 整形数:Y坐标\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.MoveTo x,y
MoveToEx(x,y,w,h) = 把鼠标移动到目的范围内的任意一点\n参数定义:\n x 整形数:X坐标\n y 整形数:Y坐标\n w 整形数:宽度(从x计算起)\n h 整形数:高度(从y计算起)\n返回值:\n字符串:\n 返回要移动到的目标点. 格式为x,y.  比如MoveToEx 100,100,10,10,返回值可能是101,102\n示例:\n// 移动鼠标到(100,100)到(110,110)这个矩形范围内的任意一点.\n dm.MoveToEx 100,100,10,10\n注: 此函数的意思是移动鼠标到指定的范围(x,y,x+w,y+h)内的任意随机一点.
RightClick() = 按下鼠标右键\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.RightClick
RightDown() = 按住鼠标右键\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.RightDown
RightUp() = 弹起鼠标右键\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.RightUp
SetKeypadDelay(type,delay) = 设置按键时,键盘按下和弹起的时间间隔。高级用户使用。某些窗口可能需要调整这个参数才可以正常按键。\n 参数定义:\n type 字符串: 键盘类型,取值有以下\n     "normal" : 对应normal键盘  默认内部延时为30ms\n     "windows": 对应windows 键盘 默认内部延时为10ms\n     "dx" :     对应dx 键盘 默认内部延时为50ms\ndelay 整形数: 延时,单位是毫秒\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.SetKeypadDelay "dx",10  \n注 : 此函数影响的接口有KeyPress
SetMouseDelay(type,delay) = 设置鼠标单击或者双击时,鼠标按下和弹起的时间间隔。高级用户使用。某些窗口可能需要调整这个参数才可以正常点击。\n 参数定义:\n type 字符串: 鼠标类型,取值有以下\n     "normal" : 对应normal鼠标 默认内部延时为 30ms\n     "windows": 对应windows 鼠标 默认内部延时为 10ms\n     "dx" :     对应dx鼠标 默认内部延时为40ms\ndelay 整形数: 延时,单位是毫秒\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.SetMouseDelay "dx",10  \n注 : 此函数影响的接口有LeftClick RightClick MiddleClick LeftDoubleClick
WaitKey(vk_code,time_out) = 等待指定的按键按下 (前台,不是后台)\n参数定义:\n vk_code 整形数:虚拟按键码\n time_out 整形数:等待多久,单位毫秒. 如果是0，表示一直等待\n返回值:\n整形数:\n 0:超时\n 1:指定的按键按下\n示例:\n dm.WaitKey 66,0
WheelDown() = 滚轮向下滚\n参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.WheelDown
WheelUp() = 滚轮向上滚\n参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.WheelUp
DmGuard(enable,type) = 针对部分检测措施的保护盾.  <收费功能，具体详情点击查看>\n参数定义:\nenable 整形数: 0表示关闭保护盾,1表示打开保护盾.\n type 字符串: 参数具体内容可以是以下任意一个.\n "np" : 这个是防止NP检测.\n "np2" : 在NP下保护后台可以正常运行. (此模式需要加载驱动,目前仅支持32位系统)\n "memory" : 这个保护内存系列接口和汇编接口可以正常运行.(不用带dx.public.memory的情况下)(此模式需要加载驱动,目前仅支持32位系统)\n "phide [pid]" : 保护指定进程不被非法访问. pid为可选参数.如果不指定pid，默认保护当前进程.(此模式需要加载驱动,目前仅支持32位系统)\n 其它后续开发. \n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n dm.DmGuard 1,"np"\n dm.DmGuard 1,"phide"\n dm.DmGuard 1,"phide 1045"\n注 : 此函数最好在目标进程打开之前调用即可。调用一次即可。 尽量保证此函数第一个被执行，以免和其他驱动冲突.

```
