---
title: 大漠插件智能提示（3.1233）
---
免费版：
```
/**intellisense(!dm)
CreateFoobarCustom(hwnd,x,y,pic_name,trans_color,sim) = 根据指定的位图创建一个自定义形状的窗口\n参数定义:\n hwnd 整形数: 指定的窗口句柄,如果此值为0,那么就在桌面创建此窗口\n x 整形数: 左上角X坐标(相对于hwnd客户区坐标)\ny 整形数: 左上角Y坐标(相对于hwnd客户区坐标)\npic_name 字符串: 位图名字\ntrans_color 字符串: 透明色(RRGGBB)\nsim 双精度浮点数: 透明色的相似值 0.1-1.0\n返回值:\n 整形数 : 创建成功的窗口句柄\n示例:\nfoobar = dm.CreateFoobarCustom(hwnd,10,10,"菜单.bmp","FF00FF",1.0)
CreateFoobarEllipse(hwnd,x,y,w,h) = 创建一个椭圆窗口\n参数定义:\n hwnd整形数: 指定的窗口句柄,如果此值为0,那么就在桌面创建此窗口\n x整形数: 左上角X坐标(相对于hwnd客户区坐标)\ny整形数: 左上角Y坐标(相对于hwnd客户区坐标)\nw整形数: 矩形区域的宽度\nh整形数: 矩形区域的高度\n返回值:\n 整形数 : 创建成功的窗口句柄\n示例:\nfoobar = dm.CreateFoobarEllipse(hwnd,10,10,200,200)
CreateFoobarRect(hwnd,x,y,w,h) = 创建一个矩形窗口\n参数定义:\n hwnd整形数: 指定的窗口句柄,如果此值为0,那么就在桌面创建此窗口\n x整形数: 左上角X坐标(相对于hwnd客户区坐标)\ny整形数: 左上角Y坐标(相对于hwnd客户区坐标)\nw整形数: 矩形区域的宽度\nh整形数: 矩形区域的高度\n返回值:\n 整形数 : 创建成功的窗口句柄\n示例:\nfoobar = dm.CreateFoobarRect(hwnd,10,10,200,200)
CreateFoobarRoundRect(hwnd,x,y,w,h,rw,rh) = 创建一个圆角矩形窗口\n参数定义:\n hwnd整形数: 指定的窗口句柄,如果此值为0,那么就在桌面创建此窗口\n x整形数: 左上角X坐标(相对于hwnd客户区坐标)\ny整形数: 左上角Y坐标(相对于hwnd客户区坐标)\nw整形数: 矩形区域的宽度\nh整形数: 矩形区域的高度\nrw整形数: 圆角的宽度\nrh整形数: 圆角的高度\n返回值:\n 整形数 : 创建成功的窗口句柄\n示例:\nfoobar = dm.CreateFoobarRoundRect(hwnd,10,10,200,200,30,30)
FoobarClearText(hwnd) = 清除指定的Foobar滚动文本区\n参数定义:\n hwnd整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\n返回值:\n整形数 :\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarClearText(foobar)
FoobarClose(hwnd) = 关闭一个Foobar,注意,必须调用此函数来关闭窗口,用SetWindowState也可以关闭,但会造成内存泄漏.\n参数定义:\n hwnd整形数: 指定的Foobar窗口句柄\n返回值:\n 整形数:\n 0: 失败\n1: 成功\n示例:\ndm_ret = dm.FoobarClose(foobar)
FoobarDrawPic(hwnd,x,y,pic_name,trans_color) = 在指定的Foobar窗口绘制图像 此图片不能是加密的图片\n参数定义:\n hwnd整形数: 指定的Foobar窗口,注意,此句柄必须是通过CreateFoobarxxxx系列函数创建出来的\n x整形数: 左上角X坐标(相对于hwnd客户区坐标)\ny整形数: 左上角Y坐标(相对于hwnd客户区坐标)\npic_name字符串: 图像文件名\ntrans_color字符串: 图像透明色\n返回值:\n整形数 :\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarDrawPic(foobar,0,0,"menu.bmp","FF0000")
FoobarDrawText(hwnd,x,y,w,h,text,color,align) = 在指定的Foobar窗口绘制文字\n参数定义:\n hwnd整形数: 指定的Foobar窗口,注意,此句柄必须是通过CreateFoobarxxxx系列函数创建出来的\n x整形数: 左上角X坐标(相对于hwnd客户区坐标)\ny整形数: 左上角Y坐标(相对于hwnd客户区坐标)\nw整形数: 矩形区域的宽度\nh整形数: 矩形区域的高度\ntext字符串: 字符串\ncolor字符串: 文字颜色值\nalign 整形数: 取值定义如下\n1 : 左对齐\n2 : 中间对齐\n4 : 右对齐\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarDrawText(foobar,0,0,200,30,"测试","FF0000",1)
FoobarFillRect(hwnd,x1,y1,x2,y2,color) = 在指定的Foobar窗口内部填充矩形\n参数定义:\n hwnd 整形数: 指定的Foobar窗口,注意,此句柄必须是通过CreateFoobarxxxx系列函数创建出来的\n x1 整形数: 左上角X坐标(相对于hwnd客户区坐标)\ny1 整形数: 左上角Y坐标(相对于hwnd客户区坐标)\nx2 整形数: 右下角X坐标(相对于hwnd客户区坐标)\ny2 整形数: 右下角Y坐标(相对于hwnd客户区坐标)\ncolor字符串: 填充的颜色值\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarFillRect(foobar,0,0,200,200,"FF0000")
FoobarLock(hwnd) = 锁定指定的Foobar窗口,不能通过鼠标来移动\n参数定义:\n hwnd整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarLock(foobar)
FoobarPrintText(hwnd,text,color) = 向指定的Foobar窗口区域内输出滚动文字\n参数定义:\n hwnd整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\ntext字符串: 文本内容\ncolor字符串: 文本颜色\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarPrintText(foobar,"大漠测试","ff0000")\n// 用红色文字向滚动区域输出文字信息
FoobarSetFont(hwnd,font_name,size,flag) = 设置指定Foobar窗口的字体\n参数定义:\n hwnd整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\nfont_name字符串: 系统字体名,注意,必须保证系统中有此字体\nsize整形数: 字体大小\nflag整形数: 取值定义如下\n0 : 正常字体\n1 : 粗体\n2 : 斜体\n4 : 下划线\n文字可以是以上的组合 比如粗斜体就是1+2,斜体带下划线就是:2+4等.\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarSetFont(foobar,"宋体",25,2+4)
FoobarSetSave(hwnd,file,enable,header) = 设置保存指定的Foobar滚动文本区信息到文件.\n参数定义:\n hwnd 整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\nfile 字符串: 保存的文件名\nenable 整形数: 取值如下\n              0 : 关闭向文件输出 (默认是0)\n              1 : 开启向文件输出\nheader 字符串: 输出的附加头信息. (比如行数 日期 时间信息) 格式是如下格式串的顺序组合.如果为空串，表示无附加头.\n              "%L0nd%" 表示附加头信息带有行号，并且是按照十进制输出. n表示按多少个十进制数字补0对齐. 比如"%L04d%",输出的行号为0001  0002 0003等. "%L03d",输出的行号为001 002 003..等.\n              "%L0nx%"表示附加头信息带有行号，并且是按照16进制小写输出. n表示按多少个16进制数字补0对齐. 比如"%L04x%",输出的行号为0009  000a 000b等. "%L03x",输出的行号为009 00a 00b..等.\n              "%L0nX%"表示附加头信息带有行号，并且是按照16进制大写输出. n表示按多少个16进制数字补0对齐. 比如"%L04X%",输出的行号为0009  000A 000B等. "%L03X",输出的行号为009 00A 00B..等.\n              "%yyyy%"表示年. 比如2012\n              "%MM%"表示月. 比如12\n              "%dd%"表示日. 比如28\n              "%hh%"表示小时. 比如13\n              "%mm%"表示分钟. 比如59\n              "%ss%"表示秒. 比如48.\n返回值:\n整形数 :\n 0 : 失败\n1 : 成功\n示例:\n// 开启输出，并且按原始信息输出. 无附加头.\n dm.FoobarSetSave foobar,"output.txt",1,""\n// 开启输出，并且按行号信息输出.\n dm.FoobarSetSave foobar,"output.txt",1,"【%L04d%】"\n // 这个输出的信息类似如下\n 【0001】…\n 【0002】…\n 【0003】…\n// 开启输出，并且按年月日的方式输出.\n dm.FoobarSetSave foobar,"output.txt",1,"{%yyyy%-%MM%-%dd%} "\n // 这个输出的信息类似如下\n {2008-01-01} …\n {2008-01-01} …\n {2008-01-01} …\n {2008-01-01} …  \n// 开启输出，并且按时分秒的方式输出.\n dm.FoobarSetSave foobar,"output.txt",1,"{%hh%-%mm%-%ss%} "\n // 这个输出的信息类似如下\n {13-04-45} …\n {13-04-48} …\n {13-04-50} …\n// 开启输出，并且按照行号 时分的方式输出\n dm.FoobarSetSave foobar,"output.txt",1,"[%L03d%] (%hh%-%mm%)"\n // 这个输出的信息类似如下\n [001] (23-16)…\n [002] (23-17)…\n [003] (23-20)…
FoobarTextLineGap(hwnd,line_gap) = 设置滚动文本区的文字行间距,默认是3\n参数定义:\n hwnd 整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\nline_gap 整形数: 文本行间距\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarTextLineGap(foobar,5)
FoobarTextPrintDir(hwnd,dir) = 设置滚动文本区的文字输出方向,默认是0\n参数定义:\n hwnd 整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\ndir 整形数: 0 表示向下输出\n    : 1 表示向上输出\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarTextPrintDir(foobar,1)
FoobarTextRect(hwnd,x,y,w,h) = 设置指定Foobar窗口的滚动文本框范围,默认的文本框范围是窗口区域\n参数定义:\n hwnd 整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\nx 整形数: x坐标\ny 整形数: y坐标\nw 整形数: 宽度\nh 整形数: 高度\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarTextRect(foobar,10,10,100,200)
FoobarUnlock(hwnd) = 解锁指定的Foobar窗口,可以通过鼠标来移动\n参数定义:\n hwnd 整形数: 指定的Foobar窗口句柄,此句柄必须是通过CreateFoobarxxx创建而来\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarUnlock(foobar)
FoobarUpdate(hwnd) = 刷新指定的Foobar窗口\n参数定义:\n hwnd 整形数: 指定的Foobar窗口,注意,此句柄必须是通过CreateFoobarxxxx系列函数创建出来的\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.FoobarUpdate(foobar)\n注意： 所有绘制完成以后,必须通过调用此函数来刷新窗口,否则窗口内容不会改变.
DoubleToData(value) = 把双精度浮点数转换成二进制形式.\n 参数定义:\n value 双精度浮点数: 需要转化的双精度浮点数\n返回值:\n字符串:\n 字符串形式表达的二进制数据. 可以用于WriteData FindData FindDataEx等接口.\n示例:\ndouble_data =  dm.DoubleToData(1.24)\n dm_ret = dm.FindData(hwnd,"00000000-7fffffff",double_data)
FindDouble(hwnd, addr_range, double_value_min, double_value_max) = 搜索指定的双精度浮点数,默认步长是1.如果要定制步长，请用FindDoubleEx\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr_range 字符串: 指定搜索的地址集合，字符串类型，这个地方可以是上次FindXXX的返回地址集合,可以进行二次搜索.(类似CE的再次扫描)\n             如果要进行地址范围搜索，那么这个值为的形如如下(类似于CE的新搜索)\n            "00400000-7FFFFFFF" "80000000-BFFFFFFF" "00000000-FFFFFFFF" 等.\ndouble_value_min 双精度浮点数: 搜索的双精度数值最小值\ndouble_value_max 双精度浮点数: 搜索的双精度数值最大值 \n 最终搜索的数值大与等于double_value_min,并且小于等于double_value_max\n返回值:\n字符串:\n 返回搜索到的地址集合，地址格式如下:\n"addr1|addr2|addr3…|addrn"\n比如"400050|423435|453430"\n示例:\n// 全局搜索\n result = dm.FindDouble(hwnd,"00000000-FFFFFFFF",0.5,1.0)\n if len(result) = 0 then\n      MessageBox "找不到"\n      EndScript\n end if\n result = split(result,"|")\n count = ubound(result)+1\n MessageBox "找到"&count&"个地址"\n 注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。
FindFloat(hwnd, addr_range, float_value_min, float_value_max) = 搜索指定的单精度浮点数,默认步长是1.如果要定制步长，请用FindFloatEx\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr_range 字符串: 指定搜索的地址集合，字符串类型，这个地方可以是上次FindXXX的返回地址集合,可以进行二次搜索.(类似CE的再次扫描)\n             如果要进行地址范围搜索，那么这个值为的形如如下(类似于CE的新搜索)\n            "00400000-7FFFFFFF" "80000000-BFFFFFFF" "00000000-FFFFFFFF" 等.\nfloat_value_min 单精度浮点数: 搜索的单精度数值最小值\nfloat_value_max 单精度浮点数: 搜索的单精度数值最大值 \n 最终搜索的数值大与等于float_value_min,并且小于等于float_value_max\n返回值:\n字符串:\n 返回搜索到的地址集合，地址格式如下:\n"addr1|addr2|addr3…|addrn"\n比如"400050|423435|453430"\n示例:\n// 全局搜索\n result = dm.FindFloat(hwnd,"00000000-FFFFFFFF",0.5,1.0)\n if len(result) = 0 then\n      MessageBox "找不到"\n      EndScript\n end if\n result = split(result,"|")\n count = ubound(result)+1\n MessageBox "找到"&count&"个地址"\n 注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。
FindInt(hwnd, addr_range, int_value_min, int_value_max,type) = 搜索指定的整数,默认步长是1.如果要定制步长，请用FindIntEx\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr_range 字符串: 指定搜索的地址集合，字符串类型，这个地方可以是上次FindXXX的返回地址集合,可以进行二次搜索.(类似CE的再次扫描)\n             如果要进行地址范围搜索，那么这个值为的形如如下(类似于CE的新搜索)\n            "00400000-7FFFFFFF" "80000000-BFFFFFFF" "00000000-FFFFFFFF" 等.\nint_value_min 整形数: 搜索的整数数值最小值\nint_value_max 整形数: 搜索的整数数值最大值 \n 最终搜索的数值大与等于int_value_min,并且小于等于int_value_max\ntype 整形数: 搜索的整数类型,取值如下\n      0 : 32位\n      1 : 16 位\n      2 : 8位\n返回值:\n字符串:\n 返回搜索到的地址集合，地址格式如下:\n"addr1|addr2|addr3…|addrn"\n比如"400050|423435|453430"\n示例:\n// 全局搜索\n result = dm.FindInt(hwnd,"00000000-FFFFFFFF",300,300,0)\n if len(result) = 0 then\n      MessageBox "找不到"\n      EndScript\n end if\n result = split(result,"|")\n count = ubound(result)+1\n MessageBox "找到"&count&"个地址"\n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。  
FindString(hwnd, addr_range, string_value,type) = 搜索指定的字符串,默认步长是1.如果要定制步长，请用FindStringEx\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr_range 字符串: 指定搜索的地址集合，字符串类型，这个地方可以是上次FindXXX的返回地址集合,可以进行二次搜索.(类似CE的再次扫描)\n             如果要进行地址范围搜索，那么这个值为的形如如下(类似于CE的新搜索)\n            "00400000-7FFFFFFF" "80000000-BFFFFFFF" "00000000-FFFFFFFF" 等.\nstring_value 字符串: 搜索的字符串\ntype 整形数: 搜索的字符串类型,取值如下\n      0 : Ascii字符串\n      1 : Unicode字符串\n返回值:\n字符串:\n 返回搜索到的地址集合，地址格式如下:\n"addr1|addr2|addr3…|addrn"\n比如"400050|423435|453430"\n示例:\n// 全局搜索\n result = dm.FindString(hwnd,"00000000-FFFFFFFF","哈哈哈哈",0)\n if len(result) = 0 then\n      MessageBox "找不到"\n      EndScript\n end if\n result = split(result,"|")\n count = ubound(result)+1\n MessageBox "找到"&count&"个地址"\n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。  
FloatToData(value) = 把单精度浮点数转换成二进制形式.\n 参数定义:\n value 单精度浮点数: 需要转化的单精度浮点数\n返回值:\n字符串:\n 字符串形式表达的二进制数据. 可以用于WriteData FindData FindDataEx等接口.\n示例:\nfloat_data =  dm.FloatToData(1.24)\n dm_ret = dm.FindData(hwnd,"00000000-7fffffff",float_data)
GetModuleBaseAddr(hwnd,module) = 根据指定的窗口句柄，来获取对应窗口句柄进程下的指定模块的基址\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\nmodule 字符串: 模块名\n返回值:\n整形数:\n 模块的基址\n示例:\nbase_addr = dm.GetModuleBaseAddr(hwnd,"gdi32.dll")\n MessageBox  base_addr  \n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。
IntToData(value,type) = 把整数转换成二进制形式.\n 参数定义:\n value 整形数: 需要转化的整型数\n type  整形数: 取值如下:\n             0: 4字节整形数 (一般都选这个)\n             1: 2字节整形数\n             2: 1字节整形数\n返回值:\n字符串:\n 字符串形式表达的二进制数据. 可以用于WriteData FindData FindDataEx等接口.\n示例:\nint_data =  dm.IntToData(&H12345678,0)\n dm_ret = dm.FindData(hwnd,"00000000-7fffffff",int_data)
ReadData(hwnd,addr,len) = 读取指定地址的二进制数据\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\nlen 整形数: 二进制数据的长度\n返回值:\n字符串:\n 读取到的数值,以16进制表示的字符串 每个字节以空格相隔 比如"12 34 56 78 ab cd ef"\n示例:\nvalue = dm.ReadData(hwnd,"4DA678",10)\n MessageBox  value  \n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。
ReadDouble(hwnd,addr) = 读取指定地址的双精度浮点数\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\n返回值:\n双精度浮点数:\n 读取到的数值,注意这里无法判断读取是否成功\n示例:\nvalue = dm.ReadDouble(hwnd,"4DA678")\n MessageBox  value  \n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。
ReadFloat(hwnd,addr) = 读取指定地址的单精度浮点数\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\n返回值:\n单精度浮点数:\n 读取到的数值,注意这里无法判断读取是否成功\n示例:\nvalue = dm.ReadFloat(hwnd,"4DA678")\n MessageBox  value  \n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。
ReadInt(hwnd,addr,type) = 读取指定地址的整数数值，类型可以是8位，16位 或者 32位\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\ntype 整形数: 整数类型,取值如下\n      0 : 32位\n      1 : 16 位\n      2 : 8位\n返回值:\n整形数:\n 读取到的数值,注意这里无法判断读取是否成功\n示例:\nvalue = dm.ReadInt(hwnd,"4DA678",0)\n MessageBox  value  \n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。
ReadString(hwnd,addr,type,len) = 读取指定地址的字符串，可以是GBK字符串或者是Unicode字符串.(必须事先知道内存区的字符串编码方式)\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\ntype 整形数: 字符串类型,取值如下\n      0 : GBK字符串\n      1 : Unicode字符串\nlen 整形数: 需要读取的字节数目.\n返回值:\n字符串:\n 读取到的字符串,注意这里无法判断读取是否成功\n示例:\nvalue = dm.ReadString(hwnd,"4DA678",0,10)\n MessageBox  value  \n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。
StringToData(value,type) = 把字符串转换成二进制形式.\n 参数定义:\n value字符串: 需要转化的字符串\n type  整形数: 取值如下:\n             0: 返回Ascii表达的字符串\n             1: 返回Unicode表达的字符串\n返回值:\n字符串:\n 字符串形式表达的二进制数据. 可以用于WriteData FindData FindDataEx等接口.\n示例:\nstring_data =  dm.StringToData("12345678",1)\n dm_ret = dm.FindData(hwnd,"00000000-7fffffff",string_data)
WriteData(hwnd,addr,data) = 对指定地址写入二进制数据\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\ndata 字符串: 二进制数据，以字符串形式描述，比如"12 34 56 78 90 ab cd"\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.WriteData(hwnd,"4DA678","12 34 56 78 90 ab cd")\n 注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。\n注: 简单游平台不支持此接口
WriteDouble(hwnd,addr,v) = 对指定地址写入双精度浮点数\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\nv 双精度浮点数: 双精度浮点数\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.WriteDouble(hwnd,"4DA678",2.34)\n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。\n注: 简单游平台不支持此接口
WriteFloat(hwnd,addr,v) = 对指定地址写入单精度浮点数\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\nv 单精度浮点数: 单精度浮点数\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.WriteFloat(hwnd,"4DA678",2.34)\n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。\n注: 简单游平台不支持此接口
WriteInt(hwnd,addr,type,v) = 对指定地址写入整数数值，类型可以是8位，16位 或者 32位\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\ntype 整形数: 整数类型,取值如下\n      0 : 32位\n      1 : 16 位\n      2 : 8位\nv 整形数: 整形数值\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.WriteInt(hwnd,"4DA678",0,100)\n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。  \n注: 简单游平台不支持此接口
WriteString(hwnd,addr,type,v) = 对指定地址写入字符串，可以是Ascii字符串或者是Unicode字符串\n 参数定义:\n hwnd 整形数: 指定搜索的窗口句柄或者进程ID.  默认是窗口句柄. 如果要指定为进程ID,需要调用SetMemoryHwndAsProcessId.\naddr 字符串: 用字符串来描述地址，类似于CE的地址描述，数值必须是16进制,里面可以用[ ] + -这些符号来描述一个地址。+表示地址加，-表示地址减\n        模块名必须用<>符号来圈起来\n      例如:\n 1.         "4DA678" 最简单的方式，用绝对数值来表示地址\n 2.         "<360SE.exe>+DA678" 相对简单的方式，只是这里用模块名来决定模块基址，后面的是偏移\n 3.         "[4DA678]+3A" 用绝对数值加偏移，相当于一级指针\n 4.         "[<360SE.exe>+DA678]+3A" 用模块定基址的方式，也是一级指针\n 5.         "[[[<360SE.exe>+DA678]+3A]+5B]+8" 这个是一个三级指针\n 总之熟悉CE的人 应该对这个地址描述都很熟悉,我就不多举例了\ntype 整形数: 字符串类型,取值如下\n      0 : Ascii字符串\n      1 : Unicode字符串\nv 字符串: 字符串\n返回值:\n整形数:\n 0: 失败\n1: 成功\n示例:\ndm_ret = dm.WriteString(hwnd,"4DA678",0,"我是来测试的")\n注: 如果目标窗口的绑定属性中有dx.public.memory,并且是用本对象来绑定的，那么操作方式是直接进入目标进程读写.\n dx.public.memory可突破部分窗口读写保护. 如果正常方式无法读写,可以尝试此属性。另外DmGuard中的memory护盾也可以突破部分窗口内存保护，可以尝试使用。\n注: 简单游平台不支持此接口
DownCpu(rate) = 降低目标窗口所在进程的CPU占用\n 参数定义:\n rate 整形数: 取值范围0到100   取值为0 表示关闭CPU优化. 这个值越大表示降低CPU效果越好.\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n dm_ret = dm.BindWindowEx(hwnd,"dx.graphic.3d","normal","normal","",0)\n dm.DownCpu 50\n注意: 此接口必须在绑定窗口成功以后调用，而且必须保证目标窗口可以支持dx.graphic.3d或者dx.graphic.3d.8或者dx.graphic.2d或者dx.graphic.2d.2方式截图，否则降低CPU无效.\n因为降低CPU是通过降低窗口刷新速度来实现，所以注意，开启此功能以后会导致窗口刷新速度变慢.  
EnableIme(enable) = 设置是否关闭绑定窗口所在进程的输入法.\n 参数定义:\n enable 整形数: 1 开启\n 0 关闭\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n// 绑定为后台\n dm_ret = dm.BindWindow(hwnd,"dx","dx","dx",101)\n …\n // 关闭输入法\n dm.EnableIme 0 \n …\n // 再开启输入法\n dm.EnableIme 1\n注: 此函数必须在绑定后调用才有效果.
EnableSpeedDx(enable) = 设置是否开启高速dx键鼠模式。 默认是关闭.\n 参数定义:\n enable 整形数: 0 关闭\n 1 开启\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm.EnableSpeedDx 1\n注: 此函数开启的后果就是，所有dx键鼠操作将不会等待，适用于某些特殊的场合(比如避免窗口无响应导致宿主进程也卡死的问题).\n EnableMouseSync和EnableKeyboardSync开启以后，此函数就无效了.\n 此函数可能在部分窗口下会有副作用，谨慎使用!!
LockInput(lock) = 禁止外部输入到指定窗口\n 参数定义:\n lock 整形数: 0关闭锁定\n        1 开启锁定(键盘鼠标都锁定)\n        2 只锁定鼠标\n        3 只锁定键盘\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n dm_ret = dm.BindWindow(hwnd,"dx","dx2","dx",0)\n dm.LockInput 1\n // 这里做需要锁定输入做的事情\n dm.LockInput 0\n注意:此接口只针对dx键鼠. 普通键鼠无效. \n 有时候，绑定为dx2 鼠标模式时(或者没有锁定鼠标位置或状态时)，在脚本处理过程中，在某个时候需要临时锁定外部输入，以免外部干扰，那么这个函数就非常有用.\n 比如某个信息，需要鼠标移动到某个位置才可以获取，但这时，如果外部干扰，那么很可能就会获取失败，所以，这时候就很有必要锁定外部输入. \n 当然，锁定完以后，记得要解除锁定，否则外部永远都无法输入了，除非解除了窗口绑定.
LockMouseRect(x1,y1,x2,y2) = 设置前台鼠标在屏幕上的活动范围.\n 参数定义:\nx1 整形数:区域的左上X坐标. 屏幕坐标.\n y1 整形数:区域的左上Y坐标. 屏幕坐标.\n x2 整形数:区域的右下X坐标. 屏幕坐标.\n y2 整形数:区域的右下Y坐标. 屏幕坐标.\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n// 限制鼠标只能在10,10,800,600区域内活动.\n dm.LockMouseRect 10,10,800,600\n …\n Sub OnScriptExit()\n     // 恢复,4个参数都是0,表示恢复鼠标活动范围为整个屏幕区域.\n     dm.LockMouseRect 0,0,0,0\n End Sub\n注: 调用此函数后，一旦有窗口切换或者窗口移动的动作，那么限制立刻失效.\n 如果想一直限制鼠标范围在指定的窗口客户区域，那么你需要启动一个线程，并且时刻监视当前活动窗口，然后根据情况调用此函数限制鼠标范围.
SetDisplayDelay(time) = 设置dx截图最长等待时间。内部默认是3000毫秒. 一般用不到调整这个.\n 参数定义:\n time  整形数: 等待时间，单位是毫秒。 注意这里不能设置的过小，否则可能会导致截图失败,从而导致图色函数和文字识别失败.\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm.SetDisplayDelay 500\n 注: 此接口仅对 图色为dx.graphic.3d   dx.graphic.3d.8  dx.graphic.2d   dx.graphic.2d.2有效. 其他图色模式无效.\n 默认情况下，截图需要等待一个延时，超时就认为截图失败. 这个接口可以调整这个延时. 某些时候或许有用.比如当窗口图色卡死(这时获取图色一定都是超时)，并且要判断窗口卡死，那么这个设置就很有用了。
UnBindWindow() = 解除绑定窗口,并释放系统资源.一般在OnScriptExit调用\n 参数定义:\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n Sub OnScriptExit()\n     dm_ret = dm.UnBindWindow() \n End Sub
AppendPicAddr(pic_info,addr,size) = 对指定的数据地址和长度，组合成新的参数. FindPicMem FindPicMemE 以及FindPicMemEx专用\n参数定义:\npic_info 字符串: 老的地址描述串\naddr 整形数: 数据地址\nsize 整形数: 数据长度\n返回值:\n 字符串:\n 新的地址描述串\n示例:\npic_info = ""\n pic_info = dm.AppendPicAddr(pic_info,12034,643)\n pic_info = dm.AppendPicAddr(pic_info,328435,8935)\n pic_info = dm.AppendPicAddr(pic_info,809234,789) 
BGR2RGB(bgr_color) = 把BGR(按键格式)的颜色格式转换为RGB\n参数定义:\n bgr_color 字符串:bgr格式的颜色字符串\n返回值:\n字符串:\n RGB格式的字符串\n示例:\n rgb_color = dm.BGR2RGB(bgr_color)
Capture(x1, y1, x2, y2, file) = 抓取指定区域(x1, y1, x2, y2)的图像,保存为file(24位位图)\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n file 字符串:保存的文件名,保存的地方一般为SetPath中设置的目录\n     当然这里也可以指定全路径名.\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm_ret = dm.Capture(0,0,2000,2000,"screen.bmp")
CaptureGif(x1, y1, x2, y2, file,delay,time) = 抓取指定区域(x1, y1, x2, y2)的动画，保存为gif格式\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n file 字符串:保存的文件名,保存的地方一般为SetPath中设置的目录\n     当然这里也可以指定全路径名.\n delay 整形数: 动画间隔，单位毫秒。 如果为0，表示只截取静态图片\n time 整形数: 总共截取多久的动画，单位毫秒。\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n// 截取动画\n dm_ret = dm.CaptureGif(0,0,2000,2000,"screen.gif",100,3000)\n // 截取静态\n dm_ret = dm.CaptureGif(0,0,2000,2000,"screen.gif",0,0)
CaptureJpg(x1, y1, x2, y2, file, quality) = 抓取指定区域(x1, y1, x2, y2)的图像,保存为file(JPG压缩格式)\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n file 字符串:保存的文件名,保存的地方一般为SetPath中设置的目录\n     当然这里也可以指定全路径名.\n quality 整形数: jpg压缩比率(1-100) 越大图片质量越好\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm_ret = dm.CaptureJpg(0,0,2000,2000,"screen.jpg",50)
CapturePng(x1,y1,x2,y2,file) = 同Capture函数，只是保存的格式为PNG.\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n file 字符串:保存的文件名,保存的地方一般为SetPath中设置的目录\n     当然这里也可以指定全路径名.  \n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm_ret = dm.CapturePng(0,0,2000,2000,"screen.png")
CapturePre(file) = 抓取上次操作的图色区域，保存为file(24位位图)\n参数定义:\n file 字符串:保存的文件名,保存的地方一般为SetPath中设置的目录\n     当然这里也可以指定全路径名.\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm_ret = dm.CapturePre("screen.bmp")\n注意，要开启此函数，必须先调用EnableDisplayDebug\n 任何图色或者文字识别函数，都可以通过这个来截取. 具体可以查看常见问题中"本机文字识别正常,别的机器为何不正常"这一节.
CmpColor(x,y,color,sim) = 比较指定坐标点(x,y)的颜色\n参数定义:\nx 整形数: X坐标\ny 整形数: Y坐标\ncolor 字符串: 颜色字符串,可以支持偏色,多色,例如 "ffffff-202020|000000-000000" 这个表示白色偏色为202020,和黑色偏色为000000.颜色最多支持10种颜色组合. 注意，这里只支持RGB颜色.\nsim 双精度浮点数: 相似度(0.1-1.0)\n返回值:\n整形数:\n 0: 颜色匹配\n 1: 颜色不匹配\n示例:\ndm_ret = dm.CmpColor(200,300,"000000-000000|ff00ff-101010",0.9)\n If dm_ret = 0 Then\n     MessageBox "相等" \n End If 
EnableDisplayDebug(enable_debug) = 开启图色调试模式，此模式会稍许降低图色和文字识别的速度.默认不开启.\n参数定义:\n enable_debug 整形数: 0 为关闭\n               1 为开启\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.EnableDisplayDebug 1\n dm_ret = dm.CapturePre("screen.bmp")
EnableGetColorByCapture(enable) = 允许调用GetColor GetColorBGR GetColorHSV 以及 CmpColor时，以截图的方式来获取颜色。\n参数定义:\nenable 整形数: 0 关闭\n         1 打开\n返回值:\n整形数:\n 0 : 失败\n 1 : 成功\n示例:\n dm.EnableGetColorByCapture 1\n TracePrint dm.GetColor(300,300)\n注 : 某些窗口上，可能GetColor会获取不到颜色，可以尝试此接口.
FindColor(x1, y1, x2, y2, color, sim, dir,intX,intY) = 查找指定区域内的颜色,颜色格式"RRGGBB-DRDGDB",注意,和按键的颜色格式相反\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n color 字符串:颜色 格式为"RRGGBB-DRDGDB",比如"123456-000000|aabbcc-202020".注意，这里只支持RGB颜色.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 \n              1: 从左到右,从下到上 \n              2: 从右到左,从上到下 \n              3: 从右到左,从下到上 \n              4：从中心往外查找\n              5: 从上到下,从左到右 \n              6: 从上到下,从右到左\n              7: 从下到上,从左到右\n              8: 从下到上,从右到左\n intX 变参指针:返回X坐标\n intY 变参指针:返回Y坐标\n 返回值: \n整形数:\n 0:没找到\n 1:找到\n示例:\n dm_ret = dm.FindColor(0,0,2000,2000,"123456-000000|aabbcc-030303|ddeeff-202020",1.0,0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n     MessageBox "找到"\n End If
FindColorE(x1, y1, x2, y2, color, sim, dir) = 查找指定区域内的颜色,颜色格式"RRGGBB-DRDGDB",注意,和按键的颜色格式相反\n易语言用不了FindColor可以用此接口来代替\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n color 字符串:颜色 格式为"RRGGBB-DRDGDB",比如"123456-000000|aabbcc-202020".注意，这里只支持RGB颜色.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 \n              1: 从左到右,从下到上 \n              2: 从右到左,从上到下 \n              3: 从右到左,从下到上 \n              4：从中心往外查找\n              5: 从上到下,从左到右 \n              6: 从上到下,从右到左\n              7: 从下到上,从左到右\n              8: 从下到上,从右到左\n 返回值: \n字符串:\n 返回X和Y坐标 形式如"x|y", 比如"100|200"\n示例:\n pos = dm.FindColorE(0,0,2000,2000,"123456-000000|aabbcc-030303|ddeeff-202020",1.0,0)\n pos = split(pos,"|")\n If int(pos(0)) > 0 Then\n     MessageBox "找到"\n End If
FindColorEx(x1, y1, x2, y2, color, sim, dir) = 查找指定区域内的所有颜色,颜色格式"RRGGBB-DRDGDB",注意,和按键的颜色格式相反\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n color 字符串:颜色 格式为"RRGGBB-DRDGDB" 比如"aabbcc-000000|123456-202020".注意，这里只支持RGB颜色.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 \n              1: 从左到右,从下到上 \n              2: 从右到左,从上到下 \n              3: 从右到左,从下到上 \n              5: 从上到下,从左到右 \n              6: 从上到下,从右到左\n              7: 从下到上,从左到右\n              8: 从下到上,从右到左  \n 返回值: \n字符串:\n 返回所有颜色信息的坐标值,然后通过GetResultCount等接口来解析 (由于内存限制,返回的颜色数量最多为1800个左右)\n示例:\n s = dm.FindColorEx(0,0,2000,2000,"123456-000000|abcdef-202020",1.0,0)\n count = dm.GetResultCount(s)\n index = 0\n Do While index < count\n     dm_ret = dm.GetResultPos(s,index,intX,intY)\n     MessageBox intX&","&intY \n     index = index + 1 \n Loop 
FindMultiColor(x1, y1, x2, y2,first_color,offset_color,sim, dir,intX,intY) = 根据指定的多点查找颜色坐标\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n first_color 字符串:颜色 格式为"RRGGBB-DRDGDB",比如"123456-000000"\n 这里的含义和按键自带Color插件的意义相同，只不过我的可以支持偏色\n 所有的偏移色坐标都相对于此颜色.注意，这里只支持RGB颜色.\n offset_color 字符串: 偏移颜色 可以支持任意多个点 格式和按键自带的Color插件意义相同\n  格式为"x1|y1|RRGGBB-DRDGDB,……xn|yn|RRGGBB-DRDGDB"\n 比如"1|3|aabbcc,-5|-3|123456-000000"等任意组合都可以，支持偏色\n 还可以支持反色模式，比如"1|3|-aabbcc,-5|-3|-123456-000000","-"表示除了指定颜色之外的颜色.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 1: 从左到右,从下到上 2: 从右到左,从上到下 3: 从右到左, 从下到上\n intX 变参指针:返回X坐标(坐标为first_color所在坐标)\n intY 变参指针:返回Y坐标(坐标为first_color所在坐标)\n 返回值: \n整形数:\n 0:没找到\n 1:找到\n示例:\n dm_ret = dm.FindMultiColor(0,0,2000,2000,"cc805b-020202","9|2|-00ff00,15|2|2dff1c-010101,6|11|a0d962,11|14|-ffffff",1.0,1,intX,intY)\n dm.MoveTo intX,intY
FindMultiColorE(x1, y1, x2, y2,first_color,offset_color,sim, dir) = 根据指定的多点查找颜色坐标\n易语言用不了FindMultiColor可以用此接口来代替\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n first_color 字符串:颜色 格式为"RRGGBB-DRDGDB",比如"123456-000000"\n 这里的含义和按键自带Color插件的意义相同，只不过我的可以支持偏色\n 所有的偏移色坐标都相对于此颜色.注意，这里只支持RGB颜色.\n offset_color 字符串: 偏移颜色 可以支持任意多个点 格式和按键自带的Color插件意义相同\n  格式为"x1|y1|RRGGBB-DRDGDB,……xn|yn|RRGGBB-DRDGDB"\n 比如"1|3|aabbcc,-5|-3|123456-000000"等任意组合都可以，支持偏色\n 还可以支持反色模式，比如"1|3|-aabbcc,-5|-3|-123456-000000","-"表示除了指定颜色之外的颜色.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 1: 从左到右,从下到上 2: 从右到左,从上到下 3: 从右到左, 从下到上  \n 返回值: \n字符串:\n 返回X和Y坐标 形式如"x|y", 比如"100|200"\n示例:\n pos = dm.FindMultiColorE(0,0,2000,2000,"cc805b-020202","9|2|-00ff00,15|2|-2dff1c-010101,6|11|a0d962,11|14|-ffffff",1.0,1)\n pos = split(pos,"|")\n dm.MoveTo int(pos(0)),int(pos(1))
FindMultiColorEx(x1, y1, x2, y2,first_color,offset_color,sim, dir) = 根据指定的多点查找所有颜色坐标\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n first_color 字符串:颜色 格式为"RRGGBB-DRDGDB",比如"123456-000000"\n 这里的含义和按键自带Color插件的意义相同，只不过我的可以支持偏色\n 所有的偏移色坐标都相对于此颜色.注意，这里只支持RGB颜色.\n offset_color 字符串: 偏移颜色 可以支持任意多个点 格式和按键自带的Color插件意义相同\n  格式为"x1|y1|RRGGBB-DRDGDB,……xn|yn|RRGGBB-DRDGDB"\n 比如"1|3|aabbcc,-5|-3|123456-000000"等任意组合都可以，支持偏色\n 还可以支持反色模式，比如"1|3|-aabbcc,-5|-3|-123456-000000","-"表示除了指定颜色之外的颜色\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 1: 从左到右,从下到上 2: 从右到左,从上到下 3: 从右到左, 从下到上  \n 返回值: \n字符串:\n 返回所有颜色信息的坐标值,然后通过GetResultCount等接口来解析(由于内存限制,返回的坐标数量最多为1800个左右)\n坐标是first_color所在的坐标\n示例:\n dm_ret = dm.FindMultiColorEx(0,0,2000,2000,"cc805b-020202","9|2|-00ff00,15|2|2dff1c-010101,6|11|a0d962,11|14|-ffffff",1.0,1)\n count = dm.GetResultCount(dm_ret)\n index = 0\n Do While index < count \n    aa = dm.GetResultPos(dm_ret,index,intX,intY)\n    dm.MoveTo intX,intY\n    index = index + 1\n    Delay  1000\n Loop
FindPic(x1, y1, x2, y2, pic_name, delta_color,sim, dir,intX, intY) = 查找指定区域内的图片,位图必须是24位色格式,支持透明色,当图像上下左右4个顶点的颜色一样时,则这个颜色将作为透明色处理.\n这个函数可以查找多个图片,只返回第一个找到的X Y坐标.\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n pic_name 字符串:图片名,可以是多个图片,比如"test.bmp|test2.bmp|test3.bmp"\n delta_color 字符串:颜色色偏 比如"203040" 表示RGB的色偏分别是20 30 40 (这里是16进制表示)\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 1: 从左到右,从下到上 2: 从右到左,从上到下 3: 从右到左, 从下到上\n intX 变参指针:返回图片左上角的X坐标\n intY 变参指针:返回图片左上角的Y坐标\n返回值:\n整形数:\n 返回找到的图片的序号,从0开始索引.如果没找到返回-1\n示例:\n dm_ret = dm.FindPic(0,0,2000,2000,"1.bmp|2.bmp|3.bmp","000000",0.9,0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n     MessageBox "找到"\n End If
FindPicE(x1, y1, x2, y2, pic_name, delta_color,sim, dir) = 查找指定区域内的图片,位图必须是24位色格式,支持透明色,当图像上下左右4个顶点的颜色一样时,则这个颜色将作为透明色处理.\n这个函数可以查找多个图片,只返回第一个找到的X Y坐标.\n易语言用不了FindPic可以用此接口来代替\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n pic_name 字符串:图片名,可以是多个图片,比如"test.bmp|test2.bmp|test3.bmp"\n delta_color 字符串:颜色色偏 比如"203040" 表示RGB的色偏分别是20 30 40 (这里是16进制表示)\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 1: 从左到右,从下到上 2: 从右到左,从上到下 3: 从右到左, 从下到上\n返回值:\n 字符串:\n 返回找到的图片序号(从0开始索引)以及X和Y坐标 形式如"index|x|y", 比如"3|100|200"\n示例:\n pos = dm.FindPicE(0,0,2000,2000,"1.bmp|2.bmp|3.bmp","000000",0.9,0)\n pos = split(pos,"|")\n If int(pos(1)) > 0 Then\n     MessageBox "找到"\n End If
FindPicEx(x1, y1, x2, y2, pic_name, delta_color,sim, dir) = 查找指定区域内的图片,位图必须是24位色格式,支持透明色,当图像上下左右4个顶点的颜色一样时,则这个颜色将作为透明色处理.\n这个函数可以查找多个图片,并且返回所有找到的图像的坐标.\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n pic_name 字符串:图片名,可以是多个图片,比如"test.bmp|test2.bmp|test3.bmp"\n delta_color 字符串:颜色色偏 比如"203040" 表示RGB的色偏分别是20 30 40 (这里是16进制表示)\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n dir 整形数:查找方向 0: 从左到右,从上到下 1: 从左到右,从下到上 2: 从右到左,从上到下 3: 从右到左, 从下到上\n返回值:\n字符串:\n 返回的是所有找到的坐标格式如下:"id,x,y|id,x,y..|id,x,y" (图片左上角的坐标)\n比如"0,100,20|2,30,40" 表示找到了两个,第一个,对应的图片是图像序号为0的图片,坐标是(100,20),第二个是序号为2的图片,坐标(30,40)\n (由于内存限制,返回的图片数量最多为1500个左右)\n示例:\n dm_ret = dm.FindPicEx(0,0,2000,2000,"test.bmp|test2.bmp|test3.bmp|test4.bmp|test5.bmp","020202",1.0,0)\n If len(dm_ret) > 0 Then\n    ss = split(dm_ret,"|")\n    index = 0\n    count = UBound(ss) + 1\n    Do While index < count\n       TracePrint ss(index)\n       sss = split(ss(index),",")\n       id = int(sss(0))\n       x = int(sss(1))\n       y = int(sss(2))\n       dm.MoveTo x,y\n       Delay 1000\n       index = index+1\n    Loop\n End If
FreePic(pic_name) = 释放指定的图片,此函数不必要调用,除非你想节省内存.\n参数定义:\n pic_name 字符串: 文件名 比如"1.bmp|2.bmp|3.bmp" 等,可以使用通配符,比如\n          "*.bmp" 这个对应了所有的bmp文件\n          "a?c*.bmp" 这个代表了所有第一个字母是a 第三个字母是c 第二个字母任意的所有bmp文件\n          "abc???.bmp|1.bmp|aa??.bmp" 可以这样任意组合.\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n PutAttachment "c:\test","*.bmp"\n dm_ret = dm.SetPath("c:\test")\nall_pic = "1.bmp|2.bmp|3.bmp"\n dm_ret = dm.LoadPic(all_pic)\ndm_ret = dm.FreePic(all_pic)
GetAveHSV(x1,y1,x2,y2) = 获取范围(x1,y1,x2,y2)颜色的均值,返回格式"H.S.V"\n参数定义:\n x1 整形数: 左上角X\ny1 整形数: 左上角Y\nx2 整形数: 右下角X\ny2 整形数: 右下角Y\n返回值:\n字符串:\n 颜色字符串\n示例:\n color = dm.GetAveHSV(30,30,100,100)\n MessageBox color
GetAveRGB(x1,y1,x2,y2) = 获取范围(x1,y1,x2,y2)颜色的均值,返回格式"RRGGBB"\n参数定义:\n x1 整形数: 左上角X\ny1 整形数: 左上角Y\nx2 整形数: 右下角X\ny2 整形数: 右下角Y\n返回值:\n字符串:\n 颜色字符串\n示例:\n color = dm.GetAveRGB(30,30,100,100)\n MessageBox color
GetColor(x,y) = 获取(x,y)的颜色,颜色返回格式"RRGGBB",注意,和按键的颜色格式相反\n参数定义:\n x 整形数:X坐标\n y 整形数:Y坐标\n返回值:\n字符串:\n 颜色字符串(注意这里都是小写字符，和工具相匹配)\n示例:\n color = dm.GetColor(30,30)\n If color = "ffffff" Then\n      MessageBox "是白色"\n End If
GetColorBGR(x,y) = 获取(x,y)的颜色,颜色返回格式"BBGGRR"\n参数定义:\n x 整形数:X坐标\n y 整形数:Y坐标\n返回值:\n字符串:\n 颜色字符串(注意这里都是小写字符，和工具相匹配)\n示例:\n color = dm.GetColorBGR(30,30)\n If color = "0000ff" Then\n       MessageBox "是红色"\n End If
GetColorHSV(x,y) = 获取(x,y)的HSV颜色,颜色返回格式"H.S.V"\n参数定义:\n x 整形数:X坐标\n y 整形数:Y坐标\n返回值:\n字符串:\n 颜色字符串\n示例:\n color = dm.GetColorHSV(30,30)\n If color = "100.20.20" Then\n       MessageBox "ok"\n End If
GetColorNum(x1, y1, x2, y2, color, sim) = 获取指定区域的颜色数量,颜色格式"RRGGBB-DRDGDB",注意,和按键的颜色格式相反\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n color 字符串:颜色 格式为"RRGGBB-DRDGDB",比如"123456-000000|aabbcc-202020".注意，这里只支持RGB颜色.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n 返回值: \n整形数:\n 颜色数量\n示例:\n TracePrint dm.GetColorNum(0,0,2000,2000,"123456-000000|aabbcc-030303|ddeeff-202020",1.0)  
GetPicSize(pic_name) = 获取指定图片的尺寸，如果指定的图片已经被加入缓存，则从缓存中获取信息.\n 此接口也会把此图片加入缓存. \n参数定义:\n pic_name 字符串: 文件名 比如"1.bmp"\n返回值:\n字符串:\n 形式如 "w,h" 比如"30,20"\n示例:\n PutAttachment "c:\test","*.bmp"\n dm_ret = dm.SetPath("c:\test")\npic_size = dm.GetPicSize("1.bmp")\n pic_size = split(pic_size,",")\n w = int(pic_size(0))\n h = int(pic_size(1))\n Trace "宽度:"&w\n Trace "高度:"&h
GetScreenData(x1,y1,x2,y2) = 获取指定区域的图像,用二进制数据的方式返回,（不适合按键使用）方便二次开发.\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n返回值:\n整形数:\n 返回的是指定区域的二进制颜色数据地址,每个颜色是4个字节,表示方式为(00RRGGBB)\n示例:\n无示例,开发者都懂的。\n注意,调用完此接口后，返回的数据指针在当前dm对象销毁时，或者再次调用GetScreenData时，会自动释放.\n从2.1120版本之后，调用完此函数后，没必要再调用FreenScreenData了,插件会自动释放.
ImageToBmp(pic_name,bmp_name) = 转换图片格式为24位BMP格式.\n参数定义:\npic_name 字符串: 要转换的图片名\n bmp_name 字符串: 要保存的BMP图片名 \n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm.ImageToBmp "1.png","1.bmp"\n dm.ImageToBmp "2.jpg","2.bmp"\n dm.ImageToBmp "3.gif","3.bmp"
IsDisplayDead(x1,y1,x2,y2,t) = 判断指定的区域，在指定的时间内(秒),图像数据是否一直不变.(卡屏).\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n t  整形数:需要等待的时间,单位是秒 \n返回值:\n整形数:\n 0 : 没有卡屏，图像数据在变化.\n 1 : 卡屏. 图像数据在指定的时间内一直没有变化.\n示例:\n TracePrint dm.IsDisplayDead(0,0,100,100,5)\n注:此函数的原理是不停的截取指定区域的图像，然后比较，如果改变就立刻返回0,否则等待直到指定的时间到达.
LoadPic(pic_name) = 预先加载指定的图片,这样在操作任何和图片相关的函数时,将省去了加载图片的时间。调用此函数后,没必要一定要调用FreePic,插件自己会自动释放.\n另外,此函数不是必须调用的,所有和图形相关的函数只要调用过一次，图片会自动加入缓存.\n如果想对一个已经加入缓存的图片进行修改，那么必须先用FreePic释放此图片在缓存中占用\n的内存，然后重新调用图片相关接口，就可以重新加载此图片. \n参数定义:\n pic_name 字符串: 文件名 比如"1.bmp|2.bmp|3.bmp" 等,可以使用通配符,比如\n          "*.bmp" 这个对应了所有的bmp文件\n          "a?c*.bmp" 这个代表了所有第一个字母是a 第三个字母是c 第二个字母任意的所有bmp文件\n          "abc???.bmp|1.bmp|aa??.bmp" 可以这样任意组合.\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n PutAttachment "c:\test","*.bmp"\n dm_ret = dm.SetPath("c:\test")\nall_pic = "abc???.bmp|1.bmp|aa??.bmp"\n dm_ret = dm.LoadPic(all_pic)
MatchPicName(pic_name) = 根据通配符获取文件集合. 方便用于FindPic和FindPicEx\n参数定义:\n pic_name 字符串: 文件名 比如"1.bmp|2.bmp|3.bmp" 等,可以使用通配符,比如\n          "*.bmp" 这个对应了所有的bmp文件\n          "a?c*.bmp" 这个代表了所有第一个字母是a 第三个字母是c 第二个字母任意的所有bmp文件\n          "abc???.bmp|1.bmp|aa??.bmp" 可以这样任意组合.\n返回值:\n字符串:\n 返回的是通配符对应的文件集合，每个图片以|分割\n示例:\n PutAttachment "c:\test","*.bmp"\n dm_ret = dm.SetPath("c:\test")\nall_pic = "abc*.bmp"\n pic_name = dm.MatchPicName(all_pic)\n// 比如c:\test目录下有abc001.bmp abc002.bmp abc003.bmp\n// 那么pic_name 的值为abc001.bmp|abc002.bmp|abc003.bmp
RGB2BGR(rgb_color) = 把RGB的颜色格式转换为BGR(按键格式)\n参数定义:\n rgb_color 字符串:rgb格式的颜色字符串\n返回值:\n字符串:\n BGR格式的字符串\n示例:\n bgr_color = dm.RGB2BGR(rgb_color)
SetPicPwd(pwd) = 设置图片密码，如果图片本身没有加密，那么此设置不影响不加密的图片，一样正常使用.\n参数定义:\n pwd 字符串: 图片密码\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm_ret = dm.SetPicPwd("123")\n注意,此函数必须在使用图片之前调用.
GetBasePath() = 获取注册在系统中的dm.dll的路径.\n参数定义:\n 返回值:\n字符串:\n 返回dm.dll所在路径\n示例:\n base_path = dm.GetBasePath()\n MessageBox base_path
GetID() = 返回当前大漠对象的ID值，这个值对于每个对象是唯一存在的。可以用来判定两个大漠对象是否一致.\n参数定义:\n返回值:\n整形数:\n 当前对象的ID值.\n示例:\n TracePrint dm.GetID()
GetPath() = 获取全局路径.(可用于调试)\n参数定义:\n返回值:\n字符串:\n 以字符串的形式返回当前设置的全局路径\n示例:\n path = dm.GetPath()\n MessageBox path
Reg(reg_code,ver_info) = 非简单游平台使用，调用此函数来注册，从而使用插件的高级功能.推荐使用此函数.\n参数定义:\n reg_code 字符串: 注册码. (从大漠插件后台获取)\nver_info 字符串: 版本附加信息. 可以在后台详细信息查看. 可以任意填写. 可留空. 长度不能超过10. 并且只能包含数字和字母以及小数点. 这个版本信息不是插件版本.\n返回值:\n整形数:\n -1 : 无法连接网络,(可能防火墙拦截,如果可以正常访问大漠插件网站，那就可以肯定是被防火墙拦截)\n -2 : 进程没有以管理员方式运行. (出现在win7 vista 2008.建议关闭uac)\n 0 : 失败 (未知错误)\n 1 : 成功\n 2 : 余额不足\n 3 : 绑定了本机器，但是账户余额不足50元.\n 4 : 注册码错误\n 5 : 你的机器或者IP在黑名单列表中或者不在白名单列表中.\n -8 : 版本附加信息长度超过了10\n -9 : 版本附加信息里包含了非法字母.\n 空 : 这是不可能返回空的，如果出现空，那肯定是当前使用的版本不对,老的插件里没这个函数导致返回为空.最好参考文档中的标准写法,判断插件版本号.\n示例:\n dm_ret = dm.Reg("abcdefg","")\n if dm_ret <> 1 then\n     MessageBox "注册失败,只能使用免费功能"\n end if\n 注: 简单游平台调用此函数，不会有任何效果. 也不会扣费.\n注册码在大漠插件后台可以查看.\n此函数每个进程调用一次即可，不需要每个DM对象都调用.\n必须保证此函数在创建完对象以后立即调用，尤其必须在绑定窗口之前调用，否则可能会出现异常.\n如果有多个进程操作同个窗口，必须保证每个进程要么都调用Reg,要么都不要调用Reg，以免出现异常.
RegEx(reg_code,ver_info,ip) = 非简单游平台使用，调用此函数来注册，从而使用插件的高级功能. 可以根据指定的IP列表来注册. 新手不建议使用!\n参数定义:\n reg_code 字符串: 注册码. (从大漠插件后台获取)\nver_info 字符串: 版本附加信息. 可以在后台详细信息查看.可留空. 长度不能超过10. 并且只能包含数字和字母以及小数点. 这个版本信息不是插件版本.\nip 字符串: 插件注册的ip地址.可以用|来组合,依次对ip中的地址进行注册，直到成功. ip地址列表在VIP群中获取.\n返回值:\n整形数:\n -1 : 无法连接网络,(可能防火墙拦截,如果可以正常访问大漠插件网站，那就可以肯定是被防火墙拦截)\n -2 : 进程没有以管理员方式运行. (出现在win7 vista 2008.建议关闭uac)\n 0 : 失败 (未知错误)\n 1 : 成功\n 2 : 余额不足\n 3 : 绑定了本机器，但是账户余额不足50元.\n 4 : 注册码错误\n 5 : 你的机器或者IP在黑名单列表中或者不在白名单列表中.\n -8 : 版本附加信息长度超过了10\n -9 : 版本附加信息里包含了非法字母.\n -10 : 非法的参数ip\n 空 : 这是不可能返回空的，如果出现空，那肯定是当前使用的版本不对,老的插件里没这个函数导致返回为空.最好参考文档中的标准写法,判断插件版本号.\n示例:\n// 严重注意,这个例子的IP只是示例，实际并无效。真实IP要去VIP群里获取.\n dm_ret = dm.RegEx("abcdefg","0001","123.45.4.6|78.79.26.3")\n if dm_ret <> 1 then\n     MessageBox "注册失败,只能使用免费功能"\n end if\n 注: 简单游平台调用此函数，不会有任何效果. 也不会扣费.\n注册码在大漠插件后台可以查看.\n此函数每个进程调用一次即可，不需要每个DM对象都调用.\n必须保证此函数在创建完对象以后立即调用，尤其必须在绑定窗口之前调用，否则可能会出现异常.\n如果有多个进程操作同个窗口，必须保证每个进程要么都调用RegEx,要么都不要调用RegEx，以免出现异常.
RegExNoMac(reg_code,ver_info,ip) = 非简单游平台使用，调用此函数来注册，从而使用插件的高级功能. 可以根据指定的IP列表来注册.新手不建议使用! 此函数同RegEx函数的不同在于,此函数用于注册的机器码是不带mac地址的.\n参数定义:\n reg_code 字符串: 注册码. (从大漠插件后台获取)\nver_info 字符串: 版本附加信息. 可以在后台详细信息查看.可留空. 长度不能超过10. 并且只能包含数字和字母以及小数点. 这个版本信息不是插件版本.\nip 字符串: 插件注册的ip地址.可以用|来组合,依次对ip中的地址进行注册，直到成功. ip地址列表在VIP群中获取.\n返回值:\n整形数:\n -1 : 无法连接网络,(可能防火墙拦截,如果可以正常访问大漠插件网站，那就可以肯定是被防火墙拦截)\n -2 : 进程没有以管理员方式运行. (出现在win7 vista 2008.建议关闭uac)\n 0 : 失败 (未知错误)\n 1 : 成功\n 2 : 余额不足\n 3 : 绑定了本机器，但是账户余额不足50元.\n 4 : 注册码错误\n 5 : 你的机器或者IP在黑名单列表中或者不在白名单列表中.\n -8 : 版本附加信息长度超过了10\n -9 : 版本附加信息里包含了非法字母.\n -10 : 非法的参数ip\n 空 : 这是不可能返回空的，如果出现空，那肯定是当前使用的版本不对,老的插件里没这个函数导致返回为空.最好参考文档中的标准写法,判断插件版本号.\n示例:\n// 严重注意,这个例子的IP只是示例，实际并无效。真实IP要去VIP群里获取.\n dm_ret = dm.RegExNoMac("abcdefg","0001","123.45.4.6|78.79.26.3")\n if dm_ret <> 1 then\n     MessageBox "注册失败,只能使用免费功能"\n end if\n 注: 简单游平台调用此函数，不会有任何效果. 也不会扣费.\n注册码在大漠插件后台可以查看.\n此函数每个进程调用一次即可，不需要每个DM对象都调用.\n必须保证此函数在创建完对象以后立即调用，尤其必须在绑定窗口之前调用，否则可能会出现异常.\n如果有多个进程操作同个窗口，必须保证每个进程要么都调用RegExNoMac,要么都不要调用RegExNoMac，以免出现异常.
RegNoMac(reg_code,ver_info) = 非简单游平台使用，调用此函数来注册，从而使用插件的高级功能.推荐使用此函数. 新手不建议使用! 此函数同Reg函数的不同在于,此函数用于注册的机器码是不带mac地址的.\n参数定义:\n reg_code 字符串: 注册码. (从大漠插件后台获取)\nver_info 字符串: 版本附加信息. 可以在后台详细信息查看. 可以任意填写. 可留空. 长度不能超过10. 并且只能包含数字和字母以及小数点. 这个版本信息不是插件版本.\n返回值:\n整形数:\n -1 : 无法连接网络,(可能防火墙拦截,如果可以正常访问大漠插件网站，那就可以肯定是被防火墙拦截)\n -2 : 进程没有以管理员方式运行. (出现在win7 vista 2008.建议关闭uac)\n 0 : 失败 (未知错误)\n 1 : 成功\n 2 : 余额不足\n 3 : 绑定了本机器，但是账户余额不足50元.\n 4 : 注册码错误\n 5 : 你的机器或者IP在黑名单列表中或者不在白名单列表中.\n -8 : 版本附加信息长度超过了10\n -9 : 版本附加信息里包含了非法字母.\n 空 : 这是不可能返回空的，如果出现空，那肯定是当前使用的版本不对,老的插件里没这个函数导致返回为空.最好参考文档中的标准写法,判断插件版本号.\n示例:\n dm_ret = dm.RegNoMac("abcdefg","")\n if dm_ret <> 1 then\n     MessageBox "注册失败,只能使用免费功能"\n end if\n 注: 简单游平台调用此函数，不会有任何效果. 也不会扣费.\n注册码在大漠插件后台可以查看.\n此函数每个进程调用一次即可，不需要每个DM对象都调用.\n必须保证此函数在创建完对象以后立即调用，尤其必须在绑定窗口之前调用，否则可能会出现异常.\n如果有多个进程操作同个窗口，必须保证每个进程要么都调用RegNoMac,要么都不要调用RegNoMac，以免出现异常.
SetDisplayInput(mode) =  设定图色的获取方式，默认是显示器或者后台窗口(具体参考BindWindow)\n参数定义:\n mode 字符串: 图色输入模式 取值有以下几种\n 1.     "screen" 这个是默认的模式，表示使用显示器或者后台窗口\n 2.     "pic:file" 指定输入模式为指定的图片,如果使用了这个模式，则所有和图色相关的函数\n 均视为对此图片进行处理，比如文字识别 查找图片 颜色 等等一切图色函数.\n 需要注意的是，设定以后，此图片就已经加入了缓冲，如果更改了源图片内容，那么需要\n 释放此缓冲，重新设置.\n返回值:\n整形数:\n 0: 失败\n1: 成功\n示例:\n // 设定为默认的模式\n dm_ret = dm.SetDisplayInput("screen")\n// 设定为图片模式 图片采用相对路径模式 相对于SetPath的路径\n dm_ret = dm.SetDisplayInput("pic:test.bmp")\n// 设为图片模式 图片采用绝对路径模式\n dm_ret = dm.SetDisplayInput("pic:d:\test\test.bmp")\n// 设为图片模式 但是每次设置前 先清除缓冲\n dm_ret = dm.FreePic("test.bmp")\n dm_ret = dm.SetDisplayInput("pic:test.bmp")  
SetPath(path) = 设置全局路径,设置了此路径后,所有接口调用中,相关的文件都相对于此路径. 比如图片,字库等.\n参数定义:\n path 字符串: 路径,可以是相对路径,也可以是绝对路径\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\n // 以下代码把全局路径设置到了c盘根目录\n dm_ret = dm.SetPath("c:\")\n// 如下是把全局路径设置到了相对于当前exe所在的路径\n dm.SetPath ".\MyData"\n // 以上，如果exe在c:\test\a.exe 那么，就相当于把路径设置到了c:\test\MyData
SetShowErrorMsg (show) = 设置是否弹出错误信息,默认是打开.\n参数定义:\nshow 整形数: 0表示不打开,1表示打开\n 返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\ndm_ret = dm.SetShowErrorMsg(0)  
Ver() = 返回当前插件版本号\n参数定义:\n返回值:\n字符串:\n 当前插件的版本描述字符串\n示例:\n // 返回版本号\n ver = dm.Ver()\n MessageBox ver
CopyFile(src_file,dst_file,over) = 拷贝文件. \n参数定义:\nsrc_file 字符串: 原始文件名\ndst_file 字符串: 目标文件名.\nover整形数: 取值如下,\n             0 : 如果dst_file文件存在则不覆盖返回.\n             1 : 如果dst_file文件存在则覆盖.\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n // 绝对路径\n dm.CopyFile "c:\123.txt","d:\456.txt",1\n // 相对路径\n dm.SetPath "c:\test_game"\n dm.CopyFile "123.txt","456.txt",1
CreateFolder(folder) = 创建指定目录. \n参数定义:\nfolder 字符串: 目录名\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n dm.CreateFolder "c:\123\456\789"
DeleteFile(file) = 删除文件. \n参数定义:\nfile 字符串: 文件名\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n // 绝对路径\n dm.DeleteFile "c:\123.txt"\n // 相对路径\n dm.SetPath "c:\test_game"\n dm.DeleteFile "123.txt"
DeleteFolder(folder) = 删除指定目录. \n参数定义:\nfolder 字符串: 目录名\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n dm.DeleteFolder "c:\123"
DeleteIni(section,key,file) = 删除指定的ini小节.  \n参数定义:\nsection 字符串: 小节名\nkey 字符串: 变量名. 如果这个变量为空串，则删除整个section小节.\nfile 字符串: ini文件名.\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n // 绝对路径\n dm.DeleteIni "Global","var1" ,"c:\test_game\cfg.ini"\n // 相对路径\n dm.SetPath "c:\test_game"\n dm.DeleteIni "Global","" ,"cfg.ini"\n注 : 此函数是多线程安全的. 多线程同时读写同个文件不会造成文件错乱.
DownloadFile(url,save_file,timeout) = 从internet上下载一个文件. \n参数定义:\nurl 字符串: 下载的url地址.\nsave_file 字符串: 要保存的文件名.\ntimeout整形数: 连接超时时间，单位是毫秒.\n返回值:\n 整形数:\n 1 : 成功\n -1 : 网络连接失败\n -2 : 写入文件失败\n示例:\n dm.DownloadFile "www.sohu.com","sohu.html",3000\ndm.DownloadFile "http://www.sohu.com","d:\sohu.html",3000
GetFileLength(file) = 获取指定的文件长度. \n参数定义:\nfile 字符串: 文件名\n返回值:\n 整形数:\n 文件长度(字节数)\n示例:\n // 绝对路径\n TracePrint dm.GetFileLength("c:\123.txt")\n // 相对路径\n dm.SetPath "c:\test_game"\n TracePrint dm.GetFileLength("123.txt")
IsFileExist(file) = 判断指定文件是否存在. \n参数定义:\nfile 字符串: 文件名\n返回值:\n 整形数:\n 0 : 不存在\n 1 : 存在\n示例:\n // 绝对路径\n TracePrint dm.IsFileExist("c:\123.txt")\n // 相对路径\n dm.SetPath "c:\test_game"\n TracePrint dm.IsFileExist("123.txt")
MoveFile(src_file,dst_file) = 移动文件. \n参数定义:\nsrc_file 字符串: 原始文件名\ndst_file 字符串: 目标文件名.\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n // 绝对路径\n dm.MoveFile "c:\123.txt","d:\456.txt"\n // 相对路径\n dm.SetPath "c:\test_game"\n dm.MoveFile "123.txt","456.txt"
ReadFile(file) = 从指定的文件读取内容. \n参数定义:\nfile 字符串: 文件\n返回值:\n 字符串:\n 读入的文件内容\n示例:\n // 绝对路径\n TracePrint dm.ReadFile("c:\123.txt")\n // 相对路径\n dm.SetPath "c:\test_game"\n TracePrint dm.ReadFile("123.txt")
ReadIni(section,key,file) = 从Ini中读取指定信息. \n参数定义:\nsection 字符串: 小节名\nkey 字符串: 变量名.\nfile 字符串: ini文件名.\n返回值:\n 字符串:\n 字符串形式表达的读取到的内容\n示例:\n // 绝对路径\n Text = dm.ReadIni("Global","var1","c:\test_game\cfg.ini")\n // 相对路径\n dm.SetPath "c:\test_game"\n Text = dm.ReadIni("Global","var1","cfg.ini")\n注 : 此函数是多线程安全的. 多线程同时读写同个文件不会造成文件错乱.
SelectDirectory() = 弹出选择文件夹对话框，并返回选择的文件夹.\n参数定义:\n返回值:\n 字符串:\n 选择的文件夹全路径\n示例:\nTracePrint dm.SelectDirectory()
SelectFile() = 弹出选择文件对话框，并返回选择的文件.\n参数定义:\n返回值:\n 字符串:\n 选择的文件全路径\n示例:\nTracePrint dm.SelectFile()
WriteFile(file,content) = 向指定文件追加字符串. \n参数定义:\nfile 字符串: 文件\ncontent 字符串: 写入的字符串.\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n // 绝对路径\n dm.WriteFile "c:\123.txt","哈哈哈"\n // 相对路径\n dm.SetPath "c:\test_game"\n dm.WriteFile "123.txt","哈哈哈"
WriteIni(section,key,value,file) = 向指定的Ini写入信息.  \n参数定义:\nsection 字符串: 小节名\nkey 字符串: 变量名.\nvalue 字符串: 变量内容\nfile 字符串: ini文件名.\n返回值:\n 整形数:\n 0 : 失败\n 1 : 成功\n示例:\n // 绝对路径\n dm.WriteIni "Global","var1","123","c:\test_game\cfg.ini"\n // 相对路径\n dm.SetPath "c:\test_game"\n dm.WriteIni "Global","var1","123","cfg.ini"\n注 : 此函数是多线程安全的. 多线程同时读写同个文件不会造成文件错乱.
AddDict(index,dict_info) = 给指定的字库中添加一条字库信息.\n参数定义:\nindex 整形数:字库的序号,取值为0-9,目前最多支持10个字库\n dict_info 字符串:字库描述串，具体参考大漠综合工具中的字符定义\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.AddDict(0,"081101BF8020089FD10A21443F85038$记$0.0$11")  \n注意: 此函数尽量在小字库中使用，大字库中使用AddDict速度比较慢\n另，此函数是向指定的字库所在的内存中添加,而不是往文件中添加. 添加以后立刻就可以用于文字识别。无须再SetDict\n如果要保存添加进去的字库信息，需要调用SaveDict
ClearDict(index) = 清空指定的字库.\n参数定义:\nindex 整形数:字库的序号,取值为0-9,目前最多支持10个字库\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.ClearDict 0\n注意: 此函数尽量在小字库中使用，大字库中使用AddDict速度比较慢\n另外，此函数支持清空内存中的字库，而不是字库文件本身.
FetchWord(x1, y1, x2, y2, color, word) = 根据指定的范围,以及指定的颜色描述，提取点阵信息，类似于大漠工具里的单独提取.\n参数定义:\n x1 整形数:左上角X坐标\ny1 整形数:左上角Y坐标\nx2 整形数:右下角X坐标\ny2 整形数:右下角Y坐标\ncolor 字符串: 颜色格式串.注意，RGB和HSV格式都支持.\nword 字符串: 待定义的文字,不能为空，且不能为关键符号"$"\n返回值:\n字符串:\n 识别到的点阵信息，可用于AddDict\n 如果失败，返回空\n示例:\n info = dm.FetchWord(200,200,250,220,"abcdef-101010|ffffff-101010","张三")\n If len(info) > 0 Then\n     dm.AddDict 3,info\n End if\ninfo = dm.FetchWord(200,200,250,220,"b@abcdef-101010|ffffff-101010","李四")\n If len(info) > 0 Then\n     dm.AddDict 2,info\n End if\ninfo = dm.FetchWord(200,200,250,220,"b@0.100.100-0.0.0","张三")\n If len(info) > 0 Then\n     dm.AddDict 4,info\n End if\ninfo = dm.FetchWord(200,200,250,220,"0.100.100-0.0.0|100.0.0-0.0.0","王")\n If len(info) > 0 Then\n     dm.AddDict 4,info\n End if
FindStr(x1,y1,x2,y2,string,color_format,sim,intX,intY) = 在屏幕范围(x1,y1,x2,y2)内,查找string(可以是任意个字符串的组合),并返回符合color_format的坐标位置,相似度sim同Ocr接口描述.\n(多色,差色查找类似于Ocr接口,不再重述)\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串,可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例 .注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n intX 变参指针:返回X坐标 没找到返回-1\n intY 变参指针:返回Y坐标 没找到返回-1\n返回值:\n整形数:\n 返回字符串的索引 没找到返回-1, 比如"长安|洛阳",若找到长安，则返回0\n示例:\n dm_ret = dm.FindStr(0,0,2000,2000,"长安","9f2e3f-000000",1.0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\ndm_ret = dm.FindStr(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",1.0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\n// 查找时,对多行文本进行换行,换行分隔符是"|". 语法是在","后增加换行字符串.任意字符串都可以.\n dm_ret = dm.FindStr(0,0,2000,2000,"长安|洛阳","9f2e3f-000000,|",1.0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\n注: 此函数的原理是先Ocr识别，然后再查找。所以速度比FindStrFast要慢，尤其是在字库\n 很大，或者模糊度不为1.0时。\n一般字库字符数量小于100左右，模糊度为1.0时，用FindStr要快一些,否则用FindStrFast.
FindStrE(x1,y1,x2,y2,string,color_format,sim) = 在屏幕范围(x1,y1,x2,y2)内,查找string(可以是任意个字符串的组合),并返回符合color_format的坐标位置,相似度sim同Ocr接口描述.\n(多色,差色查找类似于Ocr接口,不再重述)\n易语言用不了FindStr可以用此接口来代替\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串, 可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0  \n返回值:\n字符串:\n 返回字符串序号以及X和Y坐标,形式如"id|x|y", 比如"0|100|200",没找到时，id和X以及Y均为-1，"-1|-1|-1"\n示例:\n pos = dm.FindStrE(0,0,2000,2000,"长安","9f2e3f-000000",1.0)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\npos = dm.FindStrE(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",1.0)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\n// 查找时,对多行文本进行换行,换行分隔符是"|". 语法是在","后增加换行字符串.任意字符串都可以.\n pos = dm.FindStrE(0,0,2000,2000,"长安|洛阳","9f2e3f-000000,|",1.0)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\n注: 此函数的原理是先Ocr识别，然后再查找。所以速度比FindStrFastE要慢，尤其是在字库\n 很大，或者模糊度不为1.0时。\n一般字库字符数量小于100左右，模糊度为1.0时，用FindStrE要快一些,否则用FindStrFastE.
FindStrEx(x1,y1,x2,y2,string,color_format,sim) = 在屏幕范围(x1,y1,x2,y2)内,查找string(可以是任意字符串的组合),并返回符合color_format的所有坐标位置,相似度sim同Ocr接口描述.\n(多色,差色查找类似于Ocr接口,不再重述)\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串, 可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n返回值:\n字符串:\n 返回所有找到的坐标集合,格式如下:\n "id,x0,y0|id,x1,y1|......|id,xn,yn"\n 比如"0,100,20|2,30,40" 表示找到了两个,第一个,对应的是序号为0的字符串,坐标是(100,20),第二个是序号为2的字符串,坐标(30,40)\n 示例:\n dm_ret = dm.FindStrEx(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",1.0)\n If len(dm_ret) > 0 Then\n    ss = split(dm_ret,"|")\n    index = 0\n    count = UBound(ss) + 1\n    Do While index < count\n       TracePrint ss(index)\n       sss = split(ss(index),",")\n       id = int(sss(0))\n       x = int(sss(1))\n       y = int(sss(2))\n       dm.MoveTo x,y\n       Delay 1000\n       index = index+1\n    Loop\n End If  \n注: 此函数的原理是先Ocr识别，然后再查找。所以速度比FindStrExFast要慢，尤其是在字库\n 很大，或者模糊度不为1.0时。\n一般字库字符数量小于100左右，模糊度为1.0时，用FindStrEx要快一些,否则用FindStrFastEx.
FindStrFast(x1,y1,x2,y2,string,color_format,sim,intX,intY) = 同FindStr。\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串,可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n intX 变参指针:返回X坐标 没找到返回-1\n intY 变参指针:返回Y坐标 没找到返回-1\n返回值:\n整形数:\n 返回字符串的索引 没找到返回-1, 比如"长安|洛阳",若找到长安，则返回0\n示例:\n dm_ret = dm.FindStrFast(0,0,2000,2000,"长安","9f2e3f-000000",1.0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\ndm_ret = dm.FindStrFast(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",0.9,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\n// 查找时,对多行文本进行换行,换行分隔符是"|". 语法是在","后增加换行字符串.任意字符串都可以.\n dm_ret = dm.FindStrFast(0,0,2000,2000,"长安|洛阳","9f2e3f-000000,|",0.9,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\n注: 此函数比FindStr要快很多，尤其是在字库很大时，或者模糊识别时，效果非常明显。\n 推荐使用此函数。\n 另外由于此函数是只识别待查找的字符，所以可能会有如下情况出现问题。\n比如 字库中有"张和三" 一共3个字符数据，然后待识别区域里是"张和三",如果用FindStr查找\n "张三"肯定是找不到的，但是用FindStrFast却可以找到，因为"和"这个字符没有列入查找计划中\n 所以，在使用此函数时，也要特别注意这一点。
FindStrFastE(x1,y1,x2,y2,string,color_format,sim) = 同FindStrE\n易语言用不了FindStrFast可以用此接口来代替\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串, 可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0  \n返回值:\n字符串:\n 返回字符串序号以及X和Y坐标,形式如"id|x|y", 比如"0|100|200",没找到时，id和X以及Y均为-1，"-1|-1|-1"\n示例:\n pos = dm.FindStrFastE(0,0,2000,2000,"长安","9f2e3f-000000",1.0)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\npos = dm.FindStrFastE(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",0.9)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\n// 查找时,对多行文本进行换行,换行分隔符是"|". 语法是在","后增加换行字符串.任意字符串都可以.\n pos = dm.FindStrFastE(0,0,2000,2000,"长安|洛阳","9f2e3f-000000,|",0.9)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\n注: 此函数比FindStrE要快很多，尤其是在字库很大时，或者模糊识别时，效果非常明显。\n 推荐使用此函数。\n另外由于此函数是只识别待查找的字符，所以可能会有如下情况出现问题。\n比如 字库中有"张和三" 一共3个字符数据，然后待识别区域里是"张和三",如果用FindStrE查找\n "张三"肯定是找不到的，但是用FindStrFastE却可以找到，因为"和"这个字符没有列入查找计划中\n 所以，在使用此函数时，也要特别注意这一点。
FindStrFastEx(x1,y1,x2,y2,string,color_format,sim) = 同FindStrEx\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串, 可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n返回值:\n字符串:\n 返回所有找到的坐标集合,格式如下:\n "id,x0,y0|id,x1,y1|......|id,xn,yn"\n 比如"0,100,20|2,30,40" 表示找到了两个,第一个,对应的是序号为0的字符串,坐标是(100,20),第二个是序号为2的字符串,坐标(30,40)\n 示例:\n dm_ret = dm.FindStrFastEx(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",0.9)\n If len(dm_ret) > 0 Then\n    ss = split(dm_ret,"|")\n    index = 0\n    count = UBound(ss) + 1\n    Do While index < count\n       TracePrint ss(index)\n       sss = split(ss(index),",")\n       id = int(sss(0))\n       x = int(sss(1))\n       y = int(sss(2))\n       dm.MoveTo x,y\n       Delay 1000\n       index = index+1\n    Loop\n End If  \n注: 此函数比FindStrEx要快很多，尤其是在字库很大时，或者模糊识别时，效果非常明显。\n 推荐使用此函数。\n另外由于此函数是只识别待查找的字符，所以可能会有如下情况出现问题。\n比如 字库中有"张和三" 一共3个字符数据，然后待识别区域里是"张和三",如果用FindStrEx查找\n "张三"肯定是找不到的，但是用FindStrFastEx却可以找到，因为"和"这个字符没有列入查找计划中\n 所以，在使用此函数时，也要特别注意这一点。
FindStrWithFont(x1,y1,x2,y2,string,color_format,sim,font_name,font_size,flag,intX,intY) = 同FindStr，但是不使用SetDict设置的字库，而利用系统自带的字库，速度比FindStr稍慢.\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串,可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例 .注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n font_name 字符串:系统字体名,比如"宋体"\n font_size 整形数:系统字体尺寸，这个尺寸一定要以大漠综合工具获取的为准.如果获取尺寸看视频教程.\n flag 整形数:字体类别 取值可以是以下值的组合,比如1+2+4+8,2+4. 0表示正常字体.\n     1 : 粗体\n     2 : 斜体\n     4 : 下划线\n     8 : 删除线\n intX 变参指针:返回X坐标 没找到返回-1\n intY 变参指针:返回Y坐标 没找到返回-1\n返回值:\n整形数:\n 返回字符串的索引 没找到返回-1, 比如"长安|洛阳",若找到长安，则返回0\n示例:\n dm_ret = dm.FindStrWithFont(0,0,2000,2000,"长安","9f2e3f-000000",1.0,"宋体",9,0,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\ndm_ret = dm.FindStrWithFont(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",1.0,"宋体",9,1+2,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\n// 查找时,对多行文本进行换行,换行分隔符是"|". 语法是在","后增加换行字符串.任意字符串都可以.\n dm_ret = dm.FindStrWithFont(0,0,2000,2000,"长安|洛阳","9f2e3f-000000,|",1.0,"宋体",9,1+2,intX,intY)\n If intX >= 0 and intY >= 0 Then\n      dm.MoveTo intX,intY\n End If\n注: 对于如何获取字体尺寸以及名字等信息，可以参考视频教程，如何使用系统字库.
FindStrWithFontE(x1,y1,x2,y2,string,color_format,sim,font_name,font_size,flag) = 同FindStrE，但是不使用SetDict设置的字库，而利用系统自带的字库，速度比FindStrE稍慢\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串, 可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n font_name 字符串:系统字体名,比如"宋体"\n font_size 整形数:系统字体尺寸，这个尺寸一定要以大漠综合工具获取的为准.如果获取尺寸看视频教程.\n flag 整形数:字体类别 取值可以是以下值的组合,比如1+2+4+8,2+4. 0表示正常字体.\n     1 : 粗体\n     2 : 斜体\n     4 : 下划线\n     8 : 删除线  \n返回值:\n字符串:\n 返回字符串序号以及X和Y坐标,形式如"id|x|y", 比如"0|100|200",没找到时，id和X以及Y均为-1，"-1|-1|-1"\n示例:\n pos = dm.FindStrWithFontE(0,0,2000,2000,"长安","9f2e3f-000000",1.0,"宋体",9,0)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\npos = dm.FindStrWithFontE(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",1.0,"宋体",9,1+2)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\n// 查找时,对多行文本进行换行,换行分隔符是"|". 语法是在","后增加换行字符串.任意字符串都可以.\n pos = dm.FindStrWithFontE(0,0,2000,2000,"长安|洛阳","9f2e3f-000000,|",1.0,"宋体",9,1+2)\n pos = split(pos,"|")\n If int(pos(0)) >= 0 Then\n      dm.MoveTo int(pos(1)),int(pos(2))\n End If\n注: 对于如何获取字体尺寸以及名字等信息，可以参考视频教程，如何使用系统字库.
FindStrWithFontEx(x1,y1,x2,y2,string,color_format,sim,font_name,font_size,flag) = 同FindStrEx，但是不使用SetDict设置的字库，而利用系统自带的字库，速度比FindStrEx稍慢\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n string 字符串:待查找的字符串, 可以是字符串组合，比如"长安|洛阳|大雁塔",中间用"|"来分割字符串\n color_format 字符串:颜色格式串, 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n font_name 字符串:系统字体名,比如"宋体"\n font_size 整形数:系统字体尺寸，这个尺寸一定要以大漠综合工具获取的为准.如果获取尺寸看视频教程.\n flag 整形数:字体类别 取值可以是以下值的组合,比如1+2+4+8,2+4. 0表示正常字体.\n     1 : 粗体\n     2 : 斜体\n     4 : 下划线\n     8 : 删除线\n返回值:\n字符串:\n 返回所有找到的坐标集合,格式如下:\n "id,x0,y0|id,x1,y1|......|id,xn,yn"\n 比如"0,100,20|2,30,40" 表示找到了两个,第一个,对应的是序号为0的字符串,坐标是(100,20),第二个是序号为2的字符串,坐标(30,40)\n 示例:\n dm_ret = dm.FindStrWithFontEx(0,0,2000,2000,"长安|洛阳","9f2e3f-000000",1.0,"宋体",9,1+2)\n If len(dm_ret) > 0 Then\n    ss = split(dm_ret,"|")\n    index = 0\n    count = UBound(ss) + 1\n    Do While index < count\n       TracePrint ss(index)\n       sss = split(ss(index),",")\n       id = int(sss(0))\n       x = int(sss(1))\n       y = int(sss(2))\n       dm.MoveTo x,y\n       Delay 1000\n       index = index+1\n    Loop\n End If  \n注: 对于如何获取字体尺寸以及名字等信息，可以参考视频教程，如何使用系统字库.
GetDictCount(index) = 获取指定的字库中的字符数量.\n参数定义:\nindex 整形数: 字库序号(0-9)\n返回值:\n整形数:\n 字库数量\n示例:\n count = dm.GetDictCount(0)\n TracePrint "0号字库使用的字库数量是:"&count
GetDictInfo(str,font_name,font_size,flag) = 根据指定的文字，以及指定的系统字库信息，获取字库描述信息.\n参数定义:\nstr 字符串:需要获取的字符串\n font_name 字符串:系统字体名,比如"宋体"\n font_size 整形数:系统字体尺寸，这个尺寸一定要以大漠综合工具获取的为准.如何获取尺寸看视频教程.\n flag 整形数:字体类别 取值可以是以下值的组合,比如1+2+4+8,2+4. 0表示正常字体.\n     1 : 粗体\n     2 : 斜体\n     4 : 下划线\n     8 : 删除线\n返回值:\n字符串:\n 返回字库信息,每个字符的字库信息用"|"来分割\n示例:\n// 下面的代码是获取"回收站"这3个字符的字库信息，然后加入到字库1中.\n font_desc = dm.GetDictInfo("回收站","宋体",9,0)\n font_desc = split(font_desc,"|")\n count = ubound(font_desc)\n for i = 0 to count\n     TracePrint font_desc(i)\n     dm.AddDict 1,font_desc(i)\n next
GetNowDict() = 获取当前使用的字库序号(0-9)\n参数定义:\n返回值:\n整形数:\n 字库序号(0-9)\n示例:\n index = dm.GetNowDict()\n TracePrint "当前使用的字库序号是:"&index
GetResultCount(ret) = 对插件部分接口的返回值进行解析,并返回ret中的坐标个数\n参数定义:\n ret 字符串: 部分接口的返回串\n返回值:\n整形数:\n 返回ret中的坐标个数\n示例:\n s = dm.FindColorEx(0,0,2000,2000,"123456-000000|abcdef-202020",1.0,0)\n count = dm.GetResultCount(s)\n MessageBox count
GetResultPos(ret,index,intX,intY) = 对插件部分接口的返回值进行解析,并根据指定的第index个坐标,返回具体的值\n参数定义:\n ret 字符串:部分接口的返回串\n index 整形数: 第几个坐标\n intX 变参指针: 返回X坐标\n intY 变参指针: 返回Y坐标\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n s = dm.FindColorEx(0,0,2000,2000,"123456-000000|abcdef-202020",1.0,0)\n count = dm.GetResultCount(s)\n index = 0\n Do While index < count\n     dm_ret = dm.GetResultPos(s,index,intX,intY)\n     MessageBox intX&","&intY \n     index = index + 1 \n Loop
GetWordResultCount(str) = 在使用GetWords进行词组识别以后,可以用此接口进行识别词组数量的计算.\n参数定义:\n str 字符串: GetWords接口调用以后的返回值\n返回值:\n整形数:\n 返回词组数量\n示例:\n s = dm.GetWords(0,0,2000,2000,"000000-000000",1.0)\n count = dm.GetWordResultCount(s)\n MessageBox count 
GetWordResultPos(str,index,intX,intY) = 在使用GetWords进行词组识别以后,可以用此接口进行识别各个词组的坐标\n参数定义:\n str 字符串: GetWords的返回值\nindex 整形数: 表示第几个词组\nintX 变参指针: 返回的X坐标\nintY 变参指针: 返回的Y坐标\n返回值:\n整形数:\n 0: 失败\n1: 成功\n示例:\n s = dm.GetWords(0,0,2000,2000,"000000-000000",1.0)\n count = dm.GetWordResultCount(s)\n index = 0\n Do While index < count\n     dm_ret = dm.GetWordResultPos(s,index,intX,intY)\n     MessageBox intX&","&intY \n     index = index + 1 \n Loop 
GetWordResultStr(str,index) = 在使用GetWords进行词组识别以后,可以用此接口进行识别各个词组的内容\n参数定义:\n str 字符串: GetWords的返回值\nindex 整形数: 表示第几个词组\n返回值:\n字符串:\n 返回的第index个词组内容\n示例:\n s = dm.GetWords(0,0,2000,2000,"000000-000000",1.0)\n count = dm.GetWordResultCount(s)\n index = 0\n Do While index < count\n     word = dm.GetWordResultStr(s,index)\n     MessageBox word \n     index = index + 1 \n Loop 
GetWords(x1, y1, x2, y2, color, sim) = 根据指定的范围,以及设定好的词组识别参数(一般不用更改,除非你真的理解了)\n识别这个范围内所有满足条件的词组. 比较适合用在未知文字的情况下,进行不定识别.\n参数定义:\n x1 整形数:左上角X坐标\n y1 整形数:左上角Y坐标\n x2 整形数:右下角X坐标\n y2 整形数:右下角Y坐标\n color 字符串: 颜色格式串.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度 0.1-1.0 \n返回值:\n字符串:\n 识别到的格式串,要用到专用函数来解析\n示例:\n s = dm.GetWords(0,0,2000,2000,"000000-000000",1.0)\n count = dm.GetWordResultCount(s)\n index = 0\n Do While index < count\n     dm_ret = dm.GetWordResultPos(s,index,intX,intY)\n     word = dm.GetWordResultStr(s,index)\n     MessageBox intX&","&intY&","&word\n     index = index + 1 \n Loop 
GetWordsNoDict(x1, y1, x2, y2, color) = 根据指定的范围,以及设定好的词组识别参数(一般不用更改,除非你真的理解了)\n识别这个范围内所有满足条件的词组. 这个识别函数不会用到字库。只是识别大概形状的位置 \n参数定义:\n x1 整形数:左上角X坐标\ny1 整形数:左上角Y坐标\nx2 整形数:右下角X坐标\ny2 整形数:右下角Y坐标\ncolor 字符串: 颜色格式串.注意，RGB和HSV格式都支持.\n返回值:\n字符串:\n 识别到的格式串,要用到专用函数来解析\n示例:\n s = dm.GetWordsNoDict(0,0,2000,2000,"000000-000000")\n count = dm.GetResultCount(s)\n index = 0\n Do While index < count\n     dm_ret = dm.GetResultPos(s,index,intX,intY)\n     MessageBox intX&","&intY\n     index = index + 1 \n Loop 
Ocr(x1,y1,x2,y2,color_format,sim) = 识别屏幕范围(x1,y1,x2,y2)内符合color_format的字符串,并且相似度为sim,sim取值范围(0.1-1.0),\n这个值越大越精确,越大速度越快,越小速度越慢,请斟酌使用!\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n color_format 字符串:颜色格式串. 可以包含换行分隔符,语法是","后加分割字符串. 具体可以查看下面的示例.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n返回值:\n字符串:\n 返回识别到的字符串\n示例:\n //RGB单色识别\n s = dm.Ocr(0,0,2000,2000,"9f2e3f-000000",1.0)\n MessageBox s\n//RGB单色差色识别\n s = dm.Ocr(0,0,2000,2000,"9f2e3f-030303",1.0)\n MessageBox s\n//RGB多色识别(最多支持10种,每种颜色用"|"分割)\n s = dm.Ocr(0,0,2000,2000,"9f2e3f-030303|2d3f2f-000000|3f9e4d-100000",1.0)\n MessageBox s\n//HSV多色识别(最多支持10种,每种颜色用"|"分割)\n s = dm.Ocr(0,0,2000,2000,"20.30.40-0.0.0|30.40.50-0.0.0",1.0)\n MessageBox s\n//识别后,每行字符串用指定字符分割\n 比如用"|"字符分割\n s = dm.Ocr(0,0,2000,2000,"9f2e3f-000000,|",1.0)\n MessageBox s\n//比如用回车换行分割\n s = dm.Ocr(0,0,2000,2000,"9f2e3f-000000,"+vbcrlf,1.0)\n MessageBox s\n//背景色识别\n //比如要识别背景色为白色,文字颜色未知的字形\n s = dm.Ocr(0,0,2000,2000,"b@ffffff-000000",1.0)\n MessageBox s\n //注: 在color_fomat最前面加上"b@"表示后面的颜色描述是针对背景色,而非字的颜色.
OcrEx(x1,y1,x2,y2,color_format,sim) = 识别屏幕范围(x1,y1,x2,y2)内符合color_format的字符串,并且相似度为sim,sim取值范围(0.1-1.0),\n这个值越大越精确,越大速度越快,越小速度越慢,请斟酌使用!\n这个函数可以返回识别到的字符串，以及每个字符的坐标.\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n color_format 字符串:颜色格式串.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n返回值:\n字符串:\n 返回识别到的字符串 格式如  "识别到的信息|x0,y0|…|xn,yn"\n示例:\n和Ocr函数相同，只是结果处理有所不同 如下\nss = dm.OcrEx(0,0,2000,2000,"ffffff|000000",1.0)\n ss = split(ss,"|")\n MessageBox "识别到的字符串:"&ss(0)\n ss_len = len(ss(0))\n for i = 1 to ss_len \n     MessageBox "第("&i&")的坐标是"&ss(i)\n next
OcrInFile(x1, y1, x2, y2, pic_name, color_format, sim) = 识别位图中区域(x1,y1,x2,y2)的文字\n参数定义:\n x1 整形数:区域的左上X坐标\n y1 整形数:区域的左上Y坐标\n x2 整形数:区域的右下X坐标\n y2 整形数:区域的右下Y坐标\n pic_name 字符串:图片文件名\n color_format 字符串:颜色格式串.注意，RGB和HSV格式都支持.\n sim 双精度浮点数:相似度,取值范围0.1-1.0\n返回值:\n 字符串:\n 返回识别到的字符串\n示例:\n s = dm.OcrInFile(0,0,2000,2000,"test.bmp","000000-000000",1.0)\n MessageBox s
SaveDict(index,file) = 保存指定的字库到指定的文件中.\n参数定义:\n index 整形数:字库索引序号 取值为0-9对应10个字库\n file 字符串:文件名\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.SetPath "c:\test_game"\n dm.AddDict 0,"FFF00A7D49292524A7D402805FFC$回$0.0.54$11"\n dm.AddDict 0,"3F0020087FF08270B9A108268708808$收$0.0.43$11"\n dm.AddDict 0,"2055C98617420807C097F222447C800$站$0.0.44$11"\n dm.SaveDict 0,"test.txt"  
SetColGapNoDict(col_gap) = 高级用户使用,在不使用字库进行词组识别前,可设定文字的列距,默认列距是1\n参数定义:\n col_gap 整形数:文字列距\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetColGapNoDict(3)
SetDict(index,file) = 设置字库文件\n参数定义:\nindex 整形数:字库的序号,取值为0-9,目前最多支持10个字库\n file 字符串:字库文件名\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetDict(0,"test.txt")\n 注: 此函数速度很慢，全局初始化时调用一次即可，切换字库用UseDict
SetDictPwd(pwd) = 设置字库的密码,在SetDict前调用,目前的设计是,所有字库通用一个密码.\n参数定义:\n pwd 字符串:字库密码\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetDictPwd("1234")\n注意:如果使用了多字库,所有字库的密码必须一样. 此函数必须在SetDict之前调用,否则会解密失败.
SetExactOcr(exact_ocr) = 高级用户使用,在使用文字识别功能前，设定是否开启精准识别.\n参数定义:\n exact_ocr 整形数: 0 表示关闭精准识别\n            1 开启精准识别\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n// 开启精准识别\n dm_ret = dm.SetExactOcr(1)\n注意: 精准识别开启后，行间距和列间距会对识别结果造成较大影响，可以在工具中进行测试.
SetMinColGap(min_col_gap) = 高级用户使用,在识别前,如果待识别区域有多行文字,可以设定列间距,默认的列间距是0,\n如果根据情况设定,可以提高识别精度。一般不用设定。\n参数定义:\n min_col_gap 整形数:最小列间距\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetMinColGap(1)\n注意：此设置如果不为0,那么将不能识别连体字 慎用.
SetMinRowGap(min_row_gap) = 高级用户使用,在识别前,如果待识别区域有多行文字,可以设定行间距,默认的行间距是1,\n如果根据情况设定,可以提高识别精度。一般不用设定。\n参数定义:\n min_row_gap 整形数:最小行间距\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetMinRowGap(2)
SetRowGapNoDict(row_gap) = 高级用户使用,在不使用字库进行词组识别前,可设定文字的行距,默认行距是1\n参数定义:\n row_gap 整形数:文字行距\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm_ret = dm.SetRowGapNoDict(3)
SetWordGap(word_gap) = 高级用户使用,在识别词组前,可设定词组间的间隔,默认的词组间隔是5\n参数定义:\n word_gap 整形数:单词间距\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetWordGap(5)
SetWordGapNoDict(word_gap) = 高级用户使用,在不使用字库进行词组识别前,可设定词组间的间隔,默认的词组间隔是5\n参数定义:\n word_gap 整形数:单词间距\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetWordGapNoDict(1)
SetWordLineHeight(line_height) = 高级用户使用,在识别词组前,可设定文字的平均行高,默认的词组行高是10\n参数定义:\n line_height 整形数:行高\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetWordLineHeight(15)
SetWordLineHeightNoDict(line_height) = 高级用户使用,在不使用字库进行词组识别前,可设定文字的平均行高,默认的词组行高是10\n参数定义:\n line_height 整形数:行高\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.SetWordLineHeightNoDict(15)
UseDict(index) = 表示使用哪个字库文件进行识别(index范围:0-9)\n设置之后，永久生效，除非再次设定  \n参数定义:\n index 整形数:字库编号(0-9)\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm_ret = dm.UseDict(1)\n ss = dm.Ocr(0,0,2000,2000,"FFFFFF-000000",1.0)\n dm_ret = dm.UseDict(0)
ActiveInputMethod(hwnd,input_method) = 激活指定窗口所在进程的输入法. \n参数定义:\nhwnd 整形数: 窗口句柄\n input_method 字符串: 输入法名字。 具体输入法名字对应表查看注册表中以下位置:\nHKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layouts\n下面的每一项下的Layout Text的值就是输入法名字\n比如 "中文 - QQ拼音输入法"  \n以此类推.\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm_ret = dm.ActiveInputMethod(hwnd,"中文 - QQ拼音输入法")\n if dm_ret = 1 then\n     msgbox "QQ输入法开启成功"\n end if  
CheckInputMethod(hwnd,input_method) = 检测指定窗口所在线程输入法是否开启\n参数定义:\nhwnd 整形数: 窗口句柄\n input_method 字符串: 输入法名字。 具体输入法名字对应表查看注册表中以下位置:\nHKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layouts\n下面的每一项下的Layout Text的值就是输入法名字\n比如 "中文 - QQ拼音输入法"  \n以此类推.\n返回值:\n整形数:\n 0 : 未开启\n1 : 开启\n示例:\n dm_ret = dm.CheckInputMethod(hwnd,"中文 - QQ拼音输入法")\n if dm_ret = 1 then\n     msgbox "QQ输入法开启拉"\n end if
FindInputMethod(input_method) = 检测系统中是否安装了指定输入法\n参数定义:\n input_method 字符串: 输入法名字。 具体输入法名字对应表查看注册表中以下位置:\nHKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layouts\n下面的每一项下的Layout Text的值就是输入法名字\n比如 "中文 - QQ拼音输入法"  \n以此类推.\n返回值:\n整形数:\n 0 : 未安装\n1 : 安装了\n示例:\n dm_ret = dm.FindInputMethod("中文 - QQ拼音输入法")\n if dm_ret = 1 then\n     msgbox "QQ输入法安装啦"\n end if
AsmAdd(asm_ins) = 添加指定的MASM汇编指令\n 参数定义:\n asm_ins 字符串:MASM汇编指令,大小写均可以  比如 "mov eax,1"\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.AsmAdd "push 0100"\n dm.AsmAdd "push 060304d"\n dm.AsmAdd "call 0678fed"  \n注: 简单游平台不支持此接口
AsmClear() = 清除汇编指令缓冲区 用AsmAdd添加到缓冲的指令全部清除\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.AsmClear  \n注: 简单游平台不支持此接口
AsmCode(base_addr) = 把汇编缓冲区的指令转换为机器码 并用16进制字符串的形式输出\n 参数定义:\nbase_addr 字符串: 用AsmAdd添加到缓冲区的第一条指令所在的地址\n返回值:\n字符串:\n 机器码，比如 "aa bb cc"这样的形式\n示例:\ncode = dm.AsmCode(&H405940)\n MessageBox code  \n注: 简单游平台不支持此接口
Assemble(asm_code,base_addr,is_upper) = 把指定的机器码转换为汇编语言输出\n 参数定义:\n asm_code 字符串: 机器码，形式如 "aa bb cc"这样的16进制表示的字符串(空格无所谓)\nbase_addr 整形数: 指令所在的地址\nis_upper 整形数: 表示转换的汇编语言是否以大写输出\n返回值:\n字符串:\n MASM汇编语言字符串\n示例:\ndm_ret = dm.Assemble("81 05 E0 5A 47 00 01 00 00 00",&H435fde,0)\n MessageBox dm_ret  \n注: 简单游平台不支持此接口
ClientToScreen(hwnd,x,y) = 把窗口坐标转换为屏幕坐标 \n参数定义:\n hwnd 整形数: 指定的窗口句柄\nx 变参指针: 窗口X坐标\ny 变参指针: 窗口Y坐标\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\nx = 0:y = 0 \n dm_ret = dm.ClientToScreen(hwnd,x,y) 
FindWindow(class,title) = 查找符合类名或者标题名的顶层可见窗口\n参数定义:\n class 字符串: 窗口类名，如果为空，则匹配所有. 这里的匹配是模糊匹配.\ntitle 字符串: 窗口标题,如果为空，则匹配所有.这里的匹配是模糊匹配.\n返回值:\n整形数:\n 整形数表示的窗口句柄，没找到返回0\n示例:\nhwnd = dm.FindWindow("","记事本") 
FindWindowEx(parent,class,title) = 查找符合类名或者标题名的顶层可见窗口,如果指定了parent,则在parent的第一层子窗口中查找.\n参数定义:\n parent 整形数: 父窗口句柄，如果为空，则匹配所有顶层窗口\n class 字符串: 窗口类名，如果为空，则匹配所有. 这里的匹配是模糊匹配.\ntitle 字符串: 窗口标题,如果为空，则匹配所有. 这里的匹配是模糊匹配.\n返回值:\n整形数:\n 整形数表示的窗口句柄，没找到返回0\n示例:\nhwnd = dm.FindWindowEx(0,"","记事本") 
GetClientRect(hwnd,x1,y1,x2,y2) = 获取窗口客户区域在屏幕上的位置\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n x1 变参指针: 返回窗口客户区左上角X坐标\ny1 变参指针: 返回窗口客户区左上角Y坐标\nx2 变参指针: 返回窗口客户区右下角X坐标\ny2 变参指针: 返回窗口客户区右下角Y坐标\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm_ret = dm.GetClientRect(hwnd,x1,y1,x2,y2)
GetClientSize(hwnd,width,height) = 获取窗口客户区域的宽度和高度\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n width 变参指针: 宽度\nheight 变参指针: 高度\n返回值:\n 整形数:\n 0: 失败\n 1: 成功\n示例:\ndm_ret = dm.GetClientSize(hwnd,w,h) \n TracePrint "宽度:"& w &",高度:"& h
GetForegroundFocus() = 获取顶层活动窗口中具有输入焦点的窗口句柄 \n参数定义:\n返回值:\n整形数:\n 返回整型表示的窗口句柄\n示例:\nhwnd = dm.GetForegroundFocus()
GetForegroundWindow() = 获取顶层活动窗口,可以获取到按键自带插件无法获取到的句柄\n参数定义:\n返回值:\n整形数:\n 返回整型表示的窗口句柄\n示例:\nhwnd = dm.GetForegroundWindow()
GetMousePointWindow() = 获取鼠标指向的窗口句柄,可以获取到按键自带的插件无法获取到的句柄\n参数定义:\n返回值:\n整形数:\n 返回整型表示的窗口句柄\n示例:\nhwnd = dm.GetMousePointWindow()
GetPointWindow(x,y) = 获取给定坐标的窗口句柄,可以获取到按键自带的插件无法获取到的句柄\n参数定义:\nX 整形数: 屏幕X坐标\nY 整形数: 屏幕Y坐标\n返回值:\n整形数:\n 返回整型表示的窗口句柄\n示例:\nhwnd = dm.GetPointWindow(100,100)
GetSpecialWindow(flag) = 获取特殊窗口\n参数定义:\nFlag 整形数: 取值定义如下\n0 : 获取桌面窗口\n1 : 获取任务栏窗口\n返回值:\n整形数:\n 以整型数表示的窗口句柄\n示例:\ndesk_win = dm.GetSpecialWindow(0) 
GetWindow(hwnd,flag) = 获取给定窗口相关的窗口句柄\n参数定义:\nhwnd 整形数: 窗口句柄\nflag 整形数: 取值定义如下\n0 : 获取父窗口\n1 : 获取第一个儿子窗口\n2 : 获取First 窗口\n3 : 获取Last窗口\n4 : 获取下一个窗口\n5 : 获取上一个窗口\n6 : 获取拥有者窗口\n7 : 获取顶层窗口\n返回值:\n整形数:\n 返回整型表示的窗口句柄\n示例:\nown_hwnd = dm.GetWindow(hwnd,6)
GetWindowClass(hwnd) = 获取窗口的类名\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n返回值:\n字符串:\n 窗口的类名\n示例:\nclass_name = dm.GetWindowClass(hwnd) 
GetWindowProcessId(hwnd) = 获取指定窗口所在的进程ID.\n参数定义:\nhwnd 整形数: 窗口句柄\n返回值:\n整形数:\n 返回整型表示的是进程ID\n示例:\nprocess_id = dm.GetWindowProcessId(hwnd)
GetWindowProcessPath(hwnd) = 获取指定窗口所在的进程的exe文件全路径.\n参数定义:\nhwnd 整形数: 窗口句柄\n返回值:\n字符串:\n 返回字符串表示的是exe全路径名\n示例:\nprocess_path = dm.GetWindowProcessPath(hwnd)
GetWindowRect(hwnd,x1,y1,x2,y2) = 获取窗口在屏幕上的位置\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n x1 变参指针: 返回窗口左上角X坐标\ny1 变参指针: 返回窗口左上角Y坐标\nx2 变参指针: 返回窗口右下角X坐标\ny2 变参指针: 返回窗口右下角Y坐标\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm_ret = dm.GetWindowRect(hwnd,x1,y1,x2,y2)
GetWindowState(hwnd,flag) = 获取指定窗口的一些属性\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n flag 整形数: 取值定义如下\n0 : 判断窗口是否存在\n1 : 判断窗口是否处于激活\n2 : 判断窗口是否可见\n3 : 判断窗口是否最小化\n4 : 判断窗口是否最大化\n5 : 判断窗口是否置顶\n6 : 判断窗口是否无响应\n返回值:\n整形数:\n 0: 不满足条件\n 1: 满足条件\n示例:\ndm_ret = dm.GetWindowState(hwnd,3) \n If dm_ret = 1 Then\n     MessageBox "窗口已经最小化了"\n End If
GetWindowTitle(hwnd) = 获取窗口的标题\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n返回值:\n字符串:\n 窗口的标题\n示例:\ntitle = dm.GetWindowTitle(hwnd) 
MoveWindow(hwnd,x,y) = 移动指定窗口到指定位置\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n x 整形数: X坐标\ny 整形数: Y坐标\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm.MoveWindow hwnd,-10,-10
ScreenToClient(hwnd,x,y) = 把屏幕坐标转换为窗口坐标\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n x 变参指针: 屏幕X坐标\ny 变参指针: 屏幕Y坐标\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\nx = 100:y = 100 \n dm_ret = dm.ScreenToClient(hwnd,x,y) 
SendPaste(hwnd) = 向指定窗口发送粘贴命令. 把剪贴板的内容发送到目标窗口.\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm.SetClipboard "abcd"\n dm.SendPaste hwnd\n注:剪贴板是公共资源，多个线程同时设置剪贴板时,会产生冲突，必须用互斥信号保护.
SendString(hwnd,str) = 向指定窗口发送文本数据\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n str 字符串: 发送的文本数据\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm.SendString hwnd,"我是来测试的"
SendString2(hwnd,str) = 向指定窗口发送文本数据\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n str 字符串: 发送的文本数据\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm.SendString2 hwnd,"我是来测试的"\n注: 此接口为老的SendString，如果新的SendString不能输入，可以尝试此接口.
SetClientSize(hwnd,width,height) = 设置窗口客户区域的宽度和高度\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n width 整形数: 宽度\nheight 整形数: 高度\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm_ret = dm.SetClientSize(hwnd,800,600) 
SetWindowSize(hwnd,width,height) = 设置窗口的大小\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n width 整形数: 宽度\nheight 整形数: 高度\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm_ret = dm.SetWindowSize(hwnd,300,400)
SetWindowState(hwnd,flag) = 设置窗口的状态\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n flag 整形数: 取值定义如下\n0 : 关闭指定窗口\n1 : 激活指定窗口\n2 : 最小化指定窗口,但不激活\n3 : 最小化指定窗口,并释放内存,但同时也会激活窗口.\n4 : 最大化指定窗口,同时激活窗口.\n5 : 恢复指定窗口 ,但不激活\n6 : 隐藏指定窗口\n7 : 显示指定窗口\n8 : 置顶指定窗口\n9 : 取消置顶指定窗口\n10 : 禁止指定窗口\n11 : 取消禁止指定窗口\n12 : 恢复并激活指定窗口\n13 : 强制结束窗口所在进程.\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm_ret = dm.SetWindowState(hwnd,0) 
SetWindowText(hwnd,title) = 设置窗口的标题\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n titie 字符串: 标题\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm_ret = dm.SetWindowText(hwnd,"test") 
SetWindowTransparent(hwnd,trans) = 设置窗口的透明度\n参数定义:\n hwnd 整形数: 指定的窗口句柄\n trans 整形数: 透明度 取值(0-255) 越小透明度越大 0为完全透明(不可见) 255为完全显示(不透明)\n返回值:\n整形数:\n 0: 失败\n 1: 成功\n示例:\ndm_ret = dm.SetWindowTransparent(hwnd,200) \n注 :  此接口不支持WIN98
FaqCancel() = 可以把上次FaqPost的发送取消,接着下一次FaqPost\n参数定义:\n返回值:\n整形数:\n 0 : 失败\n 1 : 成功\n示例:\n// 截取这个范围内,3秒动画,图像质量为中等50,动画帧率间隔为100ms\n handle = dm.FaqCapture(50,50,300,400,50,100,3000)\n // 调用FaqPost异步发送\n dm.FaqCancel\n dm_ret = dm.FaqPost("192.168.1.100:12345",handle,1,3 * 60 * 1000)\n If dm_ret = 0 Then\n     MessageBox "发送失败，可能上个FaqPost还未处理完毕"\n     EndScript\n End If\n // 不影响脚本运行\n    result = dm.FaqFetch()\n    If len(result) > 0 Then\n         MessageBox "服务器返回结果 = "&result\n    End If\n    // 做其他的事情 这里就假设为延时\n    Delay 1000\n Loop
FaqCapture(x1, y1, x2, y2, quality, delay, time) = 截取指定范围内的动画或者图像,并返回此句柄.\n参数定义:\n x1 整形数: 左上角X坐标\ny1 整形数: 左上角Y坐标\nx2 整形数: 右下角X坐标\ny2 整形数: 右下角Y坐标\nquality 整形数: 图像或动画品质,或者叫压缩率,此值越大图像质量越好 取值范围（1-100）\ndelay 整形数: 截取动画时用,表示相隔两帧间的时间间隔,单位毫秒 （如果只是截取静态图像,这个参数必须是0）\ntime 整形数: 表示总共截取多久的动画,单位毫秒 （如果只是截取静态图像,这个参数必须是0）\n返回值:\n整形数:\n 图像或者动画句柄\n示例:\n// 截取这个范围内,3秒动画,图像质量为中等50,动画帧率间隔为100ms\n handle = dm.FaqCapture(intX - 50,intY - 232,intX+272,intY-12,50,100,3000)\n注 : 从插件版本2.1119之后，接口FaqCapture返回handle，不需要再手动调用FaqRelease释放了。插件已经自动释放了.
FaqFetch() = 获取由FaqPost发送后，由服务器返回的答案.\n参数定义:\n返回值:\n字符串:\n 如果此函数调用失败,那么返回值如下\n"Error:错误描述" \n如果函数调用成功,那么返回值如下\n"OK:答案"\n根据FaqPost中 request_type取值的不同,返回值不同\n当request_type 为0时,答案的格式为"x,y" (不包含引号)\n当request_type 为1时,答案的格式为"1" "2" "3" "4" "5" "6" (不包含引号)\n当request_type 为2时,答案就是要求的答案 比如 "李白" (不包含引号)\n当request_type 为3时,答案的格式为"x1,y1|x2,y2" 比如 "20,30|78,68" (不包含引号)\n如果返回为空字符串，表示FaqPost还未处理完毕,或者没有调用过FaqPost.\n示例:\n// 截取这个范围内,3秒动画,图像质量为中等50,动画帧率间隔为100ms\n handle = dm.FaqCapture(50,50,300,400,50,100,3000)\n // 调用FaqPost异步发送\n dm_ret = dm.FaqPost("192.168.1.100:12345",handle,1,3 * 60 * 1000)\n If dm_ret = 0 Then\n     MessageBox "发送失败，可能上个FaqPost还未处理完毕"\n     EndScript\n End If\n // 不影响脚本运行\n    result = dm.FaqFetch()\n    If len(result) > 0 Then\n         MessageBox "服务器返回结果 = "&result\n    End If\n    // 做其他的事情 这里就假设为延时\n    Delay 1000\n Loop\n注: 如果此函数调用成功后，插件内部状态会再次重置为未处理状态，可以接着处理FaqPost接口.
FaqGetSize(handle) = 获取句柄所对应的数据包的大小,单位是字节\n参数定义:\n handle 整形数: 由FaqCapture返回的句柄\n返回值:\n整形数:\n 数据包大小,一般用于判断数据大小,选择合适的压缩比率.\n示例:\n// 截取这个范围内,3秒动画,图像质量为中等50,动画帧率间隔为100ms\n handle = dm.FaqCapture(intX - 50,intY - 232,intX+272,intY-12,50,100,3000)\n packet_size = dm.FaqGetSize(handle)\n MessageBox packet_size  
ExcludePos(all_pos,type,x1,y1,x2,y2) = 根据部分Ex接口的返回值，排除指定范围区域内的坐标.\n参数定义:\n all_pos 字符串: 坐标描述串。  一般是FindStrEx,FindStrFastEx,FindStrWithFontEx, FindColorEx, FindMultiColorEx,和FindPicEx的返回值.\n type 整形数:  取值为0或者1\n     如果all_pos的内容是由FindPicEx,FindStrEx,FindStrFastEx,FindStrWithFontEx返回，那么取值为0\n     如果all_pos的内容是由FindColorEx, FindMultiColorEx返回，那么取值为1\nx1 整形数: 左上角横坐标\n y1 整形数: 左上角纵坐标\n x2 整形数: 右下角横坐标\n y2 整形数: 右下角纵坐标\n返回值:\n字符串:\n 经过筛选以后的返回值，格式和type指定的一致.\n示例:\nret = dm.FindColorEx(0,0,2000,2000,"aaaaaa-000000",1.0,0)\n ret = dm.ExcludePos(ret,1,100,100,300,400)\n TracePrint ret\nret = dm.FindPicEx(0,0,2000,2000,"a.bmp","000000",1.0,0)\n ret = dm.ExcludePos(ret,0,100,100,300,400)\n TracePrint ret
FindNearestPos(all_pos,type,x,y) = 根据部分Ex接口的返回值，然后在所有坐标里找出距离指定坐标最近的那个坐标.\n参数定义:\n all_pos 字符串: 坐标描述串。  一般是FindStrEx,FindStrFastEx,FindStrWithFontEx, FindColorEx, FindMultiColorEx,和FindPicEx的返回值.\n type 整形数:  取值为0或者1\n     如果all_pos的内容是由FindPicEx,FindStrEx,FindStrFastEx,FindStrWithFontEx返回，那么取值为0\n     如果all_pos的内容是由FindColorEx, FindMultiColorEx返回，那么取值为1\nx 整形数: 横坐标\n y 整形数: 纵坐标\n返回值:\n 字符串:\n 返回的格式和type有关，如果type为0，那么返回的格式是"id,x,y"\n如果type为1,那么返回的格式是"x,y".\n示例:\nret = dm.FindColorEx(0,0,2000,2000,"aaaaaa-000000",1.0,0)\n ret = dm.FindNearestPos(ret,1,100,100)\n TracePrint ret\nret = dm.FindPicEx(0,0,2000,2000,"a.bmp","000000",1.0,0)\n ret = dm.FindNearestPos(ret,0,100,100)\n TracePrint ret
SortPosDistance(all_pos,type,x,y) = 根据部分Ex接口的返回值，然后对所有坐标根据对指定坐标的距离进行从小到大的排序.\n参数定义:\n all_pos 字符串: 坐标描述串。  一般是FindStrEx,FindStrFastEx,FindStrWithFontEx, FindColorEx, FindMultiColorEx,和FindPicEx的返回值.\n type 整形数:  取值为0或者1\n     如果all_pos的内容是由FindPicEx,FindStrEx,FindStrFastEx,FindStrWithFontEx返回，那么取值为0\n     如果all_pos的内容是由FindColorEx, FindMultiColorEx返回，那么取值为1\nx 整形数: 横坐标\n y 整形数: 纵坐标\n返回值:\n 字符串:\n 返回的格式和type指定的格式一致.\n示例:\nret = dm.FindColorEx(0,0,2000,2000,"aaaaaa-000000",1.0,0)\n ret = dm.SortPosDistance(ret,1,100,100)\n TracePrint ret\nret = dm.FindPicEx(0,0,2000,2000,"a.bmp","000000",1.0,0)\n ret = dm.SortPosDistance(ret,0,100,100)\n TracePrint ret
Beep(f,duration) = 蜂鸣器.\n参数定义:\nf 整形数: 频率\nduration 整形数: 时长(ms).\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm.Beep 1000,1000
CheckUAC() = 检测当前系统是否有开启UAC(用户账户控制).\n参数定义:\n返回值:\n整形数:\n 0 : 没开启UAC\n1 : 开启了UAC\n示例:\n if dm.CheckUAC() = 1 then\n     TracePrint "当前系统开启了用户账户控制"\n end if\n注: 只有WIN7 VISTA WIN2008以及以上系统才有UAC设置
DisablePowerSave() = 关闭电源管理，不会进入睡眠.\n参数定义:\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm.DisablePowerSave\n注 :此函数调用以后，并不会更改系统电源设置. \n 此函数经常用在后台操作过程中. 避免被系统干扰.
DisableScreenSave() = 关闭屏幕保护.\n参数定义:\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm.DisableScreenSave\n注 : 调用此函数后，可能在系统中还是看到屏保是开启状态。但实际上屏保已经失效了.\n系统重启后，会失效。必须再重新调用一次.\n此函数经常用在后台操作过程中. 避免被系统干扰.
ExitOs(type) = 退出系统(注销 重启 关机) \n参数定义:\ntype 整形数: 取值为以下类型\n     0 : 注销系统\n     1 : 关机\n     2 : 重新启动\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm_ret = dm.ExitOs(1)  
GetClipboard() = 获取剪贴板的内容\n参数定义:\n返回值:\n字符串:\n 以字符串表示的剪贴板内容\n示例:\nTracePrint dm.GetClipboard()  
GetDir(type) = 得到系统的路径 \n参数定义:\ntype 整形数: 取值为以下类型\n     0 : 获取当前路径\n     1 : 获取系统路径(system32路径)\n     2 : 获取windows路径(windows所在路径)\n     3 : 获取临时目录路径(temp)\n     4 : 获取当前进程(exe)所在的路径\n返回值:\n字符串:\n 返回路径\n示例:\n path = dm.GetDir(2)  
GetDiskSerial() = 获取本机的硬盘序列号.支持ide scsi硬盘. 要求调用进程必须有管理员权限. 否则返回空串.\n参数定义:\n返回值:\n字符串:\n 字符串表达的硬盘序列号\n示例:\n sirial = dm.GetDiskSerial()
GetMachineCode() = 获取本机的机器码.(带网卡). 此机器码用于插件网站后台. 要求调用进程必须有管理员权限. 否则返回空串.\n参数定义:\n返回值:\n字符串:\n 字符串表达的机器机器码\n示例:\n machine_code = dm.GetMachineCode()\n注: 此机器码包含的硬件设备有硬盘,显卡,网卡等. 其它不便透露. 重装系统不会改变此值.\n另要注意,插拔任何USB设备,(U盘，U盾,USB移动硬盘,USB键鼠等),以及安装任何网卡驱动程序,(开启或者关闭无线网卡等)都会导致机器码改变.  
GetMachineCodeNoMac() = 获取本机的机器码.(不带网卡) 要求调用进程必须有管理员权限. 否则返回空串.\n参数定义:\n返回值:\n字符串:\n 字符串表达的机器机器码\n示例:\n machine_code = dm.GetMachineCodeNoMac()\n注: 此机器码包含的硬件设备有硬盘,显卡,等. 其它不便透露. 重装系统不会改变此值.\n另要注意,插拔任何USB设备,(U盘，U盾,USB移动硬盘,USB键鼠等),都会导致机器码改变.  
GetNetTime() = 从网络获取当前北京时间.\n参数定义:\n返回值:\n字符串:\n 时间格式. 和now返回一致. 比如"2001-11-01 23:14:08"\n示例:\n t = dm.GetNetTime()\n TracePrint "当前北京时间是:"&t  
GetOsType() = 得到操作系统的类型\n参数定义:\n返回值:\n整形数:\n 0 : win95/98/me/nt4.0\n1 : xp/2000\n2 : 2003\n3 : win7/vista/2008\n示例:\n os_type = dm.GetOsType()  
GetScreenDepth() = 获取屏幕的色深. \n参数定义:\n返回值:\n整形数:\n 返回系统颜色深度.(16或者32等)\n示例:\n Depth = dm.GetScreenDepth()  
GetScreenHeight() = 获取屏幕的高度. \n参数定义:\n返回值:\n整形数:\n 返回屏幕的高度\n示例:\n ScreenH = dm.GetScreenHeight()  
GetScreenWidth() = 获取屏幕的宽度. \n参数定义:\n返回值:\n整形数:\n 返回屏幕的宽度\n示例:\n ScreenW = dm.GetScreenWidth()  
GetTime() = 获取当前系统从开机到现在所经历过的时间，单位是毫秒\n参数定义:\n返回值:\n整形数:\n 时间(单位毫秒)\n示例:\n t1 = dm.GetTime()\n dm_ret = dm.FindPic(0,0,2000,2000,"test.bmp","000000",1.0,0,x,y)\n t2 = dm.GetTime()\n MessageBox (t2-t1)  
Is64Bit() = 判断当前系统是否是64位操作系统\n参数定义:\n返回值:\n整形数:\n 0 : 不是64位系统\n 1 : 是64位系统\n示例:\nif dm.Is64Bit() = 1 then\n     MessageBox "64位系统"\n else\n     MessageBox "不是64位系统"\n end if  
Play(media_file) = 播放指定的MP3或者wav文件.\n参数定义:\nmedia_file 字符串: 指定的音乐文件，可以采用文件名或者绝对路径的形式.\n返回值:\n整形数:\n 0 : 失败\n 非0表示当前播放的ID。可以用Stop来控制播放结束.\n示例:\n // test.mp3放于d:\test目录下\n dm.SetPath "d:\test"\n id = dm.Play("test.mp3")  \n// 绝对路径\n id = dm.Play("d:\test\test.mp3")\n Delay 1000\n dm.Stop id
SetClipboard(value) = 设置剪贴板的内容\n参数定义:\nvalue 字符串: 以字符串表示的剪贴板内容\n返回值:\n整形数:\n 0 : 失败\n 1 : 成功\n示例:\n dm.SetClipboard "abcd"  
SetScreen(width,height,depth) = 设置系统的分辨率 系统色深 \n参数定义:\nwidth 整形数: 屏幕宽度\nheight 整形数: 屏幕高度\ndepth 整形数: 系统色深\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm_ret = dm.SetScreen(1024,768,16)  
SetUAC(enable) = 设置当前系统的UAC(用户账户控制).\n参数定义:\nenable 整形数: 取值如下\n       0 : 关闭UAC\n        1 : 开启UAC\n返回值:\n 整形数:\n 0 : 操作失败\n1 : 操作成功\n示例:\n if dm.SetUAC(0) = 1 then\n     TracePrint "成功关闭了当前系统UAC设置"\n end if\n注: 只有WIN7 VISTA WIN2008以及以上系统才有UAC设置. 关闭UAC以后，必须重启系统才会生效.\n如果关闭了UAC，那么默认启动所有应用程序都是管理员权限，就不会再发生绑定失败这样的尴尬情况了.
Stop(id) = 停止指定的音乐.\n参数定义:\nid 整形数: Play返回的播放id.\n返回值:\n整形数:\n 0 : 失败\n 1 : 成功.\n示例:\n // test.mp3放于d:\test目录下\n dm.SetPath "d:\test"\n id = dm.Play("test.mp3")  \n// 绝对路径\n id = dm.Play("d:\test\test.mp3")\n Delay 1000\n dm.Stop id
GetCursorPos(x,y) = 获取鼠标位置.\n参数定义:\n x 变参指针: 返回X坐标\ny 变参指针: 返回Y坐标\n返回值:\n整形数:\n 0 : 失败\n1 : 成功\n示例:\n dm.GetCursorPos x,y\n MessageBox x&","&y\n注: 此接口在3.1223版本之后，返回的值的定义修改。  同大多数接口一样,返回的x,y坐标是根据绑定的鼠标参数来决定.  如果绑定了窗口，那么获取的坐标是相对于绑定窗口，否则是屏幕坐标.  \n 另外，此函数获取的坐标是真实的鼠标坐标，对于某些自绘鼠标位置不一定准确。请自行测试.
GetKeyState(vk_code) = 获取指定的按键状态.(前台信息,不是后台)\n参数定义:\n vk_code 整形数:虚拟按键码\n返回值:\n整形数:\n 0:弹起\n 1:按下\n示例:\n TracePrint dm.GetKeyState(13)
KeyDown(vk_code) = 按住指定的虚拟键码\n 参数定义:\n vk_code 整形数:虚拟按键码\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.KeyDown 13  
KeyDownChar(key_str) = 按住指定的虚拟键码\n 参数定义:\n key_str 字符串: 字符串描述的键码. 大小写无所谓. 点这里查看具体对应关系.\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.KeyDownChar "enter"\n dm.KeyDownChar "1"\n dm.KeyDownChar "F1"\n dm.KeyDownChar "a"\n dm.KeyDownChar "B"  
KeyPress(vk_code) = 按下指定的虚拟键码\n参数定义:\n vk_code 整形数:虚拟按键码\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.KeyPress 13
KeyPressChar(key_str) = 按下指定的虚拟键码\n参数定义:\n key_str 字符串: 字符串描述的键码. 大小写无所谓. 点这里查看具体对应关系.\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.KeyPressChar "enter"\n dm.KeyPressChar "1"\n dm.KeyPressChar "F1"\n dm.KeyPressChar "a"\n dm.KeyPressChar "B"
KeyUp(vk_code) = 弹起来虚拟键vk_code\n参数定义:\n vk_code 整形数:虚拟按键码\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.KeyUp 13
KeyUpChar(key_str) = 弹起来虚拟键key_str\n参数定义:\n key_str 字符串: 字符串描述的键码. 大小写无所谓. 点这里查看具体对应关系.\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.KeyUpChar "enter"\n dm.KeyUpChar "1"\n dm.KeyUpChar "F1"\n dm.KeyUpChar "a"\n dm.KeyUpChar "B"
LeftClick() = 按下鼠标左键\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.LeftClick
LeftDoubleClick() = 双击鼠标左键\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.LeftDoubleClick
LeftDown() = 按住鼠标左键\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.LeftDown
LeftUp() = 弹起鼠标左键\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.LeftUp
MiddleClick() = 按下鼠标中键\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.MiddleClick
MoveR(rx,ry) = 鼠标相对于上次的位置移动rx,ry\n参数定义:\n rx 整形数:相对于上次的X偏移\n ry 整形数:相对于上次的Y偏移\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.MoveR rx,ry  
MoveTo(x,y) = 把鼠标移动到目的点(x,y)\n参数定义:\n x 整形数:X坐标\n y 整形数:Y坐标\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.MoveTo x,y
MoveToEx(x,y,w,h) = 把鼠标移动到目的范围内的任意一点\n参数定义:\n x 整形数:X坐标\n y 整形数:Y坐标\n w 整形数:宽度(从x计算起)\n h 整形数:高度(从y计算起)\n返回值:\n字符串:\n 返回要移动到的目标点. 格式为x,y.  比如MoveToEx 100,100,10,10,返回值可能是101,102\n示例:\n// 移动鼠标到(100,100)到(110,110)这个矩形范围内的任意一点.\n dm.MoveToEx 100,100,10,10\n注: 此函数的意思是移动鼠标到指定的范围(x,y,x+w,y+h)内的任意随机一点.
RightClick() = 按下鼠标右键\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.RightClick
RightDown() = 按住鼠标右键\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.RightDown
RightUp() = 弹起鼠标右键\n 参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.RightUp
SetKeypadDelay(type,delay) = 设置按键时,键盘按下和弹起的时间间隔。高级用户使用。某些窗口可能需要调整这个参数才可以正常按键。\n 参数定义:\n type 字符串: 键盘类型,取值有以下\n     "normal" : 对应normal键盘  默认内部延时为30ms\n     "windows": 对应windows 键盘 默认内部延时为10ms\n     "dx" :     对应dx 键盘 默认内部延时为50ms\ndelay 整形数: 延时,单位是毫秒\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.SetKeypadDelay "dx",10  \n注 : 此函数影响的接口有KeyPress
SetMouseDelay(type,delay) = 设置鼠标单击或者双击时,鼠标按下和弹起的时间间隔。高级用户使用。某些窗口可能需要调整这个参数才可以正常点击。\n 参数定义:\n type 字符串: 鼠标类型,取值有以下\n     "normal" : 对应normal鼠标 默认内部延时为 30ms\n     "windows": 对应windows 鼠标 默认内部延时为 10ms\n     "dx" :     对应dx鼠标 默认内部延时为40ms\ndelay 整形数: 延时,单位是毫秒\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\ndm.SetMouseDelay "dx",10  \n注 : 此函数影响的接口有LeftClick RightClick MiddleClick LeftDoubleClick
WaitKey(vk_code,time_out) = 等待指定的按键按下 (前台,不是后台)\n参数定义:\n vk_code 整形数:虚拟按键码\n time_out 整形数:等待多久,单位毫秒. 如果是0，表示一直等待\n返回值:\n整形数:\n 0:超时\n 1:指定的按键按下\n示例:\n dm.WaitKey 66,0
WheelDown() = 滚轮向下滚\n参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.WheelDown
WheelUp() = 滚轮向上滚\n参数定义:\n返回值:\n整形数:\n 0:失败\n 1:成功\n示例:\n dm.WheelUp

end intellisense**/
```
